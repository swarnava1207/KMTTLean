{"name":"Mathlib.Tactic.Explode","instances":[],"imports":["Init","Lean.Elab.Command","Lean.PrettyPrinter","Mathlib.Tactic.Explode.Datatypes","Mathlib.Tactic.Explode.Pretty"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Explode.lean#L148-L273","name":"Mathlib.Explode.«command#explode_»","line":148,"kind":"def","docLink":"./Mathlib/Tactic/Explode.html#Mathlib.Explode.«command#explode_»","doc":"`#explode expr` displays a proof term in a line-by-line format somewhat akin to a Fitch-style\nproof or the Metamath proof style.\n\nFor example, exploding the following theorem:\n\n```lean\n#explode iff_of_true\n```\n\nproduces:\n\n```lean\niff_of_true : ∀ {a b : Prop}, a → b → (a ↔ b)\n\n0│         │ a         ├ Prop\n1│         │ b         ├ Prop\n2│         │ ha        ├ a\n3│         │ hb        ├ b\n4│         │ x✝        │ ┌ a\n5│4,3      │ ∀I        │ a → b\n6│         │ x✝        │ ┌ b\n7│6,2      │ ∀I        │ b → a\n8│5,7      │ Iff.intro │ a ↔ b\n9│0,1,2,3,8│ ∀I        │ ∀ {a b : Prop}, a → b → (a ↔ b)\n```\n\n## Overview\n\nThe `#explode` command takes the body of the theorem and decomposes it into its parts,\ndisplaying each expression constructor one at a time. The constructor is indicated\nin some way in column 3, and its dependencies are recorded in column 2.\n\nThese are the main constructor types:\n\n  - Lambda expressions (`Expr.lam`). The expression `fun (h : p) => s` is displayed as\n    ```lean\n     0│    │ h   │ ┌ p\n     1│**  │ **  │ │ q\n     2│1,2 │ ∀I  │ ∀ (h : p), q\n    ```\n    with `**` a wildcard, and there can be intervening steps between 0 and 1.\n    Nested lambda expressions can be merged, and `∀I` can depend on a whole list of arguments.\n\n  - Applications (`Expr.app`). The expression `f a b c` is displayed as\n     ```lean\n     0│**      │ f  │ A → B → C → D\n     1│**      │ a  │ A\n     2│**      │ b  │ B\n     3│**      │ c  │ C\n     1│0,1,2,3 │ ∀E │ D\n     ```\n     There can be intervening steps between each of these.\n     As a special case, if `f` is a constant it can be omitted and the display instead looks like\n     ```lean\n     0│**    │ a │ A\n     1│**    │ b │ B\n     2│**    │ c │ C\n     3│1,2,3 │ f │ D\n     ```\n\n  - Let expressions (`Expr.letE`) do not display in any special way, but they do\n    ensure that in `let x := v; b` that `v` is processed first and then `b`, rather\n    than first doing zeta reduction. This keeps lambda merging and application merging\n    from making proofs with `let` confusing to interpret.\n\n  - Everything else (constants, fvars, etc.) display `x : X` as\n    ```lean\n    0│  │ x │ X\n    ```\n\n## In more detail\n\nThe output of `#explode` is a Fitch-style proof in a four-column diagram modeled after Metamath\nproof displays like [this](http://us.metamath.org/mpeuni/ru.html). The headers of the columns are\n\"Step\", \"Hyp\", \"Ref\", \"Type\" (or \"Expression\" in the case of Metamath):\n* **Step**: An increasing sequence of numbers for each row in the proof, used in the Hyp fields.\n* **Hyp**: The direct children of the current step. These are step numbers for the subexpressions\n  for this step's expression. For theorem applications, it's the theorem arguments, and for\n  foralls it is all the bound variables and the conclusion.\n* **Ref**: The name of the theorem being applied. This is well-defined in Metamath, but in Lean\n  there are some special steps that may have long names because the structure of proof terms doesn't\n  exactly match this mold.\n  * If the theorem is `foo (x y : Z) : A x -> B y -> C x y`:\n    * the Ref field will contain `foo`,\n    * `x` and `y` will be suppressed, because term construction is not interesting, and\n    * the Hyp field will reference steps proving `A x` and `B y`. This corresponds to a proof term\n      like `@foo x y pA pB` where `pA` and `pB` are subproofs.\n    * In the Hyp column, suppressed terms are omitted, including terms that ought to be\n      suppressed but are not (in particular lambda arguments).\n      TODO: implement a configuration option to enable representing suppressed terms using\n      an `_` rather than a step number.\n  * If the head of the proof term is a local constant or lambda, then in this case the Ref will\n    say `∀E` for forall-elimination. This happens when you have for example `h : A -> B` and\n    `ha : A` and prove `b` by `h ha`; we reinterpret this as if it said `∀E h ha` where `∀E` is\n    (n-ary) modus ponens.\n  * If the proof term is a lambda, we will also use `∀I` for forall-introduction, referencing the\n    body of the lambda. The indentation level will increase, and a bracket will surround the proof\n    of the body of the lambda, starting at a proof step labeled with the name of the lambda variable\n    and its type, and ending with the `∀I` step. Metamath doesn't have steps like this, but the\n    style is based on Fitch proofs in first-order logic.\n* **Type**: This contains the type of the proof term, the theorem being proven at the current step.\n\nAlso, it is common for a Lean theorem to begin with a sequence of lambdas introducing local\nconstants of the theorem. In order to minimize the indentation level, the `∀I` steps at the end of\nthe proof will be introduced in a group and the indentation will stay fixed. (The indentation\nbrackets are only needed in order to delimit the scope of assumptions, and these assumptions\nhave global scope anyway so detailed tracking is not necessary.)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Explode.html#Mathlib.Explode.«command#explode_»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Explode</span>.<span class=\"name\">«command#explode_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Explode.lean#L140-L145","name":"Mathlib.Explode.explode","line":140,"kind":"def","docLink":"./Mathlib/Tactic/Explode.html#Mathlib.Explode.explode","doc":"Main definition behind `#explode` command. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Explode.html#Mathlib.Explode.explode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Explode</span>.<span class=\"name\">explode</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">filterProofs</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/Explode/Datatypes.html#Mathlib.Explode.Entries\">Entries</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Explode.lean#L134-L138","name":"Mathlib.Explode.explodeCore.consDep","line":134,"kind":"def","docLink":"./Mathlib/Tactic/Explode.html#Mathlib.Explode.explodeCore.consDep","doc":"Prepend the `line` of the `Entry` to `deps` if it's not `none`, but if the entry isn't marked\nwith `useAsDep` then it's not added to the list at all. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Explode.html#Mathlib.Explode.explodeCore.consDep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Explode</span>.<span class=\"name\">explodeCore</span>.<span class=\"name\">consDep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">includeAllDeps</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">entry?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/Explode/Datatypes.html#Mathlib.Explode.Entry\">Entry</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">deps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Explode.lean#L24-L138","name":"Mathlib.Explode.explodeCore","line":24,"kind":"opaque","docLink":"./Mathlib/Tactic/Explode.html#Mathlib.Explode.explodeCore","doc":"Core `explode` algorithm.\n\n- `select` is a condition for which expressions to process\n- `includeAllDeps` is whether to include dependencies even if they were filtered out.\n  If `True`, then `none` is inserted for omitted dependencies\n- `e` is the expression to process\n- `depth` is the current abstraction depth\n- `entries` is the table so far\n- `start` is whether we are at the top-level of the expression, which\n  causes lambdas to use `Status.sintro` to prevent a layer of nesting.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Explode.html#Mathlib.Explode.explodeCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Explode</span>.<span class=\"name\">explodeCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">select</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">includeAllDeps</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">depth</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">entries</span> : <a href=\"./Mathlib/Tactic/Explode/Datatypes.html#Mathlib.Explode.Entries\">Entries</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">start</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/Explode/Datatypes.html#Mathlib.Explode.Entry\">Entry</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Explode/Datatypes.html#Mathlib.Explode.Entries\">Entries</a>)</span></div></div>"}]}