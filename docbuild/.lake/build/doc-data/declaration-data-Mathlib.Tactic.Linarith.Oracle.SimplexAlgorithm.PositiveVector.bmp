{"name":"Mathlib.Tactic.Linarith.Oracle.SimplexAlgorithm.PositiveVector","instances":[],"imports":["Init","Lean.Meta.Basic","Mathlib.Tactic.Linarith.Oracle.SimplexAlgorithm.SimplexAlgorithm","Mathlib.Tactic.Linarith.Oracle.SimplexAlgorithm.Gauss"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/PositiveVector.lean#L80-L100","name":"Linarith.SimplexAlgorithm.findPositiveVector","line":80,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/PositiveVector.html#Linarith.SimplexAlgorithm.findPositiveVector","doc":"Finds a nonnegative vector `v`, such that `A v = 0` and some of its coordinates from\n`strictCoords`\nare positive, in the case such `v` exists. If not, throws the error. The latter prevents\n`linarith` from doing useless post-processing.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/PositiveVector.html#Linarith.SimplexAlgorithm.findPositiveVector\"><span class=\"name\">Linarith</span>.<span class=\"name\">SimplexAlgorithm</span>.<span class=\"name\">findPositiveVector</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">matType</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/Datatypes.html#Linarith.SimplexAlgorithm.UsableInSimplexAlgorithm\">UsableInSimplexAlgorithm</a> <span class=\"fn\">matType</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">A</span> : <span class=\"fn\"><span class=\"fn\">matType</span> <span class=\"fn\">n</span> <span class=\"fn\">m</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">strictIndexes</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Batteries/Data/Rat/Basic.html#Rat\">Rat</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/PositiveVector.lean#L73-L78","name":"Linarith.SimplexAlgorithm.extractSolution","line":73,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/PositiveVector.html#Linarith.SimplexAlgorithm.extractSolution","doc":"Extracts target vector from the tableau, putting auxiliary variables aside (see `stateLP`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/PositiveVector.html#Linarith.SimplexAlgorithm.extractSolution\"><span class=\"name\">Linarith</span>.<span class=\"name\">SimplexAlgorithm</span>.<span class=\"name\">extractSolution</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">matType</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/Datatypes.html#Linarith.SimplexAlgorithm.UsableInSimplexAlgorithm\">UsableInSimplexAlgorithm</a> <span class=\"fn\">matType</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tableau</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/Datatypes.html#Linarith.SimplexAlgorithm.Tableau\">Tableau</a> <span class=\"fn\">matType</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Batteries/Data/Rat/Basic.html#Rat\">Rat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/PositiveVector.lean#L40-L71","name":"Linarith.SimplexAlgorithm.stateLP","line":40,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/PositiveVector.html#Linarith.SimplexAlgorithm.stateLP","doc":"Given matrix `A` and list `strictIndexes` of strict inequalities' indexes, we want to state the\nLinear Programming problem which solution would give us a solution for the initial problem (see\n`findPositiveVector`).\n\nAs an objective function (that we are trying to maximize) we use sum of coordinates from\n`strictIndexes`: it suffices to find the nonnegative vector that makes this function positive.\n\nWe introduce two auxiliary variables and one constraint:\n* The variable `y` is interpreted as \"homogenized\" `1`. We need it because dealing with a\n  homogenized problem is easier, but having some \"unit\" is necessary.\n* To bound the problem we add the constraint `x₁ + ... + xₘ + z = y` introducing new variable `z`.\n\nThe objective function also interpreted as an auxiliary variable with constraint\n`f = ∑ i ∈ strictIndexes, xᵢ`.\n\nThe variable `f` has to always be basic while `y` has to be free. Our Gauss method implementation\ngreedy collects basic variables moving from left to right. So we place `f` before `x`-s and `y`\nafter them. We place `z` between `f` and `x` because in this case `z` will be basic and\n`Gauss.getTableau` produce tableau with nonnegative last column, meaning that we are starting from\na feasible point.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/PositiveVector.html#Linarith.SimplexAlgorithm.stateLP\"><span class=\"name\">Linarith</span>.<span class=\"name\">SimplexAlgorithm</span>.<span class=\"name\">stateLP</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">matType</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm/Datatypes.html#Linarith.SimplexAlgorithm.UsableInSimplexAlgorithm\">UsableInSimplexAlgorithm</a> <span class=\"fn\">matType</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">A</span> : <span class=\"fn\"><span class=\"fn\">matType</span> <span class=\"fn\">n</span> <span class=\"fn\">m</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">strictIndexes</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">matType</span> (<span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">2</span>) (<span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">3</span>)</span></div></div>"}]}