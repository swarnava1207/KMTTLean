{"name":"Mathlib.Tactic.Peel","instances":[],"imports":["Init","Mathlib.Tactic.Basic","Mathlib.Order.Filter.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L213-L223","name":"Mathlib.Tactic.Peel.peelArgsIff","line":213,"kind":"def","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peelArgsIff","doc":"Peel off quantifiers from an `↔` and assign the names given in `l` to the introduced\nvariables. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peelArgsIff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">peelArgsIff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L203-L211","name":"Mathlib.Tactic.Peel.peelIffAux","line":203,"kind":"def","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peelIffAux","doc":"Peel off a single quantifier from an `↔`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peelIffAux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">peelIffAux</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L189-L201","name":"Mathlib.Tactic.Peel.peelUnbounded","line":189,"kind":"opaque","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peelUnbounded","doc":"Similar to `peelArgs` but peels arbitrarily many quantifiers. Returns whether or not\nany quantifiers were peeled. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peelUnbounded\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">peelUnbounded</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfold</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L174-L187","name":"Mathlib.Tactic.Peel.peelArgs","line":174,"kind":"def","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peelArgs","doc":"Given a list `l` of names, this peels `num` quantifiers off of the expression `e` and\nthe main goal and introduces variables with the provided names until the list of names is exhausted.\nNote: the name `n?` (with default `this`) is used for the name of the expression `e` with\nquantifiers peeled. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peelArgs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">peelArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">num</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfold</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L145-L172","name":"Mathlib.Tactic.Peel.peelCore","line":145,"kind":"def","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peelCore","doc":"This is the core to the `peel` tactic.\n\nIt tries to match `e` and `goal` as quantified statements (using `∀` and the quantifiers in\nthe `quantifiers` list), then applies \"peel theorems\" using `applyPeelThm`.\n\nWe treat `∧` as a quantifier for sake of dealing with quantified statements\nlike `∃ δ > (0 : ℝ), q δ`, which is notation for `∃ δ, δ > (0 : ℝ) ∧ q δ`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peelCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">peelCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfold</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L130-L143","name":"Mathlib.Tactic.Peel.applyPeelThm","line":130,"kind":"def","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.applyPeelThm","doc":"Applies a \"peel theorem\" with two main arguments, where the first is the new goal\nand the second can be filled in using `e`. Then it intros two variables with the\nprovided names.\n\nIf, for example, `goal : ∃ y : α, q y` and `thm := Exists.imp`, the metavariable returned has\ntype `q x` where `x : α` has been introduced into the context. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.applyPeelThm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">applyPeelThm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">thm</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">ty </span><span class=\"fn\">target</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L125-L128","name":"Mathlib.Tactic.Peel.mkFreshBinderName","line":125,"kind":"def","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.mkFreshBinderName","doc":"If `f` is a lambda then use its binding name to generate a new hygienic name,\nand otherwise choose a new hygienic name. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.mkFreshBinderName\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">mkFreshBinderName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L121-L123","name":"Mathlib.Tactic.Peel.throwPeelError","line":121,"kind":"def","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.throwPeelError","doc":"Throws an error saying `ty` and `target` could not be matched up. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.throwPeelError\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">throwPeelError</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty </span><span class=\"fn\">target</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L109-L119","name":"Mathlib.Tactic.Peel.whnfQuantifier","line":109,"kind":"def","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.whnfQuantifier","doc":"If `unfold` is false then do `whnfR`, otherwise unfold everything that's not a quantifier,\naccording to the `quantifiers` list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.whnfQuantifier\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">whnfQuantifier</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">unfold</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L105-L107","name":"Mathlib.Tactic.Peel.quantifiers","line":105,"kind":"def","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.quantifiers","doc":"The list of constants that are regarded as being quantifiers. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.quantifiers\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">quantifiers</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Peel.lean#L27-L85","name":"Mathlib.Tactic.Peel.peel","line":27,"kind":"def","docLink":"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peel","doc":"Peels matching quantifiers off of a given term and the goal and introduces the relevant variables.\n\n- `peel e` peels all quantifiers (at reducible transparency),\n  using `this` for the name of the peeled hypothesis.\n- `peel e with h` is `peel e` but names the peeled hypothesis `h`.\n  If `h` is `_` then uses `this` for the name of the peeled hypothesis.\n- `peel n e` peels `n` quantifiers (at default transparency).\n- `peel n e with x y z ... h` peels `n` quantifiers, names the peeled hypothesis `h`,\n  and uses `x`, `y`, `z`, and so on to name the introduced variables; these names may be `_`.\n  If `h` is `_` then uses `this` for the name of the peeled hypothesis.\n  The length of the list of variables does not need to equal `n`.\n- `peel e with x₁ ... xₙ h` is `peel n e with x₁ ... xₙ h`.\n\nThere are also variants that apply to an iff in the goal:\n- `peel n` peels `n` quantifiers in an iff.\n- `peel with x₁ ... xₙ` peels `n` quantifiers in an iff and names them.\n\nGiven `p q : ℕ → Prop`, `h : ∀ x, p x`, and a goal `⊢ : ∀ x, q x`, the tactic `peel h with x h'`\nwill introduce `x : ℕ`, `h' : p x` into the context and the new goal will be `⊢ q x`. This works\nwith `∃`, as well as `∀ᶠ` and `∃ᶠ`, and it can even be applied to a sequence of quantifiers. Note\nthat this is a logically weaker setup, so using this tactic is not always feasible.\n\nFor a more complex example, given a hypothesis and a goal:\n```\nh : ∀ ε > (0 : ℝ), ∃ N : ℕ, ∀ n ≥ N, 1 / (n + 1 : ℝ) < ε\n⊢ ∀ ε > (0 : ℝ), ∃ N : ℕ, ∀ n ≥ N, 1 / (n + 1 : ℝ) ≤ ε\n```\n(which differ only in `<`/`≤`), applying `peel h with ε hε N n hn h_peel` will yield a tactic state:\n```\nh : ∀ ε > (0 : ℝ), ∃ N : ℕ, ∀ n ≥ N, 1 / (n + 1 : ℝ) < ε\nε : ℝ\nhε : 0 < ε\nN n : ℕ\nhn : N ≤ n\nh_peel : 1 / (n + 1 : ℝ) < ε\n⊢ 1 / (n + 1 : ℝ) ≤ ε\n```\nand the goal can be closed with `exact h_peel.le`.\nNote that in this example, `h` and the goal are logically equivalent statements, but `peel`\n*cannot* be immediately applied to show that the goal implies `h`.\n\nIn addition, `peel` supports goals of the form `(∀ x, p x) ↔ ∀ x, q x`, or likewise for any\nother quantifier. In this case, there is no hypothesis or term to supply, but otherwise the syntax\nis the same. So for such goals, the syntax is `peel 1` or `peel with x`, and after which the\nresulting goal is `p x ↔ q x`. The `congr!` tactic can also be applied to goals of this form using\n`congr! 1 with x`. While `congr!` applies congruence lemmas in general, `peel` can be relied upon\nto only apply to outermost quantifiers.\n\nFinally, the user may supply a term `e` via `... using e` in order to close the goal\nimmediately. In particular, `peel h using e` is equivalent to `peel h; exact e`. The `using` syntax\nmay be paired with any of the other features of `peel`.\n\nThis tactic works by repeatedly applying lemmas such as `forall_imp`, `Exists.imp`,\n`Filter.Eventually.mp`, `Filter.Frequently.mp`, and `Filter.Eventually.of_forall`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peel\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Peel</span>.<span class=\"name\">peel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}