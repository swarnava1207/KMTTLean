{"name":"Mathlib.Tactic.Cases","instances":[],"imports":["Init","Lean.Elab.Tactic.Induction","Batteries.Tactic.OpenPrivate","Mathlib.Lean.Expr.Basic","Batteries.Data.List.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Cases.lean#L127-L167","name":"Mathlib.Tactic.cases'","line":127,"kind":"def","docLink":"./Mathlib/Tactic/Cases.html#Mathlib.Tactic.cases'","doc":"The `cases'` tactic is similar to the `cases` tactic in Lean 4 core, but the syntax for giving\nnames is different:\n\n```\nexample (h : p ∨ q) : q ∨ p := by\n  cases h with\n  | inl hp => exact Or.inr hp\n  | inr hq => exact Or.inl hq\n\nexample (h : p ∨ q) : q ∨ p := by\n  cases' h with hp hq\n  · exact Or.inr hp\n  · exact Or.inl hq\n\nexample (h : p ∨ q) : q ∨ p := by\n  rcases h with hp | hq\n  · exact Or.inr hp\n  · exact Or.inl hq\n```\n\nPrefer `cases` or `rcases` when possible, because these tactics promote structured proofs.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Cases.html#Mathlib.Tactic.cases'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">cases'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Cases.lean#L71-L125","name":"Mathlib.Tactic.induction'","line":71,"kind":"def","docLink":"./Mathlib/Tactic/Cases.html#Mathlib.Tactic.induction'","doc":"The `induction'` tactic is similar to the `induction` tactic in Lean 4 core,\nbut with slightly different syntax (such as, no requirement to name the constructors).\n\n```\nopen Nat\n\nexample (n : ℕ) : 0 < factorial n := by\n  induction' n with n ih\n  · rw [factorial_zero]\n    simp\n  · rw [factorial_succ]\n    apply mul_pos (succ_pos n) ih\n\nexample (n : ℕ) : 0 < factorial n := by\n  induction n\n  case zero =>\n    rw [factorial_zero]\n    simp\n  case succ n ih =>\n    rw [factorial_succ]\n    apply mul_pos (succ_pos n) ih\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Cases.html#Mathlib.Tactic.induction'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">induction'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Cases.lean#L46-L68","name":"Mathlib.Tactic.ElimApp.evalNames","line":46,"kind":"def","docLink":"./Mathlib/Tactic/Cases.html#Mathlib.Tactic.ElimApp.evalNames","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Cases.html#Mathlib.Tactic.ElimApp.evalNames\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ElimApp</span>.<span class=\"name\">evalNames</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">elimInfo</span> : <a href=\"./Lean/Meta/Tactic/ElimInfo.html#Lean.Meta.ElimInfo\">Lean.Meta.ElimInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">alts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Alt\">Lean.Elab.Tactic.ElimApp.Alt</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">withArg</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numEqs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">generalized </span><span class=\"fn\">toClear</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toTag</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Meta.html#Lean.Syntax.Ident\">Lean.Ident</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"}]}