{"name":"Mathlib.Tactic.CategoryTheory.CheckCompositions","instances":[],"imports":["Init","Mathlib.CategoryTheory.Category.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/CheckCompositions.lean#L63-L112","name":"Mathlib.Tactic.CheckCompositions.tacticCheck_compositions","line":63,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.tacticCheck_compositions","doc":"For each composition `f ≫ g` in the goal,\nwhich internally is represented as `CategoryStruct.comp C inst X Y Z f g`,\ninfer the types of `f` and `g` and check whether their sources and targets agree\nwith `X`, `Y`, and `Z` at \"instances and reducible\" transparency,\nreporting any discrepancies.\n\nAn example:\n\n```\nexample (j : J) :\n    colimit.ι ((F ⋙ G) ⋙ H) j ≫ (preservesColimitIso (G ⋙ H) F).inv =\n      H.map (G.map (colimit.ι F j)) := by\n\n  -- We know which lemma we want to use, and it's even a simp lemma, but `rw`\n  -- won't let us apply it\n  fail_if_success rw [ι_preservesColimitIso_inv]\n  fail_if_success rw [ι_preservesColimitIso_inv (G ⋙ H)]\n  fail_if_success simp only [ι_preservesColimitIso_inv]\n\n  -- This would work:\n  -- erw [ι_preservesColimitIso_inv (G ⋙ H)]\n\n  -- `check_compositions` checks if the two morphisms we're composing are\n  -- composed by abusing defeq, and indeed it tells us that we are abusing\n  -- definitional associativity of composition of functors here: it prints\n  -- the following.\n\n  -- info: In composition\n  --   colimit.ι ((F ⋙ G) ⋙ H) j ≫ (preservesColimitIso (G ⋙ H) F).inv\n  -- the source of\n  --   (preservesColimitIso (G ⋙ H) F).inv\n  -- is\n  --   colimit (F ⋙ G ⋙ H)\n  -- but should be\n  --   colimit ((F ⋙ G) ⋙ H)\n\n  check_compositions\n\n  -- In this case, we can \"fix\" this by reassociating in the goal, but\n  -- usually at this point the right thing to do is to back off and\n  -- check how we ended up with a bad goal in the first place.\n  dsimp only [Functor.assoc]\n\n  -- This would work now, but it is not needed, because simp works as well\n  -- rw [ι_preservesColimitIso_inv]\n\n  simp\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.tacticCheck_compositions\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CheckCompositions</span>.<span class=\"name\">tacticCheck_compositions</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/CheckCompositions.lean#L58-L61","name":"Mathlib.Tactic.CheckCompositions.checkCompositionsTac","line":58,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.checkCompositionsTac","doc":"Check the typing of categorical compositions in the goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.checkCompositionsTac\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CheckCompositions</span>.<span class=\"name\">checkCompositionsTac</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/CheckCompositions.lean#L54-L56","name":"Mathlib.Tactic.CheckCompositions.checkCompositions","line":54,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.checkCompositions","doc":"Check the typing of categorical compositions in an expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.checkCompositions\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CheckCompositions</span>.<span class=\"name\">checkCompositions</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/CheckCompositions.lean#L29-L52","name":"Mathlib.Tactic.CheckCompositions.checkComposition","line":29,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.checkComposition","doc":"Given a composition `CategoryStruct.comp _ _ X Y Z f g`,\ninfer the types of `f` and `g` and check whether their sources and targets agree,\nat \"instances and reducible\" transparency, with `X`, `Y`, and `Z`,\nreporting any discrepancies. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.checkComposition\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CheckCompositions</span>.<span class=\"name\">checkComposition</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/CheckCompositions.lean#L25-L27","name":"Mathlib.Tactic.CheckCompositions.forEachComposition","line":25,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.forEachComposition","doc":"Find appearances of `CategoryStruct.comp C inst X Y Z f g`, and apply `f` to each. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.forEachComposition\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CheckCompositions</span>.<span class=\"name\">forEachComposition</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"}]}