{"name":"Qq.Simp","instances":[],"imports":["Init","Qq.MetaM"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/quote4/blob/aa4c87abed970d9dfad2506000d99d30b02f476b/Qq/Simp.lean#L51-L56","name":"Lean.Meta.Simp.Simproc.ofQ","line":51,"kind":"def","docLink":"./Qq/Simp.html#Lean.Meta.Simp.Simproc.ofQ","doc":"Build a simproc with Qq-enabled typechecking of inputs and outputs.\n\nThis calls `inferTypeQ` on the expression and passes the arguments to `proc`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.Simproc.ofQ\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">Simproc</span>.<span class=\"name\">ofQ</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proc</span> : <a href=\"./Qq/Simp.html#Lean.Meta.Simp.SimprocQ\">SimprocQ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Simproc</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/quote4/blob/aa4c87abed970d9dfad2506000d99d30b02f476b/Qq/Simp.lean#L46-L49","name":"Lean.Meta.Simp.SimprocQ","line":46,"kind":"def","docLink":"./Qq/Simp.html#Lean.Meta.Simp.SimprocQ","doc":"A copy of `Lean.Meta.Simproc` with explicit types.\n\nSee `Simproc.ofQ` to construct terms of this type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.SimprocQ\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">SimprocQ</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/quote4/blob/aa4c87abed970d9dfad2506000d99d30b02f476b/Qq/Simp.lean#L43-L44","name":"Lean.Meta.Simp.StepQ.continue","line":43,"kind":"def","docLink":"./Qq/Simp.html#Lean.Meta.Simp.StepQ.continue","doc":"For `pre` procedures, continue transformation by visiting subexpressions, and then\nexecuting `post` procedures.\n\nFor `post` procedures, this is equivalent to returning `visit`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ.continue\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">StepQ</span>.<span class=\"name\">continue</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ\">ResultQ</a> <span class=\"fn\">e</span>)</span></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ\">StepQ</a> <span class=\"fn\">e</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/quote4/blob/aa4c87abed970d9dfad2506000d99d30b02f476b/Qq/Simp.lean#L41-L42","name":"Lean.Meta.Simp.StepQ.visit","line":41,"kind":"def","docLink":"./Qq/Simp.html#Lean.Meta.Simp.StepQ.visit","doc":"For `pre` procedures, the resulting expression is passed to `pre` again.\n\nFor `post` procedures, the resulting expression is passed to `pre` again IF\n`Simp.Config.singlePass := false` and resulting expression is not equal to initial expression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ.visit\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">StepQ</span>.<span class=\"name\">visit</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ\">ResultQ</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ\">StepQ</a> <span class=\"fn\">e</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/quote4/blob/aa4c87abed970d9dfad2506000d99d30b02f476b/Qq/Simp.lean#L39-L40","name":"Lean.Meta.Simp.StepQ.done","line":39,"kind":"def","docLink":"./Qq/Simp.html#Lean.Meta.Simp.StepQ.done","doc":"For `pre` procedures, it returns the result without visiting any subexpressions.\n\nFor `post` procedures, it returns the result.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ.done\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">StepQ</span>.<span class=\"name\">done</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ\">ResultQ</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ\">StepQ</a> <span class=\"fn\">e</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/quote4/blob/aa4c87abed970d9dfad2506000d99d30b02f476b/Qq/Simp.lean#L36-L37","name":"Lean.Meta.Simp.StepQ","line":36,"kind":"def","docLink":"./Qq/Simp.html#Lean.Meta.Simp.StepQ","doc":"A copy of `Meta.Simp.Step` with explicit types. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.StepQ\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">StepQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/quote4/blob/aa4c87abed970d9dfad2506000d99d30b02f476b/Qq/Simp.lean#L29-L34","name":"Lean.Meta.Simp.ResultQ.mk","line":29,"kind":"def","docLink":"./Qq/Simp.html#Lean.Meta.Simp.ResultQ.mk","doc":"A copy of `Meta.Simp.Result.mk` with explicit types. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">ResultQ</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$expr»</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cache</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ\">ResultQ</a> <span class=\"fn\">e</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/quote4/blob/aa4c87abed970d9dfad2506000d99d30b02f476b/Qq/Simp.lean#L26-L27","name":"Lean.Meta.Simp.ResultQ","line":26,"kind":"def","docLink":"./Qq/Simp.html#Lean.Meta.Simp.ResultQ","doc":"A copy of `Meta.Simp.Result` with explicit types. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Qq/Simp.html#Lean.Meta.Simp.ResultQ\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">ResultQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}