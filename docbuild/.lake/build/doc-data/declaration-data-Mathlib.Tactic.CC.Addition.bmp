{"name":"Mathlib.Tactic.CC.Addition","instances":[],"imports":["Init","Mathlib.Data.Option.Defs","Mathlib.Tactic.CC.MkProof"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1420-L1463","name":"Mathlib.Tactic.CC.CCM.add","line":1420,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.add","doc":"Add `proof : type` to the congruence closure. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type </span><span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1414-L1418","name":"Mathlib.Tactic.CC.CCM.addEqvCore","line":1414,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvCore","doc":"Add `H : lhs = rhs` or `H : HEq lhs rhs` to the congruence closure. Don't forget to internalize\n`lhs` and `rhs` beforehand. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addEqvCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs </span><span class=\"fn\">H</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqProof</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1409-L1412","name":"Mathlib.Tactic.CC.CCM.internalize","line":1409,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalize","doc":"Internalize `e` so that the congruence closure can deal with the given expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1398-L1407","name":"Mathlib.Tactic.CC.CCM.processTodo","line":1398,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processTodo","doc":"Process the tasks in the `todo` field. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">processTodo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1268-L1396","name":"Mathlib.Tactic.CC.CCM.addEqvStep.go","line":1268,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvStep.go","doc":"The auxiliary definition for `addEqvStep` to flip the input. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvStep.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addEqvStep</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n₁ </span><span class=\"fn\">n₂ </span><span class=\"fn\">r₁ </span><span class=\"fn\">r₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">flipped</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqProof</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1235-L1396","name":"Mathlib.Tactic.CC.CCM.addEqvStep","line":1235,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvStep","doc":"Performs one step in the process when the new equation is added.\n\nHere, `H` contains the proof that `e₁ = e₂` (if `heqProof` is false)\nor `HEq e₁ e₂` (if `heqProof` is true). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addEqvStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqProof</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1222-L1233","name":"Mathlib.Tactic.CC.CCM.propagateDown","line":1222,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateDown","doc":"Propagate equality from `e` to subexpressions of `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1214-L1220","name":"Mathlib.Tactic.CC.CCM.propagateExistsDown","line":1214,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateExistsDown","doc":"Propagate equality from `¬∃ x, p x` to `∀ x, ¬p x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateExistsDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateExistsDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1208-L1212","name":"Mathlib.Tactic.CC.CCM.propagateEqDown","line":1208,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqDown","doc":"Propagate equality from `(a = b) = True` to `a = b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateEqDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1197-L1206","name":"Mathlib.Tactic.CC.CCM.propagateNotDown","line":1197,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotDown","doc":"Propagate equality from `¬a` to `a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateNotDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1189-L1195","name":"Mathlib.Tactic.CC.CCM.propagateOrDown","line":1189,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrDown","doc":"Propagate equality from `a ∨ b = False` to `a = False` and `b = False`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateOrDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1181-L1187","name":"Mathlib.Tactic.CC.CCM.propagateAndDown","line":1181,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndDown","doc":"Propagate equality from `a ∧ b = True` to `a = True` and `b = True`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateAndDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1169-L1179","name":"Mathlib.Tactic.CC.CCM.propagateValueInconsistency","line":1169,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateValueInconsistency","doc":"Derive contradiction if we can get equality between different values. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateValueInconsistency\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateValueInconsistency</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1147-L1160","name":"Mathlib.Tactic.CC.CCM.propagateConstructorEq.go","line":1147,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateConstructorEq.go","doc":"Given an injective theorem `val : type`, whose `type` is the form of\n`a₁ = a₂ ∧ HEq b₁ b₂ ∧ ..`, destruct `val` and push equality proofs to the todo list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateConstructorEq.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateConstructorEq</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type </span><span class=\"fn\">val</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1121-L1167","name":"Mathlib.Tactic.CC.CCM.propagateConstructorEq","line":1121,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateConstructorEq","doc":"Given a new equality `e₁ = e₂`, where `e₁` and `e₂` are constructor applications.\nImplement the following implications:\n```lean\nc a₁ ... aₙ = c b₁ ... bₙ => a₁ = b₁, ..., aₙ = bₙ\n\nc₁ ... = c₂ ... => False\n```\nwhere `c`, `c₁` and `c₂` are constructors "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateConstructorEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateConstructorEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1097-L1119","name":"Mathlib.Tactic.CC.CCM.propagateProjectionConstructor","line":1097,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateProjectionConstructor","doc":"Given `c` a constructor application, if `p` is a projection application (not `.proj _ _ _`, but\n`.app (.const projName _) _`) such that major premise is\nequal to `c`, then propagate new equality.\n\nExample: if `p` is of the form `b.fst`, `c` is of the form `(x, y)`, and `b = c`, we add the\nequality `(x, y).fst = x` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateProjectionConstructor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateProjectionConstructor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">c</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1071-L1095","name":"Mathlib.Tactic.CC.CCM.propagateBetaToEqc","line":1071,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBetaToEqc","doc":"For each `fnRoot` in `fnRoots` traverse its parents, and look for a parent prefix that is\nin the same equivalence class of the given lambdas.\n\nremark All expressions in lambdas are in the same equivalence class "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBetaToEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateBetaToEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fnRoots </span><span class=\"fn\">lambdas</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newLambdaApps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1067-L1069","name":"Mathlib.Tactic.CC.CCM.checkInvariant","line":1067,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkInvariant","doc":"Check for integrity of the `CCStructure`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkInvariant\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">checkInvariant</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1054-L1065","name":"Mathlib.Tactic.CC.CCM.reinsertParents","line":1054,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.reinsertParents","doc":"Reinsert parents of `e` to the congruence table and the symm congruence table.\n\nTogether with `removeParents`, this allows modifying parents of an expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.reinsertParents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">reinsertParents</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1037-L1052","name":"Mathlib.Tactic.CC.CCM.collectFnRoots","line":1037,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collectFnRoots","doc":"Traverse the `root`'s equivalence class, and for each function application,\ncollect the function's equivalence class root. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collectFnRoots\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">collectFnRoots</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">root</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fnRoots</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L1012-L1035","name":"Mathlib.Tactic.CC.CCM.invertTrans","line":1012,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.invertTrans","doc":"The fields `target` and `proof` in `e`'s entry are encoding a transitivity proof\nLet `e.rootTarget` and `e.rootProof` denote these fields.\n```lean\ne = e.rootTarget            := e.rootProof\n_ = e.rootTarget.rootTarget := e.rootTarget.rootProof\n ...\n_ = e.root                  := ...\n```\nThe transitivity proof eventually reaches the root of the equivalence class.\nThis method \"inverts\" the proof. That is, the `target` goes from `e.root` to e after\nwe execute it.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.invertTrans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">invertTrans</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newFlipped</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newTarget</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newProof</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L976-L1010","name":"Mathlib.Tactic.CC.CCM.removeParents","line":976,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.removeParents","doc":"Remove parents of `e` from the congruence table and the symm congruence table, and append\nparents to propagate equality, to `parentsToPropagate`.\nReturns the new value of `parentsToPropagate`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.removeParents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">removeParents</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parentsToPropagate</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L971-L974","name":"Mathlib.Tactic.CC.CCM.mayPropagate","line":971,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mayPropagate","doc":"Can we propagate equality from subexpressions of `e` to `e`? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mayPropagate\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mayPropagate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L962-L968","name":"Mathlib.Tactic.CC.CCM.mkEntry","line":962,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkEntry","doc":"Add an new entry for `e` to the congruence closure. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkEntry</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">interpreted</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L937-L960","name":"Mathlib.Tactic.CC.CCM.processSubsingletonElem","line":937,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processSubsingletonElem","doc":"If `e` is a subsingleton element, push the equality proof between `e` and its canonical form\nto the todo list or register `e` as the canonical form of itself. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processSubsingletonElem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">processSubsingletonElem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L870-L935","name":"Mathlib.Tactic.CC.CCM.applySimpleEqvs","line":870,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.applySimpleEqvs","doc":"This method is invoked during internalization and eagerly apply basic equivalences for term `e`\nExamples:\n- If `e := cast H e'`, then it merges the equivalence classes of `cast H e'` and `e'`\n\nIn principle, we could mark theorems such as `cast_eq` as simplification rules, but this created\nproblems with the builtin support for cast-introduction in the ematching module in Lean 3.\nTODO: check if this is now possible in Lean 4.\n\nEagerly merging the equivalence classes is also more efficient. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.applySimpleEqvs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">applySimpleEqvs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L852-L868","name":"Mathlib.Tactic.CC.CCM.propagateUp","line":852,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateUp","doc":"Propagate equality from subexpressions of `e` to `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L811-L850","name":"Mathlib.Tactic.CC.CCM.propagateEqUp","line":811,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqUp","doc":"Propagate equality from `a` and `b` to *disprove* `a = b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateEqUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L798-L809","name":"Mathlib.Tactic.CC.CCM.propagateIteUp","line":798,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIteUp","doc":"Propagate equality from `p`, `a` and `b` to `if p then a else b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIteUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateIteUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L763-L796","name":"Mathlib.Tactic.CC.CCM.propagateImpUp","line":763,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateImpUp","doc":"Propagate equality from `a` and `b` to `a → b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateImpUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateImpUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L749-L761","name":"Mathlib.Tactic.CC.CCM.propagateNotUp","line":749,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotUp","doc":"Propagate equality from `a` to `¬a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateNotUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L727-L746","name":"Mathlib.Tactic.CC.CCM.propagateOrUp","line":727,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrUp","doc":"Propagate equality from `a` and `b` to `a ∨ b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateOrUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L705-L724","name":"Mathlib.Tactic.CC.CCM.propagateAndUp","line":705,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndUp","doc":"Propagate equality from `a` and `b` to `a ∧ b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateAndUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L692-L703","name":"Mathlib.Tactic.CC.CCM.propagateIffUp","line":692,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIffUp","doc":"Propagate equality from `a` and `b` to `a ↔ b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIffUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateIffUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L646-L690","name":"Mathlib.Tactic.CC.CCM.internalizeCore","line":646,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeCore","doc":"Internalize `e` so that the congruence closure can deal with the given expression. Don't forget\nto process the tasks in the `todo` field later. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parent?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L581-L644","name":"Mathlib.Tactic.CC.CCM.internalizeAppLit","line":581,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAppLit","doc":"The specialized `internalizeCore` for applications or literals. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAppLit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeAppLit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L554-L578","name":"Mathlib.Tactic.CC.CCM.internalizeAC","line":554,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAC","doc":"Internalize `e` so that the AC module can deal with the given expression.\n\nIf the expression does not contain an AC operator, or the parent expression\nis already processed by `internalizeAC`, this operation does nothing. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parent?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L542-L552","name":"Mathlib.Tactic.CC.CCM.convertAC","line":542,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.convertAC","doc":"Given `e := op₁ (op₂ a₁ a₂) (op₃ a₃ a₄)` where `opₙ`s are canonicalized to `op`, internalize\n`aₙ`s as AC variables and return `(op (op a₁ a₂) (op a₃ a₄), args ++ #[a₁, a₂, a₃, a₄])`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.convertAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">convertAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L514-L540","name":"Mathlib.Tactic.CC.CCM.isAC","line":514,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isAC","doc":"If `e` is of the form `op e₁ e₂` where `op` is an associative and commutative binary operator,\nreturn the canonical form of `op`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">isAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L504-L512","name":"Mathlib.Tactic.CC.CCM.internalizeACVar","line":504,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeACVar","doc":"If `e` isn't an AC variable, set `e` as an new AC variable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeACVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeACVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L493-L502","name":"Mathlib.Tactic.CC.CCM.setACVar","line":493,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.setACVar","doc":"If the root expression of `e` is AC variable, add equality to AC module. If not, register the\nAC variable to the root entry. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.setACVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">setACVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L485-L491","name":"Mathlib.Tactic.CC.CCM.addACEq","line":485,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addACEq","doc":"Given AC variables `e₁` and `e₂` which are in the same equivalence class, add the proof of\n`e₁ = e₂` to the AC module. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addACEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addACEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L432-L483","name":"Mathlib.Tactic.CC.CCM.processAC","line":432,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processAC","doc":"Process the tasks in the `acTodo` field. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">processAC</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L393-L430","name":"Mathlib.Tactic.CC.CCM.superposeAC","line":393,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.superposeAC","doc":"Given `tsEqa : ts = a`, for each equality `trEqb : tr = b` in `acR` where\nthe intersection `t` of `ts` and `tr` is nonempty, let `ts = t*s` and `tr := t*r`, add a new\nequality `r*a = s*b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.superposeAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">superposeAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ts </span><span class=\"fn\">a</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tsEqa</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L366-L391","name":"Mathlib.Tactic.CC.CCM.mkACSuperposeProof","line":366,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkACSuperposeProof","doc":"Given `ra := a*r` `sb := b*s` `ts := t*s` `tr := t*r` `tsEqa : t*s = a` `trEqb : t*r = b`,\nreturn a proof for `ra = sb`.\n\nWe use `a*b` to denote an AC application. That is, `(a*b)*(c*a)` is the term `a*a*b*c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkACSuperposeProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkACSuperposeProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ra </span><span class=\"fn\">sb </span><span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">r </span><span class=\"fn\">s </span><span class=\"fn\">ts </span><span class=\"fn\">tr</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tsEqa </span><span class=\"fn\">trEqb</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L342-L364","name":"Mathlib.Tactic.CC.CCM.collapseAC","line":342,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collapseAC","doc":"Try to simplify the left hand sides of equalities in `acR` by `H : lhs = rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collapseAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">collapseAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L319-L340","name":"Mathlib.Tactic.CC.CCM.composeAC","line":319,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.composeAC","doc":"Try to simplify the right hand sides of equalities in `acR` by `H : lhs = rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.composeAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">composeAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L313-L317","name":"Mathlib.Tactic.CC.CCM.eraseRRHSOccs","line":313,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRRHSOccs","doc":"Erase `lhs` to the occurrences of arguments of `e` on the right hand side of\nan equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">eraseRRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L307-L311","name":"Mathlib.Tactic.CC.CCM.insertRRHSOccs","line":307,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRRHSOccs","doc":"Insert `lhs` to the occurrences of arguments of `e` on the right hand side of\nan equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertRRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L300-L305","name":"Mathlib.Tactic.CC.CCM.eraseRBHSOccs","line":300,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRBHSOccs","doc":"Erase `lhs` to the occurrences on an equality in `acR` corresponding to the equality\n`lhs := rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRBHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">eraseRBHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L293-L298","name":"Mathlib.Tactic.CC.CCM.insertRBHSOccs","line":293,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRBHSOccs","doc":"Insert `lhs` to the occurrences on an equality in `acR` corresponding to the equality\n`lhs := rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRBHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertRBHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L288-L291","name":"Mathlib.Tactic.CC.CCM.eraseROccs","line":288,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseROccs","doc":"Erase `lhs` to the occurrences of arguments of `e` on an equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">eraseROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L283-L286","name":"Mathlib.Tactic.CC.CCM.insertROccs","line":283,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertROccs","doc":"Insert `lhs` to the occurrences of arguments of `e` on an equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L273-L281","name":"Mathlib.Tactic.CC.CCM.insertEraseROccs","line":273,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROccs","doc":"Insert or erase `lhs` to the occurrences of arguments of `e` on an equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertEraseROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS </span><span class=\"fn\">isInsert</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L264-L271","name":"Mathlib.Tactic.CC.CCM.insertEraseROcc","line":264,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROcc","doc":"Insert or erase `lhs` to the occurrences of `arg` on an equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROcc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertEraseROcc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">arg</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS </span><span class=\"fn\">isInsert</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L259-L262","name":"Mathlib.Tactic.CC.CCM.dbgTraceACState","line":259,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACState","doc":"Trace the state of AC module. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">dbgTraceACState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L252-L257","name":"Mathlib.Tactic.CC.CCM.dbgTraceACEq","line":252,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACEq","doc":"Given `lhs`, `rhs`, and `header := \"my header:\"`, Trace `my header: lhs = rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">dbgTraceACEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">header</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L239-L250","name":"Mathlib.Tactic.CC.CCM.propagateBeta","line":239,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBeta","doc":"Remove `fn` and expressions whose type isn't def-eq to `fn`'s type out from `lambdas`,\nreturn the remaining lambdas applied to the reversed arguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBeta\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateBeta</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fn</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">revArgs </span><span class=\"fn\">lambdas</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newLambdaApps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L222-L237","name":"Mathlib.Tactic.CC.CCM.getEqcLambdas","line":222,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqcLambdas","doc":"Get all lambda expressions in the equivalence class of `e` and append to `r`.\n\n`e` must be the root of its equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqcLambdas\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getEqcLambdas</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L208-L220","name":"Mathlib.Tactic.CC.CCM.checkNewSubsingletonEq","line":208,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkNewSubsingletonEq","doc":"Given the equivalent expressions `oldRoot` and `newRoot` the root of `oldRoot` is\n`newRoot`, if `oldRoot` has root representative of subsingletons, try to push the equality proof\nbetween their root representatives to the todo list, or update the root representative to\n`newRoot`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkNewSubsingletonEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">checkNewSubsingletonEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">oldRoot </span><span class=\"fn\">newRoot</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L191-L206","name":"Mathlib.Tactic.CC.CCM.pushSubsingletonEq","line":191,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushSubsingletonEq","doc":"Given subsingleton elements `a` and `b` which are not necessarily of the same type, if the\ntypes of `a` and `b` are equivalent, add the (heterogeneous) equality proof between `a` and `b` to\nthe todo list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushSubsingletonEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushSubsingletonEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L160-L189","name":"Mathlib.Tactic.CC.CCM.addSymmCongruenceTable","line":160,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addSymmCongruenceTable","doc":"If the symm congruence table (`symmCongruences` field) has congruent expression to `e`, add the\nequality to the todo list. If not, add `e` to the symm congruence table. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addSymmCongruenceTable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addSymmCongruenceTable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L136-L158","name":"Mathlib.Tactic.CC.CCM.addCongruenceTable","line":136,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addCongruenceTable","doc":"If the congruence table (`congruences` field) has congruent expression to `e`, add the\nequality to the todo list. If not, add `e` to the congruence table. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addCongruenceTable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addCongruenceTable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L125-L134","name":"Mathlib.Tactic.CC.CCM.checkEqTrue","line":125,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkEqTrue","doc":"Given `e := R lhs rhs`, if `R` is a reflexive relation and `lhs` is equivalent to `rhs`, add\nequality `e = True`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkEqTrue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">checkEqTrue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L113-L123","name":"Mathlib.Tactic.CC.CCM.compareSymm","line":113,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymm","doc":"Given ``k₁ := (R₁ lhs₁ rhs₁, `R₁)`` and ``k₂ := (R₂ lhs₂ rhs₂, `R₂)``, return `true` if\n`R₁ lhs₁ rhs₁` is equivalent to `R₂ lhs₂ rhs₂` modulo the symmetry of `R₁` and `R₂`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">compareSymm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k₁ </span><span class=\"fn\">k₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L101-L111","name":"Mathlib.Tactic.CC.CCM.compareSymmAux","line":101,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymmAux","doc":"Auxiliary function for comparing `lhs₁ ~ rhs₁` and `lhs₂ ~ rhs₂`,\n    when `~` is symmetric/commutative.\nIt returns `true` (equal) for `a ~ b` `b ~ a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymmAux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">compareSymmAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs₁ </span><span class=\"fn\">rhs₁ </span><span class=\"fn\">lhs₂ </span><span class=\"fn\">rhs₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L95-L99","name":"Mathlib.Tactic.CC.CCM.mkSymmCongruencesKey","line":95,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkSymmCongruencesKey","doc":"Return the `SymmCongruencesKey` associated with the equality `lhs = rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkSymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkSymmCongruencesKey</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L85-L93","name":"Mathlib.Tactic.CC.CCM.mkCongruencesKey","line":85,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCongruencesKey","doc":"Return the `CongruencesKey` associated with an expression of the form `f a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkCongruencesKey</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">CongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L69-L83","name":"Mathlib.Tactic.CC.CCM.propagateInstImplicit","line":69,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateInstImplicit","doc":"Record the instance `e` and add it to the set of known defeq instances. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateInstImplicit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateInstImplicit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L60-L67","name":"Mathlib.Tactic.CC.CCM.addOccurrence","line":60,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addOccurrence","doc":"Update the `child` so its parent becomes `parent`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addOccurrence\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addOccurrence</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parent </span><span class=\"fn\">child</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symmTable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L55-L58","name":"Mathlib.Tactic.CC.CCM.pushReflEq","line":55,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushReflEq","doc":"Add `rfl : lhs = rhs` to the todo list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushReflEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushReflEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L50-L53","name":"Mathlib.Tactic.CC.CCM.pushHEq","line":50,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushHEq","doc":"Add the heterogeneous equality proof `H : HEq lhs rhs` to the end of the todo list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushHEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushHEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L45-L48","name":"Mathlib.Tactic.CC.CCM.pushEq","line":45,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushEq","doc":"Add the equality proof `H : lhs = rhs` to the end of the todo list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L39-L43","name":"Mathlib.Tactic.CC.CCM.pushTodo","line":39,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushTodo","doc":"Add a new entry to the end of the todo list.\n\nSee also `pushEq`, `pushHEq` and `pushReflEq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqProof</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L34-L37","name":"Mathlib.Tactic.CC.CCM.getACTodo","line":34,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getACTodo","doc":"Read the `acTodo` field of the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getACTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getACTodo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">ACTodoEntry</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L29-L32","name":"Mathlib.Tactic.CC.CCM.getTodo","line":29,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getTodo","doc":"Read the `todo` field of the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getTodo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">TodoEntry</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L24-L27","name":"Mathlib.Tactic.CC.CCM.modifyACTodo","line":24,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyACTodo","doc":"Update the `acTodo` field of the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyACTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">modifyACTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">ACTodoEntry</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">ACTodoEntry</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Addition.lean#L19-L22","name":"Mathlib.Tactic.CC.CCM.modifyTodo","line":19,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyTodo","doc":"Update the `todo` field of the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">modifyTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">TodoEntry</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">TodoEntry</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"}]}