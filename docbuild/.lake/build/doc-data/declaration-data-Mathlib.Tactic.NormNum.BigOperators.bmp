{"name":"Mathlib.Tactic.NormNum.BigOperators","instances":[],"imports":["Init","Mathlib.Tactic.NormNum.Basic","Mathlib.Data.List.FinRange","Mathlib.Algebra.BigOperators.Group.Finset.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L380-L404","name":"Mathlib.Meta.NormNum.evalFinsetSum","line":380,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetSum","doc":"`norm_num` plugin for evaluating sums of finsets.\n\nIf your finset is not supported, you can add it to the match in `Finset.proveEmptyOrCons`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetSum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">evalFinsetSum</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt\">NormNumExt</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L350-L377","name":"Mathlib.Meta.NormNum.evalFinsetProd","line":350,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetProd","doc":"`norm_num` plugin for evaluating products of finsets.\n\nIf your finset is not supported, you can add it to the match in `Finset.proveEmptyOrCons`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">evalFinsetProd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt\">NormNumExt</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L328-L347","name":"Mathlib.Meta.NormNum.evalFinsetBigop","line":328,"kind":"opaque","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetBigop","doc":"Evaluate a big operator applied to a finset by repeating `proveEmptyOrCons` until\nwe exhaust all elements of the set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetBigop\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">evalFinsetBigop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span> → <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">«$α»</span> → <span class=\"fn\">«$β»</span>)</span> → <span class=\"fn\">«$β»</span></span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$α»</span> → <span class=\"fn\">«$β»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">res_empty</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\"><span class=\"fn\">«$op»</span> <a href=\"./Mathlib/Data/Finset/Empty.html#Finset.empty\">Finset.empty</a> <span class=\"fn\">«$f»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">res_cons</span> :\n  <span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>} →\n    <span class=\"fn\">{<span class=\"fn\">s'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>} →\n      <span class=\"fn\">{<span class=\"fn\">h</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a»</span> ∉ <span class=\"fn\">«$s'»</span></span>)</span>} →\n        <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\"><span class=\"fn\">«$f»</span> <span class=\"fn\">«$a»</span></span>)</span></span> →\n          <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\"><span class=\"fn\">«$op»</span> <span class=\"fn\">«$s'»</span> <span class=\"fn\">«$f»</span></span>)</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\"><span class=\"fn\">«$op»</span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Finset/Insert.html#Finset.cons\">Finset.cons</a> <span class=\"fn\">«$a»</span> <span class=\"fn\">«$s'»</span> <span class=\"fn\">«$h»</span>)</span> <span class=\"fn\">«$f»</span></span>)</span>)</span></span></span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\"><span class=\"fn\">«$op»</span> <span class=\"fn\">«$s»</span> <span class=\"fn\">«$f»</span></span>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L324-L326","name":"Mathlib.Meta.NormNum.Finset.prod_empty","line":324,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Finset.prod_empty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Finset.prod_empty\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Finset</span>.<span class=\"name\">prod_empty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>.<a href=\"./Mathlib/Algebra/BigOperators/Group/Finset/Defs.html#Finset.prod\">prod</a></span> <span class=\"fn\">f</span>)</span> <span class=\"fn\">1</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L320-L322","name":"Mathlib.Meta.NormNum.Finset.sum_empty","line":320,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Finset.sum_empty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Finset.sum_empty\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Finset</span>.<span class=\"name\">sum_empty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>.<a href=\"./Mathlib/Algebra/BigOperators/Group/Finset/Defs.html#Finset.sum\">sum</a></span> <span class=\"fn\">f</span>)</span> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L302-L318","name":"Mathlib.Meta.NormNum.Result.eq_trans","line":302,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Result.eq_trans","doc":"If `a = b` and we can evaluate `b`, then we can evaluate `a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Result.eq_trans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">eq_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">Q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$b»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">b</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L257-L298","name":"Mathlib.Meta.Finset.proveEmptyOrCons","line":257,"kind":"opaque","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.proveEmptyOrCons","doc":"Either show the expression `s : Q(Finset α)` is empty, or remove one element from it.\n\nFails if we cannot determine which of the alternatives apply to the expression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.proveEmptyOrCons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">proveEmptyOrCons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">s</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L252-L255","name":"Mathlib.Meta.Finset.univ_eq_elems","line":252,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.univ_eq_elems","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.univ_eq_elems\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">univ_eq_elems</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Fintype/Defs.html#Fintype\">Fintype</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">elems</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">complete</span> : <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">elems</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Data/Fintype/Defs.html#Finset.univ\">Finset.univ</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">elems</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L248-L250","name":"Mathlib.Meta.Finset.range_succ'","line":248,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.range_succ'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.range_succ'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">range_succ'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">nn </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">nn</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn'</span> : <span class=\"fn\">nn</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n'</span>.<a href=\"./Init/Prelude.html#Nat.succ\">succ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Range.html#Finset.range\">Finset.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Insert.html#Finset.cons\">Finset.cons</a> <span class=\"fn\">n'</span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Finset/Range.html#Finset.range\">Finset.range</a> <span class=\"fn\">n'</span>)</span> <span class=\"fn\">⋯</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L245-L246","name":"Mathlib.Meta.Finset.range_zero'","line":245,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.range_zero'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.range_zero'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">range_zero'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Range.html#Finset.range\">Finset.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L241-L243","name":"Mathlib.Meta.Finset.insert_eq_cons","line":241,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.insert_eq_cons","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.insert_eq_cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">insert_eq_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">a</span> ∉ <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Insert.insert\">insert</a> <span class=\"fn\">a</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Insert.html#Finset.cons\">Finset.cons</a> <span class=\"fn\">a</span> <span class=\"fn\">s</span> <span class=\"fn\">h</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L233-L239","name":"Mathlib.Meta.Finset.ProveEmptyOrConsResult.eq_trans","line":233,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.eq_trans","doc":"If `s = t` and we can get the result for `t`, then we can get the result for `s`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.eq_trans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">ProveEmptyOrConsResult</span>.<span class=\"name\">eq_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s </span><span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$t»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">s</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L223-L231","name":"Mathlib.Meta.Finset.ProveEmptyOrConsResult.uncheckedCast","line":223,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.uncheckedCast","doc":"If `s` unifies with `t`, convert a result for `s` to a result for `t`.\n\nIf `s` does not unify with `t`, this results in a type-incorrect proof.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.uncheckedCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">ProveEmptyOrConsResult</span>.<span class=\"name\">uncheckedCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$β»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">s</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">t</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L220-L221","name":"Mathlib.Meta.Finset.ProveEmptyOrConsResult.cons","line":220,"kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.cons","doc":"The set equals `a` inserted into the strict subset `s'`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">ProveEmptyOrConsResult</span>.<span class=\"name\">cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a»</span> ∉ <span class=\"fn\">«$s'»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Insert.html#Finset.cons\">Finset.cons</a> <span class=\"fn\">«$a»</span> <span class=\"fn\">«$s'»</span> <span class=\"fn\">«$h»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">s</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L218-L219","name":"Mathlib.Meta.Finset.ProveEmptyOrConsResult.empty","line":218,"kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.empty","doc":"The set is empty. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.empty\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">ProveEmptyOrConsResult</span>.<span class=\"name\">empty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">s</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L215-L221","name":"Mathlib.Meta.Finset.ProveEmptyOrConsResult","line":215,"kind":"inductive","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult","doc":"This represents the result of trying to determine whether the given expression\n`s : Q(Finset $α)` is either empty or consists of an element inserted into a strict subset. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">ProveEmptyOrConsResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L183-L213","name":"Mathlib.Meta.Multiset.proveZeroOrCons","line":183,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.proveZeroOrCons","doc":"Either show the expression `s : Q(Multiset α)` is Zero, or remove one element from it.\n\nFails if we cannot determine which of the alternatives apply to the expression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.proveZeroOrCons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">proveZeroOrCons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">s</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L179-L181","name":"Mathlib.Meta.Multiset.range_succ'","line":179,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.range_succ'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.range_succ'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">range_succ'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">nn </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">nn</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn'</span> : <span class=\"fn\">nn</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n'</span>.<a href=\"./Init/Prelude.html#Nat.succ\">succ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Range.html#Multiset.range\">Multiset.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span> <a href=\"./Mathlib/Data/Multiset/ZeroCons.html#Multiset.cons\">::ₘ</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Range.html#Multiset.range\">Multiset.range</a> <span class=\"fn\">n'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L176-L177","name":"Mathlib.Meta.Multiset.range_zero'","line":176,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.range_zero'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.range_zero'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">range_zero'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Range.html#Multiset.range\">Multiset.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L172-L174","name":"Mathlib.Meta.Multiset.insert_eq_cons","line":172,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.insert_eq_cons","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.insert_eq_cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">insert_eq_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Insert.insert\">insert</a> <span class=\"fn\">a</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span> <a href=\"./Mathlib/Data/Multiset/ZeroCons.html#Multiset.cons\">::ₘ</a> <span class=\"fn\">s</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L164-L170","name":"Mathlib.Meta.Multiset.ProveZeroOrConsResult.eq_trans","line":164,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.eq_trans","doc":"If `s = t` and we can get the result for `t`, then we can get the result for `s`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.eq_trans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">ProveZeroOrConsResult</span>.<span class=\"name\">eq_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s </span><span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$t»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">s</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L154-L162","name":"Mathlib.Meta.Multiset.ProveZeroOrConsResult.uncheckedCast","line":154,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.uncheckedCast","doc":"If `s` unifies with `t`, convert a result for `s` to a result for `t`.\n\nIf `s` does not unify with `t`, this results in a type-incorrect proof.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.uncheckedCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">ProveZeroOrConsResult</span>.<span class=\"name\">uncheckedCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$β»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">s</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">t</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L151-L152","name":"Mathlib.Meta.Multiset.ProveZeroOrConsResult.cons","line":151,"kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.cons","doc":"The set equals `a` inserted into the strict subset `s'`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">ProveZeroOrConsResult</span>.<span class=\"name\">cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$a»</span> <a href=\"./Mathlib/Data/Multiset/ZeroCons.html#Multiset.cons\">::ₘ</a> <span class=\"fn\">«$s'»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">s</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L149-L150","name":"Mathlib.Meta.Multiset.ProveZeroOrConsResult.zero","line":149,"kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.zero","doc":"The set is zero. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">ProveZeroOrConsResult</span>.<span class=\"name\">zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">s</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L146-L152","name":"Mathlib.Meta.Multiset.ProveZeroOrConsResult","line":146,"kind":"inductive","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult","doc":"This represents the result of trying to determine whether the given expression\n`s : Q(Multiset $α)` is either empty or consists of an element inserted into a strict subset. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">ProveZeroOrConsResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L106-L144","name":"Mathlib.Meta.List.proveNilOrCons","line":106,"kind":"opaque","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.proveNilOrCons","doc":"Either show the expression `s : Q(List α)` is Nil, or remove one element from it.\n\nFails if we cannot determine which of the alternatives apply to the expression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.proveNilOrCons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">proveNilOrCons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">s</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L101-L103","name":"Mathlib.Meta.List.range_succ_eq_map'","line":101,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.range_succ_eq_map'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.range_succ_eq_map'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">range_succ_eq_map'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">nn </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">nn</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn'</span> : <span class=\"fn\">nn</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n'</span>.<a href=\"./Init/Prelude.html#Nat.succ\">succ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/List/Basic.html#List.range\">List.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\"><a href=\"./Init/Data/List/Basic.html#List.map\">List.map</a> <a href=\"./Init/Prelude.html#Nat.succ\">Nat.succ</a> <span class=\"fn\">(<a href=\"./Init/Data/List/Basic.html#List.range\">List.range</a> <span class=\"fn\">n'</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L98-L99","name":"Mathlib.Meta.List.range_zero'","line":98,"kind":"theorem","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.range_zero'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.range_zero'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">range_zero'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/List/Basic.html#List.range\">List.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L90-L96","name":"Mathlib.Meta.List.ProveNilOrConsResult.eq_trans","line":90,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.eq_trans","doc":"If `s = t` and we can get the result for `t`, then we can get the result for `s`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.eq_trans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">ProveNilOrConsResult</span>.<span class=\"name\">eq_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s </span><span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$t»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">s</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L80-L88","name":"Mathlib.Meta.List.ProveNilOrConsResult.uncheckedCast","line":80,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.uncheckedCast","doc":"If `s` unifies with `t`, convert a result for `s` to a result for `t`.\n\nIf `s` does not unify with `t`, this results in a type-incorrect proof.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.uncheckedCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">ProveNilOrConsResult</span>.<span class=\"name\">uncheckedCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$β»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">s</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">t</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L77-L78","name":"Mathlib.Meta.List.ProveNilOrConsResult.cons","line":77,"kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.cons","doc":"The set equals `a` inserted into the strict subset `s'`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">ProveNilOrConsResult</span>.<span class=\"name\">cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">«$s'»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">s</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L75-L76","name":"Mathlib.Meta.List.ProveNilOrConsResult.nil","line":75,"kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.nil","doc":"The set is Nil. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.nil\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">ProveNilOrConsResult</span>.<span class=\"name\">nil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">s</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L72-L78","name":"Mathlib.Meta.List.ProveNilOrConsResult","line":72,"kind":"inductive","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult","doc":"This represents the result of trying to determine whether the given expression\n`s : Q(List $α)` is either empty or consists of an element inserted into a strict subset. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">ProveNilOrConsResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L55-L70","name":"Mathlib.Meta.Nat.unifyZeroOrSucc","line":55,"kind":"def","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.unifyZeroOrSucc","doc":"Determine whether the expression `n : Q(ℕ)` unifies with `0` or `Nat.succ n'`.\n\nWe do not use `norm_num` functionality because we want definitional equality,\nnot propositional equality, for use in dependent types.\n\nFails if neither of the options succeed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.unifyZeroOrSucc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Nat</span>.<span class=\"name\">unifyZeroOrSucc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult\">UnifyZeroOrSuccResult</a> <span class=\"fn\">n</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L52-L53","name":"Mathlib.Meta.Nat.UnifyZeroOrSuccResult.succ","line":52,"kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult.succ","doc":"`n` unifies with `succ n'` for this specific `n'` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult.succ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Nat</span>.<span class=\"name\">UnifyZeroOrSuccResult</span>.<span class=\"name\">succ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\"><span class=\"fn\">«$n»</span> =Q <span class=\"fn\"><span class=\"fn\">«$n'»</span>.<a href=\"./Init/Prelude.html#Nat.succ\">succ</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult\">UnifyZeroOrSuccResult</a> <span class=\"fn\">n</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L50-L51","name":"Mathlib.Meta.Nat.UnifyZeroOrSuccResult.zero","line":50,"kind":"ctor","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult.zero","doc":"`n` unifies with `0` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Nat</span>.<span class=\"name\">UnifyZeroOrSuccResult</span>.<span class=\"name\">zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\"><span class=\"fn\">«$n»</span> =Q <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult\">UnifyZeroOrSuccResult</a> <span class=\"fn\">n</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/NormNum/BigOperators.lean#L47-L53","name":"Mathlib.Meta.Nat.UnifyZeroOrSuccResult","line":47,"kind":"inductive","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult","doc":"This represents the result of trying to determine whether the given expression `n : Q(ℕ)`\nis either `zero` or `succ`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Nat</span>.<span class=\"name\">UnifyZeroOrSuccResult</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}