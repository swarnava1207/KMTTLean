{"name":"Mathlib.Tactic.ModCases","instances":[],"imports":["Init","Mathlib.Data.Int.ModEq","Mathlib.Tactic.HaveI"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L170-L180","name":"Mathlib.Tactic.ModCases.«tacticMod_cases_:_%_»","line":170,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.«tacticMod_cases_:_%_»","doc":"* The tactic `mod_cases h : e % 3` will perform a case disjunction on `e`.\n  If `e : ℤ`, then it will yield subgoals containing the assumptions\n  `h : e ≡ 0 [ZMOD 3]`, `h : e ≡ 1 [ZMOD 3]`, `h : e ≡ 2 [ZMOD 3]`\n  respectively. If `e : ℕ` instead, then it works similarly, except with\n  `[MOD 3]` instead of `[ZMOD 3]`.\n* In general, `mod_cases h : e % n` works\n  when `n` is a positive numeral and `e` is an expression of type `ℕ` or `ℤ`.\n* If `h` is omitted as in `mod_cases e % n`, it will be default-named `H`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.«tacticMod_cases_:_%_»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">«tacticMod_cases_:_%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L151-L166","name":"Mathlib.Tactic.ModCases.NatMod.modCases","line":151,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.modCases","doc":"Nat case of `mod_cases h : e % n`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.modCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">modCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L136-L149","name":"Mathlib.Tactic.ModCases.NatMod.proveOnModCases","line":136,"kind":"opaque","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.proveOnModCases","doc":"Proves an expression of the form `OnModCases n a b p` where `n` and `b` are raw nat literals\nand `b ≤ n`. Returns the list of subgoals `?gi : a ≡ i [MOD n] → p`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.proveOnModCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">proveOnModCases</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\">OnModCases</a> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$a»</span> <span class=\"fn\">«$b»</span> <span class=\"fn\">«$p»</span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L126-L134","name":"Mathlib.Tactic.ModCases.NatMod.onModCases_succ","line":126,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_succ","doc":"The successor case decomposes `∃ m, b ≤ m < n ∧ a ≡ m (mod n)` into\n`a ≡ b (mod n) ∨ ∃ m, b+1 ≤ m < n ∧ a ≡ m (mod n)`,\nand the `a ≡ b (mod n) → p` case becomes a subgoal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_succ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">onModCases_succ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Mathlib/Data/Nat/ModEq.html#Nat.ModEq\">≡</a> <span class=\"fn\">b</span> <a href=\"./Mathlib/Data/Nat/ModEq.html#Nat.ModEq\">[MOD</a> <span class=\"fn\">n</span><a href=\"./Mathlib/Data/Nat/ModEq.html#Nat.ModEq\">]</a> → <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">b</span>.<a href=\"./Init/Prelude.html#Nat.add\">add</a></span> <span class=\"fn\">1</span>)</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span> <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L119-L124","name":"Mathlib.Tactic.ModCases.NatMod.onModCases_stop","line":119,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_stop","doc":"The end point is that once we have reduced to `∃ m, n ≤ m < n ∧ a ≡ m (mod n)`\nthere are no more cases to consider.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_stop\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">onModCases_stop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L107-L116","name":"Mathlib.Tactic.ModCases.NatMod.onModCases_start","line":107,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_start","doc":"The first theorem we apply says that `∃ m, 0 ≤ m < n ∧ a ≡ m (mod n)`.\nThe actual mathematical content of the proof is here.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_start\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">onModCases_start</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hn</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat.ble\">Nat.ble</a> <span class=\"fn\">1</span> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">0</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">p</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L98-L105","name":"Mathlib.Tactic.ModCases.NatMod.OnModCases","line":98,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases","doc":"`OnModCases n a lb p` represents a partial proof by cases that\nthere exists `0 ≤ m < n` such that `a ≡ m (mod n)`.\nIt asserts that if `∃ m, lb ≤ m < n ∧ a ≡ m (mod n)` holds, then `p`\n(where `p` is the current goal).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">OnModCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">a </span><span class=\"fn\">lb</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Sort</a> (imax 1 u_1)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L77-L92","name":"Mathlib.Tactic.ModCases.IntMod.modCases","line":77,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.modCases","doc":"Int case of `mod_cases h : e % n`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.modCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">modCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L60-L75","name":"Mathlib.Tactic.ModCases.IntMod.proveOnModCases","line":60,"kind":"opaque","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.proveOnModCases","doc":"Proves an expression of the form `OnModCases n a b p` where `n` and `b` are raw nat literals\nand `b ≤ n`. Returns the list of subgoals `?gi : a ≡ i [ZMOD n] → p`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.proveOnModCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">proveOnModCases</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\">OnModCases</a> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$a»</span> <span class=\"fn\">«$b»</span> <span class=\"fn\">«$p»</span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L50-L58","name":"Mathlib.Tactic.ModCases.IntMod.onModCases_succ","line":50,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_succ","doc":"The successor case decomposes `∃ z, b ≤ z < n ∧ a ≡ z (mod n)` into\n`a ≡ b (mod n) ∨ ∃ z, b+1 ≤ z < n ∧ a ≡ z (mod n)`,\nand the `a ≡ b (mod n) → p` case becomes a subgoal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_succ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">onModCases_succ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Mathlib/Data/Int/ModEq.html#Int.ModEq\">≡</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat.ofNat\">OfNat.ofNat</a> <span class=\"fn\">b</span></span> <a href=\"./Mathlib/Data/Int/ModEq.html#Int.ModEq\">[ZMOD</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat.ofNat\">OfNat.ofNat</a> <span class=\"fn\">n</span></span><a href=\"./Mathlib/Data/Int/ModEq.html#Int.ModEq\">]</a> → <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">b</span>.<a href=\"./Init/Prelude.html#Nat.add\">add</a></span> <span class=\"fn\">1</span>)</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span> <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L43-L48","name":"Mathlib.Tactic.ModCases.IntMod.onModCases_stop","line":43,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_stop","doc":"The end point is that once we have reduced to `∃ z, n ≤ z < n ∧ a ≡ z (mod n)`\nthere are no more cases to consider.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_stop\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">onModCases_stop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L30-L41","name":"Mathlib.Tactic.ModCases.IntMod.onModCases_start","line":30,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_start","doc":"The first theorem we apply says that `∃ z, 0 ≤ z < n ∧ a ≡ z (mod n)`.\nThe actual mathematical content of the proof is here.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_start\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">onModCases_start</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hn</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat.ble\">Nat.ble</a> <span class=\"fn\">1</span> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">0</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">p</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ModCases.lean#L21-L28","name":"Mathlib.Tactic.ModCases.IntMod.OnModCases","line":21,"kind":"def","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases","doc":"`OnModCases n a lb p` represents a partial proof by cases that\nthere exists `0 ≤ z < n` such that `a ≡ z (mod n)`.\nIt asserts that if `∃ z, lb ≤ z < n ∧ a ≡ z (mod n)` holds, then `p`\n(where `p` is the current goal).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">OnModCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lb</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Sort</a> (imax 1 u_1)</div></div>"}]}