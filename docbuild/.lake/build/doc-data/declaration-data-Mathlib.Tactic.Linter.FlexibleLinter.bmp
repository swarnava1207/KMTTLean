{"name":"Mathlib.Tactic.Linter.FlexibleLinter","instances":[{"typeNames":["Mathlib.Linter.Flexible.Stained"],"name":"Mathlib.Linter.Flexible.instReprStained","className":"Repr"},{"typeNames":["Mathlib.Linter.Flexible.Stained"],"name":"Mathlib.Linter.Flexible.instInhabitedStained","className":"Inhabited"},{"typeNames":["Eq"],"name":"Mathlib.Linter.Flexible.instDecidableEqStained","className":"Decidable"},{"typeNames":["Mathlib.Linter.Flexible.Stained"],"name":"Mathlib.Linter.Flexible.instHashableStained","className":"Hashable"},{"typeNames":["Mathlib.Linter.Flexible.Stained"],"name":"Mathlib.Linter.Flexible.instToStringStained","className":"ToString"}],"imports":["Init","Lean.Elab.Command","Mathlib.Init"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L371-L420","name":"Mathlib.Linter.Flexible.flexibleLinter","line":371,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.flexibleLinter","doc":"The main implementation of the flexible linter. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.flexibleLinter\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">flexibleLinter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.Linter\">Lean.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L348-L369","name":"Mathlib.Linter.Flexible.reallyPersist","line":348,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.reallyPersist","doc":"`reallyPersist` converts an array of pairs `(fvar, mvar)` to another array of the same type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.reallyPersist\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">reallyPersist</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fmvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvs0 </span><span class=\"fn\">mvs1</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx0 </span><span class=\"fn\">ctx1</span> : <a href=\"./Lean/MetavarContext.html#Lean.MetavarContext\">Lean.MetavarContext</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L340-L346","name":"Mathlib.Linter.Flexible.persistFVars","line":340,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.persistFVars","doc":"`persistFVars` is one step in persisting: track a single `FVarId` between two `LocalContext`s.\nIf an `FVarId` with the same unique name exists in the new context, use it.\nOtherwise, if an `FVarId` with the same `userName` exists in the new context, use it.\nIf both of these fail, return `default` (i.e. \"fail\"). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.persistFVars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">persistFVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fv</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">before </span><span class=\"fn\">after</span> : <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">Lean.LocalContext</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L320-L327","name":"Mathlib.Linter.Flexible.getFVarIdCandidates","line":320,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.getFVarIdCandidates","doc":"`getFVarIdCandidates fv name lctx` takes an input an `FVarId`, a `Name` and a `LocalContext`.\nIt returns an array of guesses for a \"best fit\" `FVarId` in the given `LocalContext`.\nThe first entry of the array is the input `FVarId` `fv`, if it is present.\nThe next entry of the array is the `FVarId` with the given `Name`, if present.\n\nUsually, the first entry of the returned array is \"the best approximation\" to `(fv, name)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.getFVarIdCandidates\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">getFVarIdCandidates</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fv</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lctx</span> : <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">Lean.LocalContext</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L305-L318","name":"Mathlib.Linter.Flexible.usesGoal?","line":305,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.usesGoal?","doc":"By default, if a `SyntaxNodeKind` is not special-cased here, then the linter assumes that\nthe tactic will use the goal as well: this heuristic works well with `exact`, `refine`, `apply`.\nFor tactics such as `cases` this is not true: for these tactics, `usesGoal?` yields `false. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.usesGoal?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">usesGoal?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.SyntaxNodeKind\">Lean.SyntaxNodeKind</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L279-L303","name":"Mathlib.Linter.Flexible.flexible","line":279,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.flexible","doc":"`SyntaxNodeKind`s that are allowed to follow a flexible tactic:\n`simp`, `simp_all`, `simpa`, `dsimp`, `constructor`, `congr`, `done`, `rfl`, `omega`, `abel`,\n`ring`, `linarith`, `nlinarith`, `norm_cast`, `aesop`, `tauto`, `fun_prop`, `split`, `split_ifs`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.flexible\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">flexible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashSet/Basic.html#Std.HashSet\">Std.HashSet</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L249-L277","name":"Mathlib.Linter.Flexible.stoppers","line":249,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.stoppers","doc":"`SyntaxNodeKind`s that are mostly \"formatting\": mostly they are ignored\nbecause we do not want the linter to spend time on them.\nThe nodes that they contain will be visited by the linter anyway.\nThe nodes that *follow* them, though, will *not* be visited by the linter.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.stoppers\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">stoppers</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashSet/Basic.html#Std.HashSet\">Std.HashSet</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L234-L247","name":"Mathlib.Linter.Flexible.Stained.toFMVarId","line":234,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained.toFMVarId","doc":"`Stained.toFMVarId mv lctx st` takes a metavariable `mv`, a local context `lctx` and\na `Stained` `st` and returns the array of pairs `(FVarId, mv)`s that `lctx` assigns to `st`\n(the second component is always `mv`):\n* if `st` \"is\" a `Name`, returns the singleton of the `FVarId` with the name carried by `st`;\n* if `st` is `.goal`, returns the singleton `#[default]`;\n* if `st` is `.wildcard`, returns the array of all the `FVarId`s in `lctx` with also `default`\n  (to keep track of the `goal`).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained.toFMVarId\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">Stained</span>.<span class=\"name\">toFMVarId</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mv</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lctx</span> : <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">Lean.LocalContext</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L219-L232","name":"Mathlib.Linter.Flexible.getStained!","line":219,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.getStained!","doc":"`getStained! stx` expects `stx` to be an argument of a node of `SyntaxNodeKind`\n`Lean.Parser.Tactic.location`.\nTypically, we apply `getStained!` to the output of `getLocs`.\n\nIt returns the `HashSet` of `Stained` determined by the locations in `stx`.\n\nThe only difference with `getStained stx`, is that `getStained!` never returns `{}`:\nif `getStained stx = {}`, then `getStained' stx = {.goal}`.\n\nThis means that tactics that do not have an explicit \"`at`\" in their syntax will be treated as\nacting on the main goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.getStained!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">getStained!</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">all?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>) =&gt; <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashSet/Basic.html#Std.HashSet\">Std.HashSet</a> <a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L206-L217","name":"Mathlib.Linter.Flexible.getStained","line":206,"kind":"opaque","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.getStained","doc":"`getStained stx` expects `stx` to be an argument of a node of `SyntaxNodeKind`\n`Lean.Parser.Tactic.location`.\nTypically, we apply `getStained` to the output of `getLocs`.\n\nSee `getStained!` for a similar function. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.getStained\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">getStained</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">all?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>) =&gt; <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashSet/Basic.html#Std.HashSet\">Std.HashSet</a> <a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L187-L204","name":"Mathlib.Linter.Flexible.toStained","line":187,"kind":"opaque","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.toStained","doc":"`toStained stx` scans the input `Syntax` `stx` extracting identifiers and atoms, making an effort\nto convert them to `Stained`.\nThe function is used to extract \"location\" information about `stx`: either explicit locations as in\n`rw [] at locations` or implicit ones as `rw [h]`.\n\nWhether or not what this function extracts really is a location will be determined by the linter\nusing data embedded in the `InfoTree`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.toStained\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">toStained</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Std/Data/HashSet/Basic.html#Std.HashSet\">Std.HashSet</a> <a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L179-L185","name":"Mathlib.Linter.Flexible.instToStringStained","line":179,"kind":"instance","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.instToStringStained","doc":"Converting a `Stained` to a `String`:\n* a `Name` is represented by the corresponding string;\n* `goal` is represented by `⊢`;\n* `wildcard` is represented by `*`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.instToStringStained\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">instToStringStained</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L177-L177","name":"Mathlib.Linter.Flexible.instHashableStained","line":177,"kind":"instance","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.instHashableStained","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.instHashableStained\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">instHashableStained</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L177-L177","name":"Mathlib.Linter.Flexible.instDecidableEqStained","line":177,"kind":"instance","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.instDecidableEqStained","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.instDecidableEqStained\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">instDecidableEqStained</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L177-L177","name":"Mathlib.Linter.Flexible.instInhabitedStained","line":177,"kind":"instance","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.instInhabitedStained","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.instInhabitedStained\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">instInhabitedStained</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L177-L177","name":"Mathlib.Linter.Flexible.instReprStained","line":177,"kind":"instance","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.instReprStained","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.instReprStained\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">instReprStained</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L176-L176","name":"Mathlib.Linter.Flexible.Stained.wildcard","line":176,"kind":"ctor","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained.wildcard","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained.wildcard\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">Stained</span>.<span class=\"name\">wildcard</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L175-L175","name":"Mathlib.Linter.Flexible.Stained.goal","line":175,"kind":"ctor","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained.goal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained.goal\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">Stained</span>.<span class=\"name\">goal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L174-L174","name":"Mathlib.Linter.Flexible.Stained.name","line":174,"kind":"ctor","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained.name","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained.name\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">Stained</span>.<span class=\"name\">name</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\">Stained</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L168-L177","name":"Mathlib.Linter.Flexible.Stained","line":168,"kind":"inductive","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained","doc":"`Stained` is the type of the stained locations: it can be\n* a `Name` (typically of associated to the `FVarId` of a local declaration);\n* the goal (`⊢`);\n* the \"wildcard\" -- all the declaration in context (`*`).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.Stained\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">Stained</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L144-L166","name":"Mathlib.Linter.Flexible.extractCtxAndGoals","line":144,"kind":"opaque","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.extractCtxAndGoals","doc":"`extractCtxAndGoals take? tree` takes as input a function `take? : Syntax → Bool` and\nan `InfoTree` and returns the array of pairs `(stx, mvars)`,\nwhere `stx` is a syntax node such that `take? stx` is `true` and\n`mvars` indicates the goal state:\n * the context before `stx`\n * the context after `stx`\n * a list of metavariables closed by `stx`\n * a list of metavariables created by `stx`\n\nA typical usage is to find the goals following a `simp` application.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.Flexible.extractCtxAndGoals\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">Flexible</span>.<span class=\"name\">extractCtxAndGoals</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">take?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/InfoTree/Types.html#Lean.Elab.InfoTree\">Lean.Elab.InfoTree</a> →\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/MetavarContext.html#Lean.MetavarContext\">Lean.MetavarContext</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/MetavarContext.html#Lean.MetavarContext\">Lean.MetavarContext</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L133-L136","name":"Lean.Elab.TacticInfo.goalsCreatedBy","line":133,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Lean.Elab.TacticInfo.goalsCreatedBy","doc":"`goalsCreatedBy t` are the `MVarId`s after the `TacticInfo` `t` that were not present before.\nThey should correspond to the goals created or changed by the tactic `t`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Lean.Elab.TacticInfo.goalsCreatedBy\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">TacticInfo</span>.<span class=\"name\">goalsCreatedBy</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <a href=\"./Lean/Elab/InfoTree/Types.html#Lean.Elab.TacticInfo\">TacticInfo</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L128-L131","name":"Lean.Elab.TacticInfo.goalsTargetedBy","line":128,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Lean.Elab.TacticInfo.goalsTargetedBy","doc":"`goalsTargetedBy t` are the `MVarId`s before the `TacticInfo` `t` that \"disappear\" after it.\nThey should correspond to the goals in which the tactic `t` performs some action. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Lean.Elab.TacticInfo.goalsTargetedBy\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">TacticInfo</span>.<span class=\"name\">goalsTargetedBy</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <a href=\"./Lean/Elab/InfoTree/Types.html#Lean.Elab.TacticInfo\">TacticInfo</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L102-L112","name":"Mathlib.Linter.flexible?","line":102,"kind":"def","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.flexible?","doc":"`flexible? stx` is `true` if `stx` is syntax for a tactic that takes a \"wide\" variety of\ninputs and modifies them in possibly unpredictable ways.\n\nThe prototypical flexible tactic is `simp`.\nThe prototypical non-flexible tactic `rw`.\n`simp only` is also non-flexible. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.flexible?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">flexible?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Linter/FlexibleLinter.lean#L96-L100","name":"Mathlib.Linter.linter.flexible","line":96,"kind":"opaque","docLink":"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.linter.flexible","doc":"The flexible linter makes sure that \"rigid\" tactics do not follow \"flexible\" tactics. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/FlexibleLinter.html#Mathlib.Linter.linter.flexible\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">linter</span>.<span class=\"name\">flexible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"}]}