{"name":"Mathlib.Tactic.CategoryTheory.Slice","instances":[],"imports":["Init","Mathlib.CategoryTheory.Category.Basic","Mathlib.Tactic.Conv"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Slice.lean#L69-L73","name":"sliceRHS","line":69,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Slice.html#sliceRHS","doc":"`slice_rhs a b => tac` zooms to the right hand side, uses associativity for categorical\ncomposition as needed, zooms in on the `a`-th through `b`-th morphisms, and invokes `tac`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Slice.html#sliceRHS\"><span class=\"name\">sliceRHS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Slice.lean#L60-L64","name":"sliceLHS","line":60,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Slice.html#sliceLHS","doc":"`slice_lhs a b => tac` zooms to the left hand side, uses associativity for categorical\ncomposition as needed, zooms in on the `a`-th through `b`-th morphisms, and invokes `tac`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Slice.html#sliceLHS\"><span class=\"name\">sliceLHS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Slice.lean#L57-L58","name":"convSlice___","line":57,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Slice.html#convSlice___","doc":"`slice` is implemented by `evalSlice`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Slice.html#convSlice___\"><span class=\"name\">convSlice___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Slice.lean#L34-L55","name":"evalSlice","line":34,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Slice.html#evalSlice","doc":"`evalSlice`\n- rewrites the target expression using `Category.assoc`.\n- uses `congr` to split off the first `a-1` terms and rotates to `a`-th (last) term\n- counts the number `k` of rewrites as it uses `←Category.assoc` to bring the target to\n  left associated form; from the first step this is the total number of remaining terms from `C`\n- it now splits off `b-a` terms from target using `congr` leaving the desired subterm\n- finally, it rewrites it once more using `Category.assoc` to bring it to right-associated\n  normal form\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Slice.html#evalSlice\"><span class=\"name\">evalSlice</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Slice.lean#L27-L32","name":"slice","line":27,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Slice.html#slice","doc":"`slice` is a conv tactic; if the current focus is a composition of several morphisms,\n`slice a b` reassociates as needed, and zooms in on the `a`-th through `b`-th morphisms.\nThus if the current focus is `(a ≫ b) ≫ ((c ≫ d) ≫ e)`, then `slice 2 3` zooms to `b ≫ c`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Slice.html#slice\"><span class=\"name\">slice</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}