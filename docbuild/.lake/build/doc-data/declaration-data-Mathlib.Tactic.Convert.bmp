{"name":"Mathlib.Tactic.Convert","instances":[],"imports":["Init","Mathlib.Tactic.CongrExclamation"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Convert.lean#L199-L208","name":"Mathlib.Tactic.acChange","line":199,"kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.acChange","doc":"`ac_change g using n` is `convert_to g using n` followed by `ac_rfl`. It is useful for\nrearranging/reassociating e.g. sums:\n```lean\nexample (a b c d e f g N : ℕ) : (a + b) + (c + d) + (e + f) + g ≤ N := by\n  ac_change a + d + e + f + c + g + b ≤ _\n  -- ⊢ a + d + e + f + c + g + b ≤ N\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.acChange\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">acChange</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Convert.lean#L156-L178","name":"Mathlib.Tactic.convertTo","line":156,"kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convertTo","doc":"The `convert_to` tactic is for changing the type of the target or a local hypothesis,\nbut unlike the `change` tactic it will generate equality proof obligations using `congr!`\nto resolve discrepancies.\n\n* `convert_to ty` changes the target to `ty`\n* `convert_to ty using n` uses `congr! n` instead of `congr! 1`\n* `convert_to ty at h` changes the type of the local hypothesis `h` to `ty`.\n  Any remaining `congr!` goals come first.\n\nOperating on the target, the tactic `convert_to ty using n`\nis the same as `convert (?_ : ty) using n`.\nThe difference is that `convert_to` takes a type but `convert` takes a proof term.\n\nExcept for it also being able to operate on local hypotheses,\nthe syntax for `convert_to` is the same as for `convert`, and it has variations such as\n`convert_to ← g` and `convert_to (config := {transparency := .default}) g`.\n\nNote that `convert_to ty at h` may leave a copy of `h` if a later local hypotheses or the target\ndepends on it, just like in `rw` or `simp`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convertTo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convertTo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Convert.lean#L123-L137","name":"Mathlib.Tactic.elabTermForConvert","line":123,"kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.elabTermForConvert","doc":"Elaborates `term` ensuring the expected type, allowing stuck metavariables.\nReturns stuck metavariables as additional goals.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.elabTermForConvert\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabTermForConvert</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">term</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Convert.lean#L58-L121","name":"Mathlib.Tactic.convert","line":58,"kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convert","doc":"The `exact e` and `refine e` tactics require a term `e` whose type is\ndefinitionally equal to the goal. `convert e` is similar to `refine e`,\nbut the type of `e` is not required to exactly match the\ngoal. Instead, new goals are created for differences between the type\nof `e` and the goal using the same strategies as the `congr!` tactic.\nFor example, in the proof state\n\n```lean\nn : ℕ,\ne : Prime (2 * n + 1)\n⊢ Prime (n + n + 1)\n```\n\nthe tactic `convert e using 2` will change the goal to\n\n```lean\n⊢ n + n = 2 * n\n```\n\nIn this example, the new goal can be solved using `ring`.\n\nThe `using 2` indicates it should iterate the congruence algorithm up to two times,\nwhere `convert e` would use an unrestricted number of iterations and lead to two\nimpossible goals: `⊢ HAdd.hAdd = HMul.hMul` and `⊢ n = 2`.\n\nA variant configuration is `convert (config := .unfoldSameFun) e`, which only equates function\napplications for the same function (while doing so at the higher `default` transparency).\nThis gives the same goal of `⊢ n + n = 2 * n` without needing `using 2`.\n\nThe `convert` tactic applies congruence lemmas eagerly before reducing,\ntherefore it can fail in cases where `exact` succeeds:\n```lean\ndef p (n : ℕ) := True\nexample (h : p 0) : p 1 := by exact h -- succeeds\nexample (h : p 0) : p 1 := by convert h -- fails, with leftover goal `1 = 0`\n```\nLimiting the depth of recursion can help with this. For example, `convert h using 1` will work\nin this case.\n\nThe syntax `convert ← e` will reverse the direction of the new goals\n(producing `⊢ 2 * n = n + n` in this example).\n\nInternally, `convert e` works by creating a new goal asserting that\nthe goal equals the type of `e`, then simplifying it using\n`congr!`. The syntax `convert e using n` can be used to control the\ndepth of matching (like `congr! n`). In the example, `convert e using 1`\nwould produce a new goal `⊢ n + n + 1 = 2 * n + 1`.\n\nRefer to the `congr!` tactic to understand the congruence operations. One of its many\nfeatures is that if `x y : t` and an instance `Subsingleton t` is in scope,\nthen any goals of the form `x = y` are solved automatically.\n\nLike `congr!`, `convert` takes an optional `with` clause of `rintro` patterns,\nfor example `convert e using n with x y z`.\n\nThe `convert` tactic also takes a configuration option, for example\n```lean\nconvert (config := {transparency := .default}) h\n```\nThese are passed to `congr!`. See `Congr!.Config` for options.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convert\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Convert.lean#L34-L54","name":"Lean.MVarId.convertLocalDecl","line":34,"kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Lean.MVarId.convertLocalDecl","doc":"Replaces the type of the local declaration `fvarId` with `typeNew`,\nusing `Lean.MVarId.congrN!` to prove that the old type of `fvarId` is equal to `typeNew`.\nUses `Lean.MVarId.replaceLocalDecl` to replace the type.\nReturns the new goal along with the side goals generated by `congrN!`.\n\nWith `symm = true`, reverses the equality,\nchanging the goal to prove `typeNew` is equal to `typeOld`.\nWith `depth = some n`, calls `MVarId.congrN! n` instead, with `n` as the max recursion depth.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Convert.html#Lean.MVarId.convertLocalDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">convertLocalDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">typeNew</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symm</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">depth</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Congr!.Config</a> := <span class=\"fn\">{ }</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">patterns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`rcasesPat</span>)</span> := <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Convert.lean#L14-L32","name":"Lean.MVarId.convert","line":14,"kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Lean.MVarId.convert","doc":"Close the goal `g` using `Eq.mp v e`,\nwhere `v` is a metavariable asserting that the type of `g` and `e` are equal.\nThen call `MVarId.congrN!` (also using local hypotheses and reflexivity) on `v`,\nand return the resulting goals.\n\nWith `symm = true`, reverses the equality in `v`, and uses `Eq.mpr v e` instead.\nWith `depth = some n`, calls `MVarId.congrN! n` instead, with `n` as the max recursion depth.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Convert.html#Lean.MVarId.convert\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">convert</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symm</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">depth</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CongrExclamation.html#Congr!.Config\">Congr!.Config</a> := <span class=\"fn\">{ }</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">patterns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`rcasesPat</span>)</span> := <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>"}]}