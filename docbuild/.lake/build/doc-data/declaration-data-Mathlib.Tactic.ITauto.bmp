{"name":"Mathlib.Tactic.ITauto","instances":[{"typeNames":["Mathlib.Tactic.ITauto.AndKind"],"name":"Mathlib.Tactic.ITauto.instToExprAndKind","className":"Lean.ToExpr"},{"typeNames":["Eq"],"name":"Mathlib.Tactic.ITauto.instDecidableEqAndKind","className":"Decidable"},{"typeNames":["Mathlib.Tactic.ITauto.AndKind"],"name":"Mathlib.Tactic.ITauto.instInhabitedAndKind","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.ITauto.IProp"],"name":"Mathlib.Tactic.ITauto.instToExprIProp","className":"Lean.ToExpr"},{"typeNames":["Eq"],"name":"Mathlib.Tactic.ITauto.instDecidableEqIProp","className":"Decidable"},{"typeNames":["Mathlib.Tactic.ITauto.IProp"],"name":"Mathlib.Tactic.ITauto.instInhabitedIProp","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.ITauto.IProp"],"name":"Mathlib.Tactic.ITauto.instToFormatIProp","className":"Std.ToFormat"},{"typeNames":["Mathlib.Tactic.ITauto.IProp"],"name":"Mathlib.Tactic.ITauto.instLTIProp","className":"LT"},{"typeNames":["LT.lt"],"name":"Mathlib.Tactic.ITauto.instDecidableLTIProp","className":"Decidable"},{"typeNames":["Mathlib.Tactic.ITauto.Proof"],"name":"Mathlib.Tactic.ITauto.instToExprProof","className":"Lean.ToExpr"},{"typeNames":["Mathlib.Tactic.ITauto.Proof"],"name":"Mathlib.Tactic.ITauto.instInhabitedProof","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.ITauto.Proof"],"name":"Mathlib.Tactic.ITauto.instToFormatProof","className":"Std.ToFormat"},{"typeNames":["Mathlib.Tactic.ITauto.Context"],"name":"Mathlib.Tactic.ITauto.instToFormatContext","className":"Std.ToFormat"}],"imports":["Init","Batteries.Tactic.Exact","Batteries.Tactic.Init","Mathlib.Logic.Basic","Mathlib.Util.AtomM","Qq"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L718-L718","name":"Mathlib.Tactic.ITauto.itauto!","line":718,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itauto!","doc":"A decision procedure for intuitionistic propositional logic. Unlike `finish` and `tauto!` this\ntactic never uses the law of excluded middle (without the `!` option), and the proof search is\ntailored for this use case. (`itauto!` will work as a classical SAT solver, but the algorithm is\nnot very good in this situation.)\n\n```lean\nexample (p : Prop) : ¬ (p ↔ ¬ p) := by itauto\n```\n\n`itauto [a, b]` will additionally attempt case analysis on `a` and `b` assuming that it can derive\n`Decidable a` and `Decidable b`. `itauto *` will case on all decidable propositions that it can\nfind among the atomic propositions, and `itauto! *` will case on all propositional atoms.\n*Warning:* This can blow up the proof search, so it should be used sparingly.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itauto!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">itauto!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L695-L709","name":"Mathlib.Tactic.ITauto.itauto","line":695,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itauto","doc":"A decision procedure for intuitionistic propositional logic. Unlike `finish` and `tauto!` this\ntactic never uses the law of excluded middle (without the `!` option), and the proof search is\ntailored for this use case. (`itauto!` will work as a classical SAT solver, but the algorithm is\nnot very good in this situation.)\n\n```lean\nexample (p : Prop) : ¬ (p ↔ ¬ p) := by itauto\n```\n\n`itauto [a, b]` will additionally attempt case analysis on `a` and `b` assuming that it can derive\n`Decidable a` and `Decidable b`. `itauto *` will case on all decidable propositions that it can\nfind among the atomic propositions, and `itauto! *` will case on all propositional atoms.\n*Warning:* This can blow up the proof search, so it should be used sparingly.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itauto\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">itauto</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L631-L691","name":"Mathlib.Tactic.ITauto.itautoCore","line":631,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itautoCore","doc":"A decision procedure for intuitionistic propositional logic.\n\n* `useDec` will add `a ∨ ¬ a` to the context for every decidable atomic proposition `a`.\n* `useClassical` will allow `a ∨ ¬ a` to be added even if the proposition is not decidable,\n  using classical logic.\n* `extraDec` will add `a ∨ ¬ a` to the context for specified (not necessarily atomic)\n  propositions `a`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itautoCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">itautoCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">useDec </span><span class=\"fn\">useClassical</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">extraDec</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L490-L629","name":"Mathlib.Tactic.ITauto.applyProof","line":490,"kind":"opaque","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.applyProof","doc":"Once we have a proof object, we have to apply it to the goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.applyProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">applyProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Γ</span> : <span class=\"fn\"><a href=\"./Lean/Data/NameMap.html#Lean.NameMap\">Lean.NameMap</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L473-L488","name":"Mathlib.Tactic.ITauto.reify","line":473,"kind":"opaque","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.reify","doc":"Reify an `Expr` into a `IProp`, allocating anything non-propositional as an atom in the\n`AtomM` state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.reify\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">reify</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L431-L467","name":"Mathlib.Tactic.ITauto.prove","line":431,"kind":"opaque","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.prove","doc":"The main prover. This receives a context of proven or assumed lemmas and a target proposition,\nand returns a proof or `none` (with state for the fresh variable generator).\nThe intuitionistic logic rules are separated into three groups:\n\n* level 1: No splitting, validity preserving: apply whenever you can.\n  Left rules in `Context.add`, right rules in `prove`\n* level 2: Splitting rules, validity preserving: apply after level 1 rules. Done in `prove`\n* level 3: Splitting rules, not validity preserving: apply only if nothing else applies.\n  Done in `search`\n\nThe level 1 rules on the right of the turnstile are `Γ ⊢ ⊤` and `Γ ⊢ A → B`, these are easy to\nhandle. The rule `Γ ⊢ A ∧ B` is a level 2 rule, also handled here. If none of these apply, we try\nthe level 2 rule `A ∨ B ⊢ C` by searching the context and splitting all ors we find. Finally, if\nwe don't make any more progress, we go to the search phase.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.prove\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">prove</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Γ</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">B</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L397-L429","name":"Mathlib.Tactic.ITauto.search","line":397,"kind":"opaque","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.search","doc":"The search phase, which deals with the level 3 rules, which are rules that are not validity\npreserving and so require proof search. One obvious one is the or-introduction rule: we prove\n`A ∨ B` by proving `A` or `B`, and we might have to try one and backtrack.\n\nThere are two rules dealing with implication in this category: `p, p → C ⊢ B` where `p` is an\natom (which is safe if we can find it but often requires the right search to expose the `p`\nassumption), and `(A₁ → A₂) → C ⊢ B`. We decompose the double implication into two subgoals: one to\nprove `A₁ → A₂`, which can be written `A₂ → C, A₁ ⊢ A₂` (where we used `A₁` to simplify\n`(A₁ → A₂) → C`), and one to use the consequent, `C ⊢ B`. The search here is that there are\npotentially many implications to split like this, and we have to try all of them if we want to be\ncomplete. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.search\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">search</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Γ</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">B</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L390-L393","name":"Mathlib.Tactic.ITauto.whenOk","line":390,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.whenOk","doc":"Skip the continuation and return a failed proof if the boolean is false. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.whenOk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">whenOk</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Bool\">Bool</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span> → <span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L385-L388","name":"Mathlib.Tactic.ITauto.isOk","line":385,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.isOk","doc":"Convert a value-with-success to an optional value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.isOk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">isOk</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>) <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L381-L383","name":"Mathlib.Tactic.ITauto.mapProof","line":381,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.mapProof","doc":"Map a function over the proof (regardless of whether the proof is successful or not). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.mapProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">mapProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L372-L379","name":"Mathlib.Tactic.ITauto.Context.withAdd","line":372,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.withAdd","doc":"Add `A` to the context `Γ` with proof `p`. This version of `Context.add` takes a continuation\nand a target proposition `B`, so that in the case that `⊥` is found we can skip the continuation\nand just prove `B` outright. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.withAdd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Context</span>.<span class=\"name\">withAdd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Γ</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">A</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">B</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L349-L370","name":"Mathlib.Tactic.ITauto.Context.add","line":349,"kind":"opaque","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.add","doc":"Insert a proposition and its proof into the context, as in `have : A := p`. This will eagerly\napply all level 1 rules on the spot, which are rules that don't split the goal and are validity\npreserving: specifically, we drop `⊤` and `A → ⊤` hypotheses, close the goal if we find a `⊥`\nhypothesis, split all conjunctions, and also simplify `⊥ → A` (drop), `⊤ → A` (simplify to `A`),\n`A ∧ B → C` (curry to `A → B → C`) and `A ∨ B → C` (rewrite to `(A → C) ∧ (B → C)` and split). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Context</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Except\">Except</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L347-L347","name":"Mathlib.Tactic.ITauto.instToFormatContext","line":347,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatContext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatContext\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToFormatContext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L343-L345","name":"Mathlib.Tactic.ITauto.Context.format","line":343,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.format","doc":"Debug printer for the context. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.format\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Context</span>.<span class=\"name\">format</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Γ</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L340-L341","name":"Mathlib.Tactic.ITauto.Context","line":340,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context","doc":"The context during proof search is a map from propositions to proof values. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Context</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L337-L338","name":"Mathlib.Tactic.ITauto.freshName","line":337,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.freshName","doc":"Get a new name in the pattern `h0, h1, h2, ...` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.freshName\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">freshName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L268-L276","name":"Mathlib.Tactic.ITauto.Proof.app","line":268,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.app","doc":"A variant on `Proof.app'` that performs opportunistic simplification.\n(This doesn't do full normalization because we don't want the proof size to blow up.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.app\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L263-L266","name":"Mathlib.Tactic.ITauto.Proof.orElim","line":263,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orElim","doc":"A variant on `Proof.orElim'` that performs opportunistic simplification. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orElim\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orElim</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L258-L261","name":"Mathlib.Tactic.ITauto.Proof.exfalso","line":258,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.exfalso","doc":"A variant on `Proof.exfalso'` that performs opportunistic simplification. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.exfalso\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">exfalso</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L256-L256","name":"Mathlib.Tactic.ITauto.instToFormatProof","line":256,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatProof","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToFormatProof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L233-L254","name":"Mathlib.Tactic.ITauto.Proof.format","line":233,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.format","doc":"Debugging printer for proof objects. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.format\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">format</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L231-L231","name":"Mathlib.Tactic.ITauto.instInhabitedProof","line":231,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedProof","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instInhabitedProof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L229-L229","name":"Mathlib.Tactic.ITauto.instToExprProof","line":229,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprProof","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToExprProof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/ToExpr.html#Lean.ToExpr\">Lean.ToExpr</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L225-L228","name":"Mathlib.Tactic.ITauto.Proof.impImpSimp","line":225,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.impImpSimp","doc":"The variable `x` here names the variable that will be used in the elaborated proof.\n* `(p: ((x:A) → B) → C) ⊢ B → C`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.impImpSimp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">impImpSimp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L220-L224","name":"Mathlib.Tactic.ITauto.Proof.em","line":220,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.em","doc":"* `classical = false`: `(p: Decidable A) ⊢ A ∨ ¬A`\n* `classical = true`: `(p: Prop) ⊢ p ∨ ¬p`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.em\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">em</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">classical</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L218-L219","name":"Mathlib.Tactic.ITauto.Proof.decidableElim","line":218,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.decidableElim","doc":"`(p₁: Decidable A) (p₂: (x: A) ⊢ C) (p₃: (x: ¬ A) ⊢ C) ⊢ C` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.decidableElim\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">decidableElim</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">classical</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p₁ </span><span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p₂ </span><span class=\"fn\">p₃</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L216-L217","name":"Mathlib.Tactic.ITauto.Proof.orElim'","line":216,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orElim'","doc":"`(p₁: A ∨ B) (p₂: (x: A) ⊢ C) (p₃: (x: B) ⊢ C) ⊢ C` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orElim'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orElim'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p₁</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p₂ </span><span class=\"fn\">p₃</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L214-L215","name":"Mathlib.Tactic.ITauto.Proof.orInR","line":214,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orInR","doc":"`(p: B) ⊢ A ∨ B` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orInR\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orInR</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L212-L213","name":"Mathlib.Tactic.ITauto.Proof.orInL","line":212,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orInL","doc":"`(p: A) ⊢ A ∨ B` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orInL\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orInL</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L210-L211","name":"Mathlib.Tactic.ITauto.Proof.orImpR","line":210,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orImpR","doc":"`(p: A ∨ B → C) ⊢ B → C` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orImpR\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orImpR</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L208-L209","name":"Mathlib.Tactic.ITauto.Proof.orImpL","line":208,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orImpL","doc":"`(p: A ∨ B → C) ⊢ A → C` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orImpL\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orImpL</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L206-L207","name":"Mathlib.Tactic.ITauto.Proof.app'","line":206,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.app'","doc":"`(p: A → B) (q: A) ⊢ B` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.app'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">app'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L200-L205","name":"Mathlib.Tactic.ITauto.Proof.curry₂","line":200,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.curry₂","doc":"This is a partial application of curry.\n* `ak = .and`: `(p: A ∧ B → C) (q : A) ⊢ B → C`\n* `ak = .iff`: `(p: (A ↔ B) → C) (q: A → B) ⊢ (B → A) → C`\n* `ak = .eq`: `(p: (A ↔ B) → C) (q: A → B) ⊢ (B → A) → C`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.curry₂\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">curry₂</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ak</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L194-L199","name":"Mathlib.Tactic.ITauto.Proof.curry","line":194,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.curry","doc":"* `ak = .and`: `(p: A ∧ B → C) ⊢ A → B → C`\n* `ak = .iff`: `(p: (A ↔ B) → C) ⊢ (A → B) → (B → A) → C`\n* `ak = .eq`: `(p: (A = B) → C) ⊢ (A → B) → (B → A) → C`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.curry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">curry</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ak</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L188-L193","name":"Mathlib.Tactic.ITauto.Proof.andIntro","line":188,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andIntro","doc":"* `ak = .and`: `(p₁: A) (p₂: B) ⊢ A ∧ B`\n* `ak = .iff`: `(p₁: A → B) (p₁: B → A) ⊢ A ↔ B`\n* `ak = .eq`: `(p₁: A → B) (p₁: B → A) ⊢ A = B`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andIntro\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">andIntro</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ak</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p₁ </span><span class=\"fn\">p₂</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L182-L187","name":"Mathlib.Tactic.ITauto.Proof.andRight","line":182,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andRight","doc":"* `ak = .and`: `(p: A ∧ B) ⊢ B`\n* `ak = .iff`: `(p: A ↔ B) ⊢ B → A`\n* `ak = .eq`: `(p: A = B) ⊢ B → A`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andRight\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">andRight</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ak</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L176-L181","name":"Mathlib.Tactic.ITauto.Proof.andLeft","line":176,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andLeft","doc":"* `ak = .and`: `(p: A ∧ B) ⊢ A`\n* `ak = .iff`: `(p: A ↔ B) ⊢ A → B`\n* `ak = .eq`: `(p: A = B) ⊢ A → B`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andLeft\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">andLeft</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ak</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L174-L175","name":"Mathlib.Tactic.ITauto.Proof.intro","line":174,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.intro","doc":"`(p: (x: A) ⊢ B) ⊢ A → B` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.intro\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">intro</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L172-L173","name":"Mathlib.Tactic.ITauto.Proof.exfalso'","line":172,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.exfalso'","doc":"`(p: ⊥) ⊢ A` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.exfalso'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">exfalso'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L170-L171","name":"Mathlib.Tactic.ITauto.Proof.triv","line":170,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.triv","doc":"`⊢ ⊤` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.triv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">triv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L168-L169","name":"Mathlib.Tactic.ITauto.Proof.hyp","line":168,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.hyp","doc":"`(n: A) ⊢ A` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.hyp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">hyp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L166-L167","name":"Mathlib.Tactic.ITauto.Proof.sorry","line":166,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.sorry","doc":"`⊢ A`, causes failure during reconstruction "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.sorry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">sorry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L164-L229","name":"Mathlib.Tactic.ITauto.Proof","line":164,"kind":"inductive","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof","doc":"A reified inductive proof type for intuitionistic propositional logic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L160-L160","name":"Mathlib.Tactic.ITauto.instDecidableLTIProp","line":160,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instDecidableLTIProp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instDecidableLTIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instDecidableLTIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L158-L158","name":"Mathlib.Tactic.ITauto.instLTIProp","line":158,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instLTIProp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instLTIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instLTIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L142-L156","name":"Mathlib.Tactic.ITauto.IProp.cmp","line":142,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.cmp","doc":"A comparator for propositions. (There should really be a derive handler for this.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">cmp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L137-L140","name":"Mathlib.Tactic.ITauto.AndKind.cmp","line":137,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.cmp","doc":"A comparator for `AndKind`. (There should really be a derive handler for this.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span>.<span class=\"name\">cmp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L135-L135","name":"Mathlib.Tactic.ITauto.instToFormatIProp","line":135,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatIProp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToFormatIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L124-L133","name":"Mathlib.Tactic.ITauto.IProp.format","line":124,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.format","doc":"Debugging printer for propositions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.format\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">format</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L119-L122","name":"Mathlib.Tactic.ITauto.AndKind.sides","line":119,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.sides","doc":"Given the contents of an `And` variant, return the two conjuncts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.sides\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span>.<span class=\"name\">sides</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L117-L117","name":"Mathlib.Tactic.ITauto.instInhabitedIProp","line":117,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedIProp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instInhabitedIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L114-L115","name":"Mathlib.Tactic.ITauto.IProp.xor","line":114,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.xor","doc":"Constructor for `xor p q`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.xor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">xor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L111-L112","name":"Mathlib.Tactic.ITauto.IProp.not","line":111,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.not","doc":"Constructor for `¬ p`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.not\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">not</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L108-L109","name":"Mathlib.Tactic.ITauto.IProp.eq","line":108,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.eq","doc":"Constructor for `p = q`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">eq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L105-L106","name":"Mathlib.Tactic.ITauto.IProp.iff","line":105,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.iff","doc":"Constructor for `p ↔ q`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.iff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">iff</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L102-L103","name":"Mathlib.Tactic.ITauto.IProp.and","line":102,"kind":"def","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.and","doc":"Constructor for `p ∧ q`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.and\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">and</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L100-L100","name":"Mathlib.Tactic.ITauto.instDecidableEqIProp","line":100,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instDecidableEqIProp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instDecidableEqIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instDecidableEqIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L100-L100","name":"Mathlib.Tactic.ITauto.instToExprIProp","line":100,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprIProp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToExprIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/ToExpr.html#Lean.ToExpr\">Lean.ToExpr</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L99-L99","name":"Mathlib.Tactic.ITauto.IProp.imp","line":99,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.imp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.imp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">imp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L98-L98","name":"Mathlib.Tactic.ITauto.IProp.or","line":98,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.or","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.or\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">or</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L97-L97","name":"Mathlib.Tactic.ITauto.IProp.and'","line":97,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.and'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.and'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">and'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L96-L96","name":"Mathlib.Tactic.ITauto.IProp.false","line":96,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.false","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.false\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">false</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L95-L95","name":"Mathlib.Tactic.ITauto.IProp.true","line":95,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.true","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.true\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">true</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L94-L94","name":"Mathlib.Tactic.ITauto.IProp.var","line":94,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.var","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.var\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">var</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L92-L100","name":"Mathlib.Tactic.ITauto.IProp","line":92,"kind":"inductive","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp","doc":"A reified inductive type for propositional logic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L90-L90","name":"Mathlib.Tactic.ITauto.instInhabitedAndKind","line":90,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedAndKind","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedAndKind\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instInhabitedAndKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L88-L88","name":"Mathlib.Tactic.ITauto.instDecidableEqAndKind","line":88,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instDecidableEqAndKind","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instDecidableEqAndKind\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instDecidableEqAndKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L88-L88","name":"Mathlib.Tactic.ITauto.instToExprAndKind","line":88,"kind":"instance","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprAndKind","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprAndKind\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToExprAndKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/ToExpr.html#Lean.ToExpr\">Lean.ToExpr</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L87-L87","name":"Mathlib.Tactic.ITauto.AndKind.eq","line":87,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span>.<span class=\"name\">eq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L87-L87","name":"Mathlib.Tactic.ITauto.AndKind.iff","line":87,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.iff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span>.<span class=\"name\">iff</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L87-L87","name":"Mathlib.Tactic.ITauto.AndKind.and","line":87,"kind":"ctor","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.and","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.and\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span>.<span class=\"name\">and</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ITauto.lean#L85-L88","name":"Mathlib.Tactic.ITauto.AndKind","line":85,"kind":"inductive","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind","doc":"Different propositional constructors that are variants of \"and\" for the purposes of the\ntheorem prover. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}