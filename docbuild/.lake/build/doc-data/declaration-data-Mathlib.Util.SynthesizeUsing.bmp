{"name":"Mathlib.Util.SynthesizeUsing","instances":[],"imports":["Init","Mathlib.Init","Lean.Elab.Tactic.Basic","Qq"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Util/SynthesizeUsing.lean#L62-L90","name":"synthesizeUsingTactic'","line":62,"kind":"def","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsingTactic'","doc":"`synthesizeUsing' type tacticSyntax` synthesizes an element of type `type` by evaluating the\ngiven tactic syntax.\n\nExample:\n```lean\nlet e ← synthesizeUsingTactic' ty (← `(tactic| norm_num))\n```\n\nThe tactic must solve for all goals, in contrast to `synthesizeUsingTactic`.\n\nIf you need to insert expressions into a tactic proof, then you might use `synthesizeUsing'`\ndirectly, since the `TacticM` monad has access to the `TermElabM` monad. For example, here\nis a term elaborator that wraps the `simp at ...` tactic:\n```\ndef simpTerm (e : Expr) : MetaM Expr := do\n  let mvar ← Meta.mkFreshTypeMVar\n  let e' ← synthesizeUsing' mvar\n    (do evalTactic (← `(tactic| have h := $(← Term.exprToSyntax e); simp at h; exact h)))\n  -- Note: `simp` does not always insert type hints, so to ensure that we get a term\n  -- with the simplified type (as opposed to one that is merely defeq), we should add\n  -- a type hint ourselves.\n  Meta.mkExpectedTypeHint e' mvar\n\nelab \"simpTerm% \" t:term : term => do simpTerm (← Term.elabTerm t none)\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsingTactic'\"><span class=\"name\">synthesizeUsingTactic'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Util/SynthesizeUsing.lean#L46-L60","name":"synthesizeUsingTactic","line":46,"kind":"def","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsingTactic","doc":"`synthesizeUsing type tacticSyntax` synthesizes an element of type `type` by evaluating the\ngiven tactic syntax.\n\nExample:\n```lean\nlet (gs, e) ← synthesizeUsingTactic ty (← `(tactic| congr!))\n```\n\nThe tactic `tac` is allowed to leave goals open, and these remain as metavariables in the\nreturned expression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsingTactic\"><span class=\"name\">synthesizeUsingTactic</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Util/SynthesizeUsing.lean#L33-L44","name":"synthesizeUsing'","line":33,"kind":"def","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsing'","doc":"`synthesizeUsing type tac` synthesizes an element of type `type` using tactic `tac`.\n\nThe tactic must solve for all goals, in contrast to `synthesizeUsing`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsing'\"><span class=\"name\">synthesizeUsing'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Util/SynthesizeUsing.lean#L18-L31","name":"synthesizeUsing","line":18,"kind":"def","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsing","doc":"`synthesizeUsing type tac` synthesizes an element of type `type` using tactic `tac`.\n\nThe tactic `tac` is allowed to leave goals open, and these remain as metavariables in the\nreturned expression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsing\"><span class=\"name\">synthesizeUsing</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span>)</span></div></div>"}]}