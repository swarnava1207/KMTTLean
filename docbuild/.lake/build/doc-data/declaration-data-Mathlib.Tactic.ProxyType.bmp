{"name":"Mathlib.Tactic.ProxyType","instances":[],"imports":["Init","Mathlib.Tactic.Core","Mathlib.Logic.Equiv.Defs"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L287-L296","name":"Mathlib.ProxyType.elab_proxy_equiv","line":287,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elab_proxy_equiv","doc":"Elaborator for `proxy_equiv%`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elab_proxy_equiv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">elab_proxy_equiv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElab\">Lean.Elab.Term.TermElab</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L260-L285","name":"Mathlib.ProxyType.proxy_equiv","line":260,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.proxy_equiv","doc":"The term elaborator `proxy_equiv% α` for a type `α` elaborates to an equivalence `β ≃ α`\nfor a \"proxy type\" `β` composed out of basic type constructors `Unit`, `PLift`, `Sigma`,\n`Empty`, and `Sum`.\n\nThis only works for inductive types `α` that are neither recursive nor have indices.\nIf `α` is an inductive type with name `I`, then as a side effect this elaborator defines\n`I.proxyType` and `I.proxyTypeEquiv`.\n\nThe elaborator makes use of the expected type, so `(proxy_equiv% _ : _ ≃ α)` works.\n\nFor example, given this inductive type\n```\ninductive foo (n : Nat) (α : Type)\n  | a\n  | b : Bool → foo n α\n  | c (x : Fin n) : Fin x → foo n α\n  | d : Bool → α → foo n α\n```\nthe proxy type it generates is `Unit ⊕ Bool ⊕ (x : Fin n) × Fin x ⊕ (_ : Bool) × α` and\nin particular we have that\n```\nproxy_equiv% (foo n α) : Unit ⊕ Bool ⊕ (x : Fin n) × Fin x ⊕ (_ : Bool) × α ≃ foo n α\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.proxy_equiv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">proxy_equiv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L242-L258","name":"Mathlib.ProxyType.elabProxyEquiv","line":242,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elabProxyEquiv","doc":"Helper function for `proxy_equiv% type : expectedType` elaborators.\n\nElaborate `type` and get its `InductiveVal`. Uses the `expectedType`, where the\nexpected type should be of the form `_ ≃ type`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elabProxyEquiv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">elabProxyEquiv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L145-L240","name":"Mathlib.ProxyType.ensureProxyEquiv","line":145,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ensureProxyEquiv","doc":"Generates a proxy type for the inductive type and an equivalence from the proxy type to the type.\n\nIf the declarations already exist, there is a check that they are correct.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ensureProxyEquiv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ensureProxyEquiv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L137-L143","name":"Mathlib.ProxyType.ProxyEquivConfig.default","line":137,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.default","doc":"Default configuration. Defines `proxyType` and `proxyTypeEquiv` in the namespace\nof the inductive type. Uses `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L126-L135","name":"Mathlib.ProxyType.defaultMkProxyType.wrapSumAccess","line":126,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType.wrapSumAccess","doc":"Navigates into the sum type that we create in `mkCType` for the given constructor index. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType.wrapSumAccess\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">defaultMkProxyType</span>.<span class=\"name\">wrapSumAccess</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cidx </span><span class=\"fn\">nctors</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">spatt</span> : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L117-L124","name":"Mathlib.ProxyType.defaultMkProxyType.mkCType","line":117,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType.mkCType","doc":"Construct the `Sum` expression, using `decorateSum` to adjust each `Sum`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType.mkCType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">defaultMkProxyType</span>.<span class=\"name\">mkCType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decorateSum</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span> := <a href=\"./Init/Prelude.html#Pure.pure\">pure</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctypes</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`tactic</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L100-L135","name":"Mathlib.ProxyType.defaultMkProxyType","line":100,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType","doc":"Create a `Sum` of types, mildly optimized to not have a trailing `Empty`.\n\nThe `decorateSum` function is to wrap the `Sum` with a function such as `Lex`.\nIt should yield a definitionally equal type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">defaultMkProxyType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctors</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decorateSum</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span> := <a href=\"./Init/Prelude.html#Pure.pure\">pure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`tactic</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L64-L98","name":"Mathlib.ProxyType.defaultMkCtorProxyType","line":64,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkCtorProxyType","doc":"Returns a proxy type for a constructor and a pattern to use to match against it.\n\nInput: a list of pairs associated to each argument of the constructor consisting\nof (1) an fvar for this argument and (2) a name to use for this argument in patterns.\n\nFor example, given `#[(a, x), (b, y)]` with `x : Nat` and `y : Fin x`, then this function\nreturns `Sigma (fun x => Fin x)` and `⟨a, b⟩`.\n\nAlways returns a `Type*`. Uses `Unit`, `PLift`, and `Sigma`. Avoids using `PSigma` since\nthe `Fintype` instances for it go through `Sigma`s anyway.\n\nThe `decorateSigma` function is to wrap the `Sigma` a decorator such as `Lex`.\nIt should yield a definitionally equal type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkCtorProxyType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">defaultMkCtorProxyType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decorateSigma</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span> := <a href=\"./Init/Prelude.html#Pure.pure\">pure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L62-L62","name":"Mathlib.ProxyType.ProxyEquivConfig.mkProxyType","line":62,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkProxyType","doc":"Given (constructor name, proxy constructor type, proxy constructor pattern) triples\nconstructed using `mkCtorProxyType`, return (1) the total proxy type (a `Type*`),\n(2) patterns to use for each constructor, and (3) a proof to use to prove `left_inv` for\n`proxy_type ≃ type` (this proof starts with `intro x`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkProxyType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">mkProxyType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`tactic</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L57-L57","name":"Mathlib.ProxyType.ProxyEquivConfig.mkCtorProxyType","line":57,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkCtorProxyType","doc":"Returns a proxy type for a constructor and a pattern to use to match against it,\ngiven a list of fvars for the constructor arguments and pattern names to use for the arguments.\nThe proxy type is expected to be a `Type*`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkCtorProxyType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">mkCtorProxyType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L53-L53","name":"Mathlib.ProxyType.ProxyEquivConfig.proxyEquivName","line":53,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.proxyEquivName","doc":"Name to use for the declaration for the equivalence `proxyType ≃ type`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.proxyEquivName\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">proxyEquivName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L51-L51","name":"Mathlib.ProxyType.ProxyEquivConfig.proxyName","line":51,"kind":"def","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.proxyName","doc":"Name to use for the declaration for a type that is `Equiv` to the given type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.proxyName\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">proxyName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L49-L49","name":"Mathlib.ProxyType.ProxyEquivConfig.mk","line":49,"kind":"ctor","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proxyName </span><span class=\"fn\">proxyEquivName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mkCtorProxyType</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mkProxyType</span> :\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`tactic</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ProxyType.lean#L48-L62","name":"Mathlib.ProxyType.ProxyEquivConfig","line":48,"kind":"structure","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig","doc":"Configuration used by `mkProxyEquiv`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}