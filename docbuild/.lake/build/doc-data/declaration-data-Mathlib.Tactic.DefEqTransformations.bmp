{"name":"Mathlib.Tactic.DefEqTransformations","instances":[],"imports":["Init","Mathlib.Tactic.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L370-L371","name":"Mathlib.Tactic.convEta_struct","line":370,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_struct","doc":"`eta_struct at loc` transforms structure constructor applications such as `S.mk x.1 ... x.n`\n(pretty printed as, for example, `{a := x.a, b := x.b, ...}`) into `x`.\nThis also exists as a `conv`-mode tactic.\n\nThe transformation is known as eta reduction for structures, and it yields definitionally\nequal expressions.\n\nFor example, given `x : α × β`, then `(x.1, x.2)` becomes `x` after this transformation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_struct\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_struct</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L357-L368","name":"Mathlib.Tactic.etaStructStx","line":357,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructStx","doc":"`eta_struct at loc` transforms structure constructor applications such as `S.mk x.1 ... x.n`\n(pretty printed as, for example, `{a := x.a, b := x.b, ...}`) into `x`.\nThis also exists as a `conv`-mode tactic.\n\nThe transformation is known as eta reduction for structures, and it yields definitionally\nequal expressions.\n\nFor example, given `x : α × β`, then `(x.1, x.2)` becomes `x` after this transformation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStructStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L348-L355","name":"Mathlib.Tactic.etaStructAll","line":348,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructAll","doc":"Finds all occurrences of expressions of the form `S.mk x.1 ... x.n` where `S.mk`\nis a structure constructor and replaces them by `x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStructAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L336-L346","name":"Mathlib.Tactic.etaStruct?.findProj","line":336,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?.findProj","doc":"Check to see if there's an argument at some index `i`\nsuch that it's the `i`th projection of a some expression.\nReturns the expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?.findProj\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStruct?</span>.<span class=\"name\">findProj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fVal</span> : <a href=\"./Lean/Declaration.html#Lean.ConstructorVal\">Lean.ConstructorVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Lean/Data/LOption.html#Lean.LOption\">Lean.LOption</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L309-L346","name":"Mathlib.Tactic.etaStruct?","line":309,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?","doc":"Checks if the expression is of the form `S.mk x.1 ... x.n` with `n` nonzero\nand `S.mk` a structure constructor and returns `x`.\nEach projection `x.i` can be either a native projection or from a projection function.\n\n`tryWhnfR` controls whether to try applying `whnfR` to arguments when none of them\nare obviously projections.\n\nOnce an obviously correct projection is found, relies on the structure eta rule in `isDefEq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStruct?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tryWhnfR</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L296-L307","name":"Mathlib.Tactic.getProjectedExpr","line":296,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.getProjectedExpr","doc":"Given an expression that's either a native projection or a registered projection\nfunction, gives (1) the name of the structure type, (2) the index of the projection, and\n(3) the object being projected. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.getProjectedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getProjectedExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>))</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L290-L291","name":"Mathlib.Tactic.convEta_expand","line":290,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_expand","doc":"`eta_expand at loc` eta expands all sub-expressions at the given location.\nIt also beta reduces any applications of eta expanded terms, so it puts it\ninto an eta-expanded \"normal form.\"\nThis also exists as a `conv`-mode tactic.\n\nFor example, if `f` takes two arguments, then `f` becomes `fun x y => f x y`\nand `f x` becomes `fun y => f x y`.\n\nThis can be useful to turn, for example, a raw `HAdd.hAdd` into `fun x y => x + y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_expand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_expand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L276-L288","name":"Mathlib.Tactic.etaExpandStx","line":276,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandStx","doc":"`eta_expand at loc` eta expands all sub-expressions at the given location.\nIt also beta reduces any applications of eta expanded terms, so it puts it\ninto an eta-expanded \"normal form.\"\nThis also exists as a `conv`-mode tactic.\n\nFor example, if `f` takes two arguments, then `f` becomes `fun x y => f x y`\nand `f x` becomes `fun y => f x y`.\n\nThis can be useful to turn, for example, a raw `HAdd.hAdd` into `fun x y => x + y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaExpandStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L254-L274","name":"Mathlib.Tactic.etaExpandAll","line":254,"kind":"opaque","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandAll","doc":"Eta expand every sub-expression in the given expression.\n\nAs a side-effect, beta reduces any pre-existing instances of eta expanded terms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaExpandAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L248-L249","name":"Mathlib.Tactic.convEta_reduce","line":248,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_reduce","doc":"`eta_reduce at loc` eta reduces all sub-expressions at the given location.\nThis also exists as a `conv`-mode tactic.\n\nFor example, `fun x y => f x y` becomes `f` after eta reduction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_reduce\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_reduce</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L239-L246","name":"Mathlib.Tactic.etaReduceStx","line":239,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceStx","doc":"`eta_reduce at loc` eta reduces all sub-expressions at the given location.\nThis also exists as a `conv`-mode tactic.\n\nFor example, `fun x y => f x y` becomes `f` after eta reduction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaReduceStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L232-L237","name":"Mathlib.Tactic.etaReduceAll","line":232,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceAll","doc":"Eta reduce everything "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaReduceAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L226-L227","name":"Mathlib.Tactic.convUnfold_projs","line":226,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_projs","doc":"`unfold_projs at loc` unfolds projections of class instances at the given location.\nThis also exists as a `conv`-mode tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_projs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convUnfold_projs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L219-L224","name":"Mathlib.Tactic.unfoldProjsStx","line":219,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjsStx","doc":"`unfold_projs at loc` unfolds projections of class instances at the given location.\nThis also exists as a `conv`-mode tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjsStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldProjsStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L211-L217","name":"Mathlib.Tactic.unfoldProjs","line":211,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjs","doc":"Recursively unfold all the projection applications for class instances. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldProjs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L201-L202","name":"Mathlib.Tactic.convRefold_let___","line":201,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convRefold_let___","doc":"`refold_let x y z at loc` looks for the bodies of local definitions `x`, `y`, and `z` at the given\nlocation and replaces them with `x`, `y`, or `z`. This is the inverse of \"zeta reduction.\"\nThis also exists as a `conv`-mode tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convRefold_let___\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convRefold_let___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L188-L194","name":"Mathlib.Tactic.refoldLetStx","line":188,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldLetStx","doc":"`refold_let x y z at loc` looks for the bodies of local definitions `x`, `y`, and `z` at the given\nlocation and replaces them with `x`, `y`, or `z`. This is the inverse of \"zeta reduction.\"\nThis also exists as a `conv`-mode tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldLetStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">refoldLetStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L170-L186","name":"Mathlib.Tactic.refoldFVars","line":170,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldFVars","doc":"For each fvar, looks for its body in `e` and replaces it with the fvar. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldFVars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">refoldFVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">loc?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L156-L157","name":"Mathlib.Tactic.convUnfold_let___","line":156,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_let___","doc":"This tactic is subsumed by the `unfold` tactic.\n\n`unfold_let x y z at loc` unfolds the local definitions `x`, `y`, and `z` at the given\nlocation, which is known as \"zeta reduction.\"\nThis also exists as a `conv`-mode tactic.\n\nIf no local definitions are given, then all local definitions are unfolded.\nThis variant also exists as the `conv`-mode tactic `zeta`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_let___\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convUnfold_let___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L133-L145","name":"Mathlib.Tactic.unfoldLetStx","line":133,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldLetStx","doc":"This tactic is subsumed by the `unfold` tactic.\n\n`unfold_let x y z at loc` unfolds the local definitions `x`, `y`, and `z` at the given\nlocation, which is known as \"zeta reduction.\"\nThis also exists as a `conv`-mode tactic.\n\nIf no local definitions are given, then all local definitions are unfolded.\nThis variant also exists as the `conv`-mode tactic `zeta`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldLetStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldLetStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L119-L131","name":"Mathlib.Tactic.unfoldFVars","line":119,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldFVars","doc":"Unfold all the fvars from `fvars` in `e` that have local definitions (are \"let-bound\"). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldFVars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldFVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L107-L114","name":"Mathlib.Tactic.tacticReduce__","line":107,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticReduce__","doc":"`reduce at loc` completely reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis does the same transformation as the `#reduce` command.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticReduce__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticReduce__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L101-L102","name":"Mathlib.Tactic.convBeta_reduce","line":101,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convBeta_reduce","doc":"`beta_reduce at loc` completely beta reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis means that whenever there is an applied lambda expression such as\n`(fun x => f x) y` then the argument is substituted into the lambda expression\nyielding an expression such as `f y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convBeta_reduce\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convBeta_reduce</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L90-L99","name":"Mathlib.Tactic.betaReduceStx","line":90,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.betaReduceStx","doc":"`beta_reduce at loc` completely beta reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis means that whenever there is an applied lambda expression such as\n`(fun x => f x) y` then the argument is substituted into the lambda expression\nyielding an expression such as `f y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.betaReduceStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">betaReduceStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L77-L85","name":"Mathlib.Tactic.tacticWhnf__","line":77,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticWhnf__","doc":"`whnf at loc` puts the given location into weak-head normal form.\nThis also exists as a `conv`-mode tactic.\n\nWeak-head normal form is when the outer-most expression has been fully reduced, the expression\nmay contain subexpressions which have not been reduced.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticWhnf__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticWhnf__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L70-L72","name":"Mathlib.Tactic.runDefEqConvTactic","line":70,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqConvTactic","doc":"Like `Mathlib.Tactic.runDefEqTactic` but for `conv` mode. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqConvTactic\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">runDefEqConvTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L45-L68","name":"Mathlib.Tactic.runDefEqTactic","line":45,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqTactic","doc":"For the main goal, use `m` to transform the types of locations specified by `loc?`.\nIf `loc?` is none, then transforms the type of target. `m` is provided with an expression\nwith instantiated metavariables as well as, if the location is a local hypothesis, the fvar.\n\n`m` *must* transform expressions to defeq expressions.\nIf `checkDefEq = true` (the default) then `runDefEqTactic` will throw an error\nif the resulting expression is not definitionally equal to the original expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqTactic\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">runDefEqTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">loc?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.location</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tacticName</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkDefEq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/DefEqTransformations.lean#L20-L43","name":"Lean.MVarId.changeLocalDecl'","line":20,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Lean.MVarId.changeLocalDecl'","doc":"This is `Lean.MVarId.changeLocalDecl` but makes sure to preserve local variable order.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Lean.MVarId.changeLocalDecl'\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">changeLocalDecl'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">typeNew</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkDefEq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"}]}