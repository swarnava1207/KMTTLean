{"name":"Mathlib.Tactic.Subsingleton","instances":[],"imports":["Init","Mathlib.Logic.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Subsingleton.lean#L151-L177","name":"Mathlib.Tactic.elabSubsingletonInsts.go","line":151,"kind":"def","docLink":"./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.elabSubsingletonInsts.go","doc":"Main loop for `addSubsingletonInsts`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.elabSubsingletonInsts.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabSubsingletonInsts</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instTerms</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">insts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Lean.Meta.AbstractMVarsResult</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Lean.Meta.AbstractMVarsResult</a>))</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Subsingleton.lean#L139-L177","name":"Mathlib.Tactic.elabSubsingletonInsts","line":139,"kind":"def","docLink":"./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.elabSubsingletonInsts","doc":"Elaborates the terms like how `Lean.Elab.Tactic.addSimpTheorem` does,\nabstracting their metavariables.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.elabSubsingletonInsts\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabSubsingletonInsts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instTerms?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Lean.Meta.AbstractMVarsResult</a>))</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Subsingleton.lean#L105-L135","name":"Mathlib.Tactic.subsingletonStx","line":105,"kind":"def","docLink":"./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.subsingletonStx","doc":"The `subsingleton` tactic tries to prove a goal of the form `x = y` or `HEq x y`\nusing the fact that the types involved are *subsingletons*\n(a type with exactly zero or one terms).\nTo a first approximation, it does `apply Subsingleton.elim`.\nAs a nicety, `subsingleton` first runs the `intros` tactic.\n\n- If the goal is an equality, it either closes the goal or fails.\n- `subsingleton [inst1, inst2, ...]` can be used to add additional `Subsingleton` instances\n  to the local context. This can be more flexible than\n  `have := inst1; have := inst2; ...; subsingleton` since the tactic does not require that\n  all placeholders be solved for.\n\nTechniques the `subsingleton` tactic can apply:\n- proof irrelevance\n- heterogeneous proof irrelevance (via `proof_irrel_heq`)\n- using `Subsingleton` (via `Subsingleton.elim`)\n- proving `BEq` instances are equal if they are both lawful (via `lawful_beq_subsingleton`)\n\n### Properties\n\nThe tactic is careful not to accidentally specialize `Sort _` to `Prop`,\navoiding the following surprising behavior of `apply Subsingleton.elim`:\n```lean\nexample (α : Sort _) (x y : α) : x = y := by apply Subsingleton.elim\n```\nThe reason this `example` goes through is that\nit applies the `∀ (p : Prop), Subsingleton p` instance,\nspecializing the universe level metavariable in `Sort _` to `0`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.subsingletonStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">subsingletonStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Subsingleton.lean#L55-L101","name":"Lean.MVarId.subsingleton","line":55,"kind":"def","docLink":"./Mathlib/Tactic/Subsingleton.html#Lean.MVarId.subsingleton","doc":"Closes the goal `g` whose target is an `Eq` or `HEq` by appealing to the fact that the types\nare subsingletons.\nFails if it cannot find a way to do this.\n\nHas support for showing `BEq` instances are equal if they have `LawfulBEq` instances.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Lean.MVarId.subsingleton\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">subsingleton</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">insts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Meta.AbstractMVarsResult</a>)</span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Subsingleton.lean#L24-L53","name":"Lean.Meta.synthSubsingletonInst","line":24,"kind":"def","docLink":"./Mathlib/Tactic/Subsingleton.html#Lean.Meta.synthSubsingletonInst","doc":"Synthesizes a `Subsingleton ty` instance with the additional local instances made available. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Lean.Meta.synthSubsingletonInst\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">synthSubsingletonInst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">insts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Meta.html#Lean.Syntax.Term\">Term</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">AbstractMVarsResult</a>)</span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Subsingleton.lean#L19-L22","name":"Lean.Meta.mkSubsingleton","line":19,"kind":"def","docLink":"./Mathlib/Tactic/Subsingleton.html#Lean.Meta.mkSubsingleton","doc":"Returns the expression `Subsingleton ty`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Subsingleton.html#Lean.Meta.mkSubsingleton\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkSubsingleton</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>"}]}