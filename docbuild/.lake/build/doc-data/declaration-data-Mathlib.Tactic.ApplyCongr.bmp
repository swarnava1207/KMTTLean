{"name":"Mathlib.Tactic.ApplyCongr","instances":[],"imports":["Init","Mathlib.Tactic.Conv"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ApplyCongr.lean#L84-L84","name":"Lean.Parser.Tactic.applyCongr","line":84,"kind":"def","docLink":"./Mathlib/Tactic/ApplyCongr.html#Lean.Parser.Tactic.applyCongr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ApplyCongr.html#Lean.Parser.Tactic.applyCongr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">applyCongr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ApplyCongr.lean#L20-L82","name":"Lean.Elab.Tactic.applyCongr","line":20,"kind":"def","docLink":"./Mathlib/Tactic/ApplyCongr.html#Lean.Elab.Tactic.applyCongr","doc":"Apply a congruence lemma inside `conv` mode.\n\nWhen called without an argument `apply_congr` will try applying all lemmas marked with `@[congr]`.\nOtherwise `apply_congr e` will apply the lemma `e`.\n\nRecall that a goal that appears as `∣ X` in `conv` mode\nrepresents a goal of `⊢ X = ?m`,\ni.e. an equation with a metavariable for the right hand side.\n\nTo successfully use `apply_congr e`, `e` will need to be an equation\n(possibly after function arguments),\nwhich can be unified with a goal of the form `X = ?m`.\nThe right hand side of `e` will then determine the metavariable,\nand `conv` will subsequently replace `X` with that right hand side.\n\nAs usual, `apply_congr` can create new goals;\nany of these which are _not_ equations with a metavariable on the right hand side\nwill be hard to deal with in `conv` mode.\nThus `apply_congr` automatically calls `intros` on any new goals,\nand fails if they are not then equations.\n\nIn particular it is useful for rewriting inside the operand of a `Finset.sum`,\nas it provides an extra hypothesis asserting we are inside the domain.\n\nFor example:\n\n```lean\nexample (f g : ℤ → ℤ) (S : Finset ℤ) (h : ∀ m ∈ S, f m = g m) :\n    Finset.sum S f = Finset.sum S g := by\n  conv_lhs =>\n    -- If we just call `congr` here, in the second goal we're helpless,\n    -- because we are only given the opportunity to rewrite `f`.\n    -- However `apply_congr` uses the appropriate `@[congr]` lemma,\n    -- so we get to rewrite `f x`, in the presence of the crucial `H : x ∈ S` hypothesis.\n    apply_congr\n    · skip\n    · simp [*]\n```\n\nIn the above example, when the `apply_congr` tactic is called it gives the hypothesis `H : x ∈ S`\nwhich is then used to rewrite the `f x` to `g x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ApplyCongr.html#Lean.Elab.Tactic.applyCongr\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">applyCongr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"}]}