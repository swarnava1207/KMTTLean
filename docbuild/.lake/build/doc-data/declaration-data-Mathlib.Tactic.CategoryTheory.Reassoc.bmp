{"name":"Mathlib.Tactic.CategoryTheory.Reassoc","instances":[],"imports":["Init","Mathlib.CategoryTheory.Functor.Basic","Mathlib.Lean.Meta.Simp","Mathlib.Tactic.Simps.Basic","Mathlib.Util.AddRelatedDecl"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L85-L92","name":"CategoryTheory.«termReassoc_of%_»","line":85,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.«termReassoc_of%_»","doc":"`reassoc_of% t`, where `t` is\nan equation `f = g` between morphisms `X ⟶ Y` in a category (possibly after a `∀` binder),\nproduce the equation `∀ {Z} (h : Y ⟶ Z), f ≫ h = g ≫ h`,\nbut with compositions fully right associated and identities removed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.«termReassoc_of%_»\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">«termReassoc_of%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L52-L70","name":"CategoryTheory.reassoc","line":52,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassoc","doc":"Adding `@[reassoc]` to a lemma named `F` of shape `∀ .., f = g`, where `f g : X ⟶ Y` are\nmorphisms in some category, will create a new lemma named `F_assoc` of shape\n`∀ .. {Z : C} (h : Y ⟶ Z), f ≫ h = g ≫ h`\nbut with the conclusions simplified using the axioms for a category\n(`Category.comp_id`, `Category.id_comp`, and `Category.assoc`).\nSo, for example, if the conclusion of `F` is `a ≫ b = g` then\nthe conclusion of `F_assoc` will be `a ≫ (b ≫ h) = g ≫ h` (note that `≫` reassociates\nto the right so the brackets will not appear in the statement).\n\nThis attribute is useful for generating lemmas which the simplifier can use even on expressions\nthat are already right associated.\n\nNote that if you want both the lemma and the reassociated lemma to be\n`simp` lemmas, you should tag the lemma `@[reassoc (attr := simp)]`.\nThe variant `@[simp, reassoc]` on a lemma `F` will tag `F` with `@[simp]`,\nbut not `F_assoc` (this is sometimes useful).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">reassoc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L44-L50","name":"CategoryTheory.reassocExpr","line":44,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExpr","doc":"Given an equation `f = g` between morphisms `X ⟶ Y` in a category (possibly after a `∀` binder),\nproduce the equation `∀ {Z} (h : Y ⟶ Z), f ≫ h = g ≫ h`,\nbut with compositions fully right associated and identities removed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExpr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">reassocExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L38-L42","name":"CategoryTheory.categorySimp","line":38,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.categorySimp","doc":"Simplify an expression using only the axioms of a category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.categorySimp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">categorySimp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L34-L36","name":"CategoryTheory.eq_whisker'","line":34,"kind":"theorem","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.eq_whisker'","doc":"A variant of `eq_whisker` with a more convenient argument order for use in tactics. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.eq_whisker'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">eq_whisker'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{u_2, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f </span><span class=\"fn\">g</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">w</span> : <span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">Z</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span></div></div>"}]}