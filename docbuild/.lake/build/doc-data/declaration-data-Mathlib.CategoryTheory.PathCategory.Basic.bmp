{"name":"Mathlib.CategoryTheory.PathCategory.Basic","instances":[{"typeNames":["CategoryTheory.Paths"],"name":"CategoryTheory.instInhabitedPaths","className":"Inhabited"},{"typeNames":["CategoryTheory.Paths"],"name":"CategoryTheory.Paths.categoryPaths","className":"CategoryTheory.Category"}],"imports":["Init","Mathlib.CategoryTheory.EqToHom","Mathlib.CategoryTheory.Quotient","Mathlib.Combinatorics.Quiver.Path"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L262-L280","name":"CategoryTheory.quotientPathsEquiv","line":262,"kind":"def","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.quotientPathsEquiv","doc":"The canonical quotient of the path category of a category\nis equivalent to the original category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.quotientPathsEquiv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">quotientPathsEquiv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Quotient.html#CategoryTheory.Quotient\">Quotient</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathsHomRel\">pathsHomRel</a> <span class=\"fn\">C</span>)</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\">C</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L258-L258","name":"CategoryTheory.quotientPathsTo_map","line":258,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.quotientPathsTo_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.quotientPathsTo_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">quotientPathsTo_map</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Quotient.html#CategoryTheory.Quotient\">Quotient</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathsHomRel\">pathsHomRel</a> <span class=\"fn\">C</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hf</span> : <span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.quotientPathsTo\">quotientPathsTo</a> <span class=\"fn\">C</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">hf</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Core.html#Quot.liftOn\">Quot.liftOn</a> <span class=\"fn\">hf</span> <span class=\"fn\">(fun (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">a</span>.<a href=\"./Mathlib/CategoryTheory/Quotient.html#CategoryTheory.Quotient.as\">as</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">b</span>.<a href=\"./Mathlib/CategoryTheory/Quotient.html#CategoryTheory.Quotient.as\">as</a></span>) =&gt; <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">f</span></span>)</span> <span class=\"fn\">⋯</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L258-L258","name":"CategoryTheory.quotientPathsTo_obj","line":258,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.quotientPathsTo_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.quotientPathsTo_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">quotientPathsTo_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Quotient.html#CategoryTheory.Quotient\">Quotient</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathsHomRel\">pathsHomRel</a> <span class=\"fn\">C</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.quotientPathsTo\">quotientPathsTo</a> <span class=\"fn\">C</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">a</span>.<a href=\"./Mathlib/CategoryTheory/Quotient.html#CategoryTheory.Quotient.as\">as</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L256-L260","name":"CategoryTheory.quotientPathsTo","line":256,"kind":"def","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.quotientPathsTo","doc":"The functor from the canonical quotient of a path category of a category\nto the original category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.quotientPathsTo\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">quotientPathsTo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Quotient.html#CategoryTheory.Quotient\">Quotient</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathsHomRel\">pathsHomRel</a> <span class=\"fn\">C</span>)</span>)</span> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L249-L249","name":"CategoryTheory.toQuotientPaths_obj_as","line":249,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.toQuotientPaths_obj_as","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.toQuotientPaths_obj_as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">toQuotientPaths_obj_as</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.toQuotientPaths\">toQuotientPaths</a> <span class=\"fn\">C</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Quotient.html#CategoryTheory.Quotient.as\">as</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">X</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L249-L249","name":"CategoryTheory.toQuotientPaths_map","line":249,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.toQuotientPaths_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.toQuotientPaths_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">toQuotientPaths_map</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X✝ </span><span class=\"fn\">Y✝</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y✝</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.toQuotientPaths\">toQuotientPaths</a> <span class=\"fn\">C</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Quotient.html#CategoryTheory.Quotient.CompClosure\">Quotient.CompClosure</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathsHomRel\">pathsHomRel</a> <span class=\"fn\">C</span>)</span>)</span> <span class=\"fn\"><span class=\"fn\">f</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Hom.toPath\">toPath</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L248-L254","name":"CategoryTheory.toQuotientPaths","line":248,"kind":"def","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.toQuotientPaths","doc":"The functor from a category to the canonical quotient of its path category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.toQuotientPaths\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">toQuotientPaths</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Quotient.html#CategoryTheory.Quotient\">Quotient</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathsHomRel\">pathsHomRel</a> <span class=\"fn\">C</span>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L242-L246","name":"CategoryTheory.pathsHomRel","line":242,"kind":"def","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathsHomRel","doc":"The canonical relation on the path category of a category:\ntwo paths are related if they compose to the same morphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathsHomRel\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">pathsHomRel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Quotient.html#HomRel\">HomRel</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">C</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L233-L233","name":"CategoryTheory.pathComposition_obj","line":233,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathComposition_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathComposition_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">pathComposition_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathComposition\">pathComposition</a> <span class=\"fn\">C</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">X</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L233-L233","name":"CategoryTheory.pathComposition_map","line":233,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathComposition_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathComposition_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">pathComposition_map</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X✝ </span><span class=\"fn\">Y✝</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y✝</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathComposition\">pathComposition</a> <span class=\"fn\">C</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L232-L236","name":"CategoryTheory.pathComposition","line":232,"kind":"def","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathComposition","doc":"Composition of paths as functor from the path category of a category to the category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.pathComposition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">pathComposition</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">C</span>)</span> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L225-L228","name":"CategoryTheory.composePath_comp'","line":225,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_comp'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_comp'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">composePath_comp'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y </span><span class=\"fn\">Z</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">f</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">g</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L221-L223","name":"CategoryTheory.composePath_id","line":221,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">composePath_id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">X</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#id\">id</a> <span class=\"fn\">X</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L214-L219","name":"CategoryTheory.composePath_comp","line":214,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_comp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">composePath_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y </span><span class=\"fn\">Z</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path\">Quiver.Path</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path\">Quiver.Path</a> <span class=\"fn\">Y</span> <span class=\"fn\">Z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.comp\">comp</a></span> <span class=\"fn\">g</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">f</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">g</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L211-L212","name":"CategoryTheory.composePath_toPath","line":211,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_toPath","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_toPath\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">composePath_toPath</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\"><span class=\"fn\">f</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Hom.toPath\">toPath</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L208-L209","name":"CategoryTheory.composePath_cons","line":208,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_cons","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_cons\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">composePath_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y </span><span class=\"fn\">Z</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path\">Quiver.Path</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">p</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons\">cons</a></span> <span class=\"fn\">e</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <span class=\"fn\">p</span>)</span> <span class=\"fn\">e</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L206-L206","name":"CategoryTheory.composePath_nil","line":206,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath_nil\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">composePath_nil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\">composePath</a> <a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.nil\">Quiver.Path.nil</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L201-L204","name":"CategoryTheory.composePath","line":201,"kind":"def","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath","doc":"A path in a category can be composed to a single morphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.composePath\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">composePath</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v₁, u₁}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path\">Quiver.Path</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span> → (<span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L185-L188","name":"CategoryTheory.Prefunctor.mapPath_comp'","line":185,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Prefunctor.mapPath_comp'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Prefunctor.mapPath_comp'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Prefunctor</span>.<span class=\"name\">mapPath_comp'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">W</span> : <a href=\"./foundational_types.html\">Type</a> u₂)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">W</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\">V</span> <a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor\">⥤q</a> <span class=\"fn\">W</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y </span><span class=\"fn\">Z</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Prefunctor.mapPath\">mapPath</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Prefunctor.mapPath\">mapPath</a></span> <span class=\"fn\">f</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.comp\">comp</a></span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Prefunctor.mapPath\">mapPath</a></span> <span class=\"fn\">g</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L164-L178","name":"CategoryTheory.Paths.ext_functor","line":164,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.ext_functor","doc":"Two functors out of a path category are equal when they agree on singleton paths. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.ext_functor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">ext_functor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{u_2, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F </span><span class=\"fn\">G</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h_obj</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">G</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> :\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">V</span>) (<span class=\"fn\">e</span> : <span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>),\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\"><span class=\"fn\">e</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Hom.toPath\">toPath</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">eqToHom</a> <span class=\"fn\">⋯</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">G</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\"><span class=\"fn\">e</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Hom.toPath\">toPath</a></span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">eqToHom</a> <span class=\"fn\">⋯</span>)</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">F</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">G</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L144-L162","name":"CategoryTheory.Paths.lift_unique","line":144,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift_unique","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift_unique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">lift_unique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{u_2, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">φ</span> : <span class=\"fn\">V</span> <a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor\">⥤q</a> <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Φ</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span>)</span> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hΦ</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.comp\">⋙q</a> <span class=\"fn\"><span class=\"fn\">Φ</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.toPrefunctor\">toPrefunctor</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">φ</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Φ</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift\">lift</a> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L135-L142","name":"CategoryTheory.Paths.lift_spec","line":135,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift_spec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift_spec\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">lift_spec</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{u_2, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">φ</span> : <span class=\"fn\">V</span> <a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor\">⥤q</a> <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.comp\">⋙q</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift\">lift</a> <span class=\"fn\">φ</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.toPrefunctor\">toPrefunctor</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">φ</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L129-L133","name":"CategoryTheory.Paths.lift_toPath","line":129,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift_toPath","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift_toPath\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">lift_toPath</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{u_2, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">φ</span> : <span class=\"fn\">V</span> <a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor\">⥤q</a> <span class=\"fn\">C</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">V</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift\">lift</a> <span class=\"fn\">φ</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\"><span class=\"fn\">f</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Hom.toPath\">toPath</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L125-L127","name":"CategoryTheory.Paths.lift_cons","line":125,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift_cons","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift_cons\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">lift_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{u_2, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">φ</span> : <span class=\"fn\">V</span> <a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor\">⥤q</a> <span class=\"fn\">C</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y </span><span class=\"fn\">Z</span> : <span class=\"fn\">V</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path\">Quiver.Path</a> <span class=\"fn\">X</span> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift\">lift</a> <span class=\"fn\">φ</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">p</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons\">cons</a></span> <span class=\"fn\">f</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift\">lift</a> <span class=\"fn\">φ</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">p</span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L121-L123","name":"CategoryTheory.Paths.lift_nil","line":121,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift_nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift_nil\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">lift_nil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{u_2, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">φ</span> : <span class=\"fn\">V</span> <a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor\">⥤q</a> <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\">V</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift\">lift</a> <span class=\"fn\">φ</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.nil\">Quiver.Path.nil</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L103-L119","name":"CategoryTheory.Paths.lift","line":103,"kind":"def","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift","doc":"Any prefunctor from `V` lifts to a functor from `paths V` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.lift\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{u_2, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">φ</span> : <span class=\"fn\">V</span> <a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor\">⥤q</a> <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span>)</span> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L90-L99","name":"CategoryTheory.Paths.induction'","line":90,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.induction'","doc":"To prove a property on morphisms of a path category, it suffices to prove it for the identity\nand prove that the property is preserved under composition on the left with length 1 paths. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.induction'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">induction'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>} → <span class=\"fn\">(<span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>) → <a href=\"./foundational_types.html\">Prop</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">id</span> : <span class=\"fn\">∀ {<span class=\"fn\">v</span> : <span class=\"fn\">V</span>}, <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">v</span>)</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comp</span> : <span class=\"fn\">∀ {<span class=\"fn\">u </span><span class=\"fn\">v </span><span class=\"fn\">w</span> : <span class=\"fn\">V</span>} (<span class=\"fn\">p</span> : <span class=\"fn\">u</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">v</span>) (<span class=\"fn\">q</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">v</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">w</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">q</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">p</span>)</span> <span class=\"fn\">q</span>)</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L81-L88","name":"CategoryTheory.Paths.induction","line":81,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.induction","doc":"To prove a property on morphisms of a path category, it suffices to prove it for the identity\nand prove that the property is preserved under composition on the right with length 1 paths. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.induction\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">induction</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>} → <span class=\"fn\">(<span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>) → <a href=\"./foundational_types.html\">Prop</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">id</span> : <span class=\"fn\">∀ {<span class=\"fn\">v</span> : <span class=\"fn\">V</span>}, <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">v</span>)</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comp</span> : <span class=\"fn\">∀ {<span class=\"fn\">u </span><span class=\"fn\">v </span><span class=\"fn\">w</span> : <span class=\"fn\">V</span>} (<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">u</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">v</span></span>) (<span class=\"fn\">q</span> : <span class=\"fn\">v</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">w</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">p</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">p</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">q</span>)</span>)</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L64-L79","name":"CategoryTheory.Paths.induction_fixed_target","line":64,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.induction_fixed_target","doc":"To prove a property on morphisms of a path category with given target `b`, it suffices to prove\nit for the identity and prove that the property is preserved under composition on the left\nwith length 1 paths. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.induction_fixed_target\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">induction_fixed_target</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>} → <span class=\"fn\">(<span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>) → <a href=\"./foundational_types.html\">Prop</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">id</span> : <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">b</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comp</span> : <span class=\"fn\">∀ {<span class=\"fn\">u </span><span class=\"fn\">v</span> : <span class=\"fn\">V</span>} (<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">v</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>) (<span class=\"fn\">q</span> : <span class=\"fn\">u</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">v</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">p</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">q</span>)</span> <span class=\"fn\">p</span>)</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L52-L62","name":"CategoryTheory.Paths.induction_fixed_source","line":52,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.induction_fixed_source","doc":"To prove a property on morphisms of a path category with given source `a`, it suffices to\nprove it for the identity and prove that the property is preserved under composition on the right\nwith length 1 paths. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.induction_fixed_source\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">induction_fixed_source</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>} → <span class=\"fn\">(<span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>) → <a href=\"./foundational_types.html\">Prop</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">id</span> : <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">a</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comp</span> : <span class=\"fn\">∀ {<span class=\"fn\">u </span><span class=\"fn\">v</span> : <span class=\"fn\">V</span>} (<span class=\"fn\">p</span> : <span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">u</span></span>) (<span class=\"fn\">q</span> : <span class=\"fn\">u</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">v</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">p</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">p</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">q</span>)</span>)</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">a</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L45-L45","name":"CategoryTheory.Paths.of_obj","line":45,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">of_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\">V</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">X</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L45-L45","name":"CategoryTheory.Paths.of_map","line":45,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">of_map</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X✝ </span><span class=\"fn\">Y✝</span> : <span class=\"fn\">V</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y✝</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\">of</a> <span class=\"fn\">V</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Path.html#Quiver.Hom.toPath\">toPath</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L43-L48","name":"CategoryTheory.Paths.of","line":43,"kind":"def","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of","doc":"The inclusion of a quiver `V` into its path category, as a prefunctor.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.of\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">of</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">V</span> <a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor\">⥤q</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L38-L41","name":"CategoryTheory.Paths.categoryPaths","line":38,"kind":"instance","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.categoryPaths","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.categoryPaths\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span>.<span class=\"name\">categoryPaths</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver\">Quiver</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{max u₁ v₁, u₁}</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L32-L32","name":"CategoryTheory.instInhabitedPaths","line":32,"kind":"instance","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.instInhabitedPaths","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.instInhabitedPaths\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">instInhabitedPaths</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">V</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\">Paths</a> <span class=\"fn\">V</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/PathCategory/Basic.lean#L28-L30","name":"CategoryTheory.Paths","line":28,"kind":"def","docLink":"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths","doc":"A type synonym for the category of paths in a quiver.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Paths</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">V</span> : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u₁</div></div>"}]}