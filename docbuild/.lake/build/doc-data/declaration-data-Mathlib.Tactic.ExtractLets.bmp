{"name":"Mathlib.Tactic.ExtractLets","instances":[],"imports":["Init","Mathlib.Lean.Expr.Basic","Mathlib.Tactic.Basic","Batteries.Tactic.Lint.Misc"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ExtractLets.lean#L95-L113","name":"Mathlib.evalExtractLets.doExtract","line":95,"kind":"def","docLink":"./Mathlib/Tactic/ExtractLets.html#Mathlib.evalExtractLets.doExtract","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractLets.html#Mathlib.evalExtractLets.doExtract\"><span class=\"name\">Mathlib</span>.<span class=\"name\">evalExtractLets</span>.<span class=\"name\">doExtract</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ids?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <a href=\"./Init/Prelude.html#List.cons\">[</a><span class=\"fn\">`ident</span><a href=\"./Init/Prelude.html#List.cons\">,</a> <span class=\"fn\">`Lean.Parser.Term.hole</span><a href=\"./Init/Prelude.html#List.cons\">]</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">loc?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.location</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ExtractLets.lean#L88-L93","name":"Mathlib.evalExtractLets.setupNames","line":88,"kind":"def","docLink":"./Mathlib/Tactic/ExtractLets.html#Mathlib.evalExtractLets.setupNames","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractLets.html#Mathlib.evalExtractLets.setupNames\"><span class=\"name\">Mathlib</span>.<span class=\"name\">evalExtractLets</span>.<span class=\"name\">setupNames</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ids?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <a href=\"./Init/Prelude.html#List.cons\">[</a><span class=\"fn\">`ident</span><a href=\"./Init/Prelude.html#List.cons\">,</a> <span class=\"fn\">`Lean.Parser.Term.hole</span><a href=\"./Init/Prelude.html#List.cons\">]</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ExtractLets.lean#L78-L113","name":"Mathlib.evalExtractLets","line":78,"kind":"def","docLink":"./Mathlib/Tactic/ExtractLets.html#Mathlib.evalExtractLets","doc":"The `extract_lets at h` tactic takes a local hypothesis of the form `h : let x := v; b`\nand introduces a new local definition `x := v` while changing `h` to be `h : b`.  It can be thought\nof as being a `cases` tactic for `let` expressions. It can also be thought of as being like\n`intros at h` for `let` expressions.\n\nFor example, if `h : let x := 1; x = x`, then `extract_lets x at h` introduces `x : Nat := 1` and\nchanges `h` to `h : x = x`.\n\nJust like `intros`, the `extract_lets` tactic either takes a list of names, in which case\nthat specifies the number of `let` bindings that must be extracted, or it takes no names, in which\ncase all the `let` bindings are extracted.\n\nThe tactic `extract_lets` (without `at`) or `extract_lets at h ⊢` acts as a weaker\nform of `intros` on the goal that only introduces obvious `let`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractLets.html#Mathlib.evalExtractLets\"><span class=\"name\">Mathlib</span>.<span class=\"name\">evalExtractLets</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ExtractLets.lean#L62-L76","name":"Mathlib.extractLets","line":62,"kind":"def","docLink":"./Mathlib/Tactic/ExtractLets.html#Mathlib.extractLets","doc":"The `extract_lets at h` tactic takes a local hypothesis of the form `h : let x := v; b`\nand introduces a new local definition `x := v` while changing `h` to be `h : b`.  It can be thought\nof as being a `cases` tactic for `let` expressions. It can also be thought of as being like\n`intros at h` for `let` expressions.\n\nFor example, if `h : let x := 1; x = x`, then `extract_lets x at h` introduces `x : Nat := 1` and\nchanges `h` to `h : x = x`.\n\nJust like `intros`, the `extract_lets` tactic either takes a list of names, in which case\nthat specifies the number of `let` bindings that must be extracted, or it takes no names, in which\ncase all the `let` bindings are extracted.\n\nThe tactic `extract_lets` (without `at`) or `extract_lets at h ⊢` acts as a weaker\nform of `intros` on the goal that only introduces obvious `let`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractLets.html#Mathlib.extractLets\"><span class=\"name\">Mathlib</span>.<span class=\"name\">extractLets</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ExtractLets.lean#L50-L58","name":"Lean.MVarId.extractLets","line":50,"kind":"def","docLink":"./Mathlib/Tactic/ExtractLets.html#Lean.MVarId.extractLets","doc":"A more limited version of `Lean.MVarId.introN` that ensures the goal is a\nnested `let` expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractLets.html#Lean.MVarId.extractLets\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">extractLets</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">names</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ExtractLets.lean#L41-L48","name":"Lean.MVarId.extractLetsAt.process","line":41,"kind":"def","docLink":"./Mathlib/Tactic/ExtractLets.html#Lean.MVarId.extractLetsAt.process","doc":"Check that `t` is a `let` and then do what's necessary to lift it over the binding\ndescribed by `mk`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractLets.html#Lean.MVarId.extractLetsAt.process\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">extractLetsAt</span>.<span class=\"name\">process</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mk</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ExtractLets.lean#L20-L48","name":"Lean.MVarId.extractLetsAt","line":20,"kind":"def","docLink":"./Mathlib/Tactic/ExtractLets.html#Lean.MVarId.extractLetsAt","doc":"Given a local hypothesis whose type is a `let` expression, then lift the `let` bindings to be\na new local definition. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ExtractLets.html#Lean.MVarId.extractLetsAt\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">extractLetsAt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">names</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></div></div>"}]}