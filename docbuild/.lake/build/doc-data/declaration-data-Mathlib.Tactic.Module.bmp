{"name":"Mathlib.Tactic.Module","instances":[{"typeNames":["Mathlib.Tactic.Module.NF"],"name":"Mathlib.Tactic.Module.NF.instNeg","className":"Neg"},{"typeNames":["Mathlib.Tactic.Module.NF"],"name":"Mathlib.Tactic.Module.NF.instSMulOfMul","className":"SMul"}],"imports":["Init","Mathlib.Algebra.Algebra.Tower","Mathlib.Algebra.BigOperators.GroupWithZero.Action","Mathlib.Tactic.Ring","Mathlib.Util.AtomM"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L622-L652","name":"Mathlib.Tactic.Module.tacticModule","line":622,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticModule","doc":"Given a goal which is an equality in a type `M` (with `M` an `AddCommMonoid`), parse the LHS and\nRHS of the goal as linear combinations of `M`-atoms over some commutative semiring `R`, and prove\nthe goal by checking that the LHS- and RHS-coefficients of each atom are the same up to\nring-normalization in `R`.\n\n(If the proofs of coefficient-wise equality will require more reasoning than just\nring-normalization, use the tactic `match_scalars` instead, and then prove coefficient-wise equality\nby hand.)\n\nExample uses of the `module` tactic:\n```\nexample [AddCommMonoid M] [CommSemiring R] [Module R M] (a b : R) (x : M) :\n    a • x + b • x = (b + a) • x := by\n  module\n\nexample [AddCommMonoid M] [Field K] [CharZero K] [Module K M] (x : M) :\n    (2:K)⁻¹ • x + (3:K)⁻¹ • x + (6:K)⁻¹ • x = x := by\n  module\n\nexample [AddCommGroup M] [CommRing R] [Module R M] (a : R) (v w : M) :\n    (1 + a ^ 2) • (v + w) - a • (a • v - w) = v + (1 + a + a ^ 2) • w := by\n  module\n\nexample [AddCommGroup M] [CommRing R] [Module R M] (a b μ ν : R) (x y : M) :\n    (μ - ν) • a • x = (a • μ • x + b • ν • y) - ν • (a • x + b • y) := by\n  module\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticModule\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">tacticModule</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L588-L620","name":"Mathlib.Tactic.Module.tacticMatch_scalars","line":588,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticMatch_scalars","doc":"Given a goal which is an equality in a type `M` (with `M` an `AddCommMonoid`), parse the LHS and\nRHS of the goal as linear combinations of `M`-atoms over some semiring `R`, and reduce the goal to\nthe respective equalities of the `R`-coefficients of each atom.\n\nFor example, this produces the goal `⊢ a * 1 + b * 1 = (b + a) * 1`:\n```\nexample [AddCommMonoid M] [Semiring R] [Module R M] (a b : R) (x : M) :\n    a • x + b • x = (b + a) • x := by\n  match_scalars\n```\nThis produces the two goals `⊢ a * (a * 1) + b * (b * 1) = 1` (from the `x` atom) and\n`⊢ a * -(b * 1) + b * (a * 1) = 0` (from the `y` atom):\n```\nexample [AddCommGroup M] [Ring R] [Module R M] (a b : R) (x : M) :\n    a • (a • x - b • y) + (b • a • y + b • b • x) = x := by\n  match_scalars\n```\nThis produces the goal `⊢ -2 * (a * 1) = a * (-2 * 1)`:\n```\nexample [AddCommGroup M] [Ring R] [Module R M] (a : R) (x : M) :\n    -(2:R) • a • x = a • (-2:ℤ) • x  := by\n  match_scalars\n```\nThe scalar type for the goals produced by the `match_scalars` tactic is the largest scalar type\nencountered; for example, if `ℕ`, `ℚ` and a characteristic-zero field `K` all occur as scalars, then\nthe goals produced are equalities in `K`.  A variant of `push_cast` is used internally in\n`match_scalars` to interpret scalars from the other types in this largest type.\n\nIf the set of scalar types encountered is not totally ordered (in the sense that for all rings `R`,\n`S` encountered, it holds that either `Algebra R S` or `Algebra S R`), then the `match_scalars`\ntactic fails.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticMatch_scalars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">tacticMatch_scalars</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L581-L586","name":"Mathlib.Tactic.Module.matchScalars","line":581,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalars","doc":"Given a goal which is an equality in a type `M` (with `M` an `AddCommMonoid`), parse the LHS and\nRHS of the goal as linear combinations of `M`-atoms over some semiring `R`, and reduce the goal to\nthe respective equalities of the `R`-coefficients of each atom. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">matchScalars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L563-L579","name":"Mathlib.Tactic.Module.postprocess","line":563,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.postprocess","doc":"Postprocessing for the scalar goals constructed in the `match_scalars` and `module` tactics.\nThese goals feature a proliferation of `algebraMap` operations (because the scalars start in `ℕ` and\nget successively bumped up by `algebraMap`s as new semirings are encountered), so we reinterpret the\nmost commonly occurring `algebraMap`s (those out of `ℕ`, `ℤ` and `ℚ`) into their standard forms\n(`ℕ`, `ℤ` and `ℚ` casts) and then try to disperse the casts using the various `push_cast` lemmas. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.postprocess\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">postprocess</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L558-L561","name":"Mathlib.Tactic.Module.algebraMapThms","line":558,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.algebraMapThms","doc":"Lemmas used to post-process the result of the `match_scalars` and `module` tactics by converting\nthe `algebraMap` operations which (which proliferate in the constructed scalar goals) to more\nfamiliar forms: `ℕ`, `ℤ` and `ℚ` casts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.algebraMapThms\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">algebraMapThms</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L513-L556","name":"Mathlib.Tactic.Module.matchScalarsAux","line":513,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalarsAux","doc":"Given a goal which is an equality in a type `M` (with `M` an `AddCommMonoid`), parse the LHS and\nRHS of the goal as linear combinations of `M`-atoms over some semiring `R`, and reduce the goal to\nthe respective equalities of the `R`-coefficients of each atom.\n\nThis is an auxiliary function which produces slightly awkward goals in `R`; they are later cleaned\nup by the function `Mathlib.Tactic.Module.postprocess`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalarsAux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">matchScalarsAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L471-L511","name":"Mathlib.Tactic.Module.reduceCoefficientwise","line":471,"kind":"opaque","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.reduceCoefficientwise","doc":"Given expressions `R` and `M` representing types such that `M`'s is a module over `R`'s, and\ngiven two terms `l₁`, `l₂` of type `qNF R M`, i.e. lists of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s\nand a natural number), construct a list of new goals: that the `R`-coefficient of an `M`-atom which\nappears in only one list is zero, and that the `R`-coefficients of an `M`-atom which appears in both\nlists are equal.  Also construct (dependent on these new goals) a proof that the \"linear\ncombinations\" represented by `l₁` and `l₂` are equal in `M`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.reduceCoefficientwise\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">reduceCoefficientwise</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x✝¹</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iRM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a>     <span class=\"fn\">let <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">let <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_2</span></span>)</span></span></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L393-L469","name":"Mathlib.Tactic.Module.parse","line":393,"kind":"opaque","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.parse","doc":"The main algorithm behind the `match_scalars` and `module` tactics: partially-normalizing an\nexpression in an additive commutative monoid `M` into the form c1 • x1 + c2 • x2 + ... c_k • x_k,\nwhere x1, x2, ... are distinct atoms in `M`, and c1, c2, ... are scalars. The scalar type of the\nexpression is not pre-determined: instead it starts as `ℕ` (when each atom is initially given a\nscalar `(1:ℕ)`) and gets bumped up into bigger semirings when such semirings are encountered.\n\nIt is assumed that there is a \"linear order\" on all the semirings which appear in the expression:\nfor any two semirings `R` and `S` which occur, we have either `Algebra R S` or `Algebra S R`).\n\nTODO: implement a variant in which a semiring `R` is provided by the user, and the assumption is\ninstead that for any semiring `S` which occurs, we have `Algebra S R`. The PR https://github.com/leanprover-community/mathlib4/pull/16984 provides a\nproof-of-concept implementation of this variant, but it would need some polishing before joining\nMathlib.\n\nPossible TODO, if poor performance on large problems is witnessed: switch the implementation from\n`AtomM` to `CanonM`, per the discussion\nhttps://github.com/leanprover-community/mathlib4/pull/16593/files#r1749623191 "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.parse\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">parse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a>\n  <span class=\"fn\">((<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>) ×\n    <span class=\"fn\">(<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>) ×\n      <span class=\"fn\">(<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R»</span></span>)</span>) ×\n        <span class=\"fn\">(<span class=\"fn\">x_1</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span>) ×\n          <span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>) ×\n            <span class=\"fn\">let <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n            <span class=\"fn\">Q(<span class=\"fn\">«$x»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_1</span></span>)</span></span></span></span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L346-L385","name":"Mathlib.Tactic.Module.qNF.matchRings","line":346,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.matchRings","doc":"Given an expression `M` representing a type which is an `AddCommMonoid` and a module over *two*\nsemirings `R₁` and `R₂`, find the \"bigger\" of the two semirings.  That is, we assume that it will\nturn out to be the case that either (1) `R₁` is an `R₂`-algebra and the `R₂` scalar action on `M` is\ninduced from `R₁`'s scalar action on `M`, or (2) vice versa; we return the semiring `R₁` in the\nfirst case and `R₂` in the second case.\n\nMoreover, given expressions representing particular scalar multiplications of `R₁` and/or `R₂` on\n`M` (a `List (R₁ × M)`, a `List (R₂ × M)`, a pair `(r, x) : R₂ × M`), bump these up to the \"big\"\nring by applying the algebra-map where needed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.matchRings\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">matchRings</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u₁</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₁</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u₁)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iR₁</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R₁»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iRM₁</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R₁»</span> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u₂</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₂</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u₂)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iR₂</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R₂»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iRM₂</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R₂»</span> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">Q(<span class=\"fn\">«$R₂»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>) ×\n    <span class=\"fn\">(<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>) ×\n      <span class=\"fn\">(<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R»</span></span>)</span>) ×\n        <span class=\"fn\">(<span class=\"fn\">x_1</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span>) ×\n          <span class=\"fn\">((<span class=\"fn\">l₁'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>) ×\n              <span class=\"fn\">let <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n              <span class=\"fn\">let <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n              <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_2</span></span>)</span></span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a>             <span class=\"fn\">((<span class=\"fn\">l₂'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>) ×\n                <span class=\"fn\">let <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n                <span class=\"fn\">let <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n                <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_2</span></span>)</span></span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a>               <span class=\"fn\">(<span class=\"fn\">r'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$R»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\">«$r'»</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">«$x»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$r»</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">«$x»</span>)</span></span></span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L321-L340","name":"Mathlib.Tactic.Module.qNF.mkSubProof","line":321,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkSubProof","doc":"Given two terms `l₁`, `l₂` of type `qNF R M`, i.e. lists of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s\nand a natural number), recursively construct a proof that in the `$R`-module `$M`, the difference\nof the \"linear combinations\" represented by `l₁` and `l₂` is the linear combination represented by\n`Module.qNF.sub iR l₁ l₁`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkSubProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">mkSubProof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$R»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iRM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub\">sub</a> <span class=\"fn\">iR</span> <span class=\"fn\">l₁</span> <span class=\"fn\">l₂</span>)</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">let <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">let <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_1</span></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_2</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_3</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L297-L319","name":"Mathlib.Tactic.Module.qNF.sub","line":297,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub","doc":"Given two terms `l₁`, `l₂` of type `qNF R M`, i.e. lists of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s\nand a natural number), construct another such term `l`, which will have the property that in the\n`$R`-module `$M`, the difference of the \"linear combinations\" represented by `l₁` and `l₂` is the\nlinear combination represented by `l`.\n\nThe construction assumes, to be valid, that the lists `l₁` and `l₂` are in strictly increasing order\nby `ℕ`-component, and that if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with\nthe same `ℕ`-component `k`, then the expressions `x₁` and `x₂` are equal.\n\nThe construction is as follows: merge the first list and the negation of the second list, except\nthat if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with the same\n`ℕ`-component `k`, then contribute a term `(a₁ - a₂, x₁)` to the output list with `ℕ`-component `k`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">sub</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$R»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L276-L295","name":"Mathlib.Tactic.Module.qNF.mkAddProof","line":276,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkAddProof","doc":"Given two terms `l₁`, `l₂` of type `qNF R M`, i.e. lists of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s\nand a natural number), recursively construct a proof that in the `$R`-module `$M`, the sum of the\n\"linear combinations\" represented by `l₁` and `l₂` is the linear combination represented by\n`Module.qNF.add iR l₁ l₁`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkAddProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">mkAddProof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iRM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add\">add</a> <span class=\"fn\">iR</span> <span class=\"fn\">l₁</span> <span class=\"fn\">l₂</span>)</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">let <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">let <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_1</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_2</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">NF.eval</a> <span class=\"fn\">unknown_3</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L253-L274","name":"Mathlib.Tactic.Module.qNF.add","line":253,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add","doc":"Given two terms `l₁`, `l₂` of type `qNF R M`, i.e. lists of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s\nand a natural number), construct another such term `l`, which will have the property that in the\n`$R`-module `$M`, the sum of the \"linear combinations\" represented by `l₁` and `l₂` is the linear\ncombination represented by `l`.\n\nThe construction assumes, to be valid, that the lists `l₁` and `l₂` are in strictly increasing order\nby `ℕ`-component, and that if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with\nthe same `ℕ`-component `k`, then the expressions `x₁` and `x₂` are equal.\n\nThe construction is as follows: merge the two lists, except that if pairs `(a₁, x₁)` and `(a₂, x₂)`\nappear in `l₁`, `l₂` respectively with the same `ℕ`-component `k`, then contribute a term\n`(a₁ + a₂, x₁)` to the output list with `ℕ`-component `k`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iR</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$R»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L246-L251","name":"Mathlib.Tactic.Module.qNF.onScalar","line":246,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.onScalar","doc":"Given `l` of type `qNF R₁ M`, i.e. a list of `(Q($R₁) × Q($M)) × ℕ`s (two `Expr`s and a natural\nnumber), apply an expression representing a function with domain `R₁` to each of the `Q($R₁)`\ncomponents. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.onScalar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">onScalar</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u₁ </span><span class=\"fn\">u₂</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₁</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u₁)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₂</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u₂)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$R₁»</span> → <span class=\"fn\">«$R₂»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L238-L244","name":"Mathlib.Tactic.Module.qNF.toNF","line":238,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF","doc":"Given `l` of type `qNF R M`, i.e. a list of `(Q($R) × Q($M)) × ℕ`s (two `Expr`s and a natural\nnumber), build an `Expr` representing an object of type `NF R M` (i.e. `List (R × M)`) in the\nin the obvious way: by forgetting the natural numbers and gluing together the `Expr`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span>.<span class=\"name\">toNF</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\">qNF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">«$R»</span> <span class=\"fn\">«$M»</span></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L219-L232","name":"Mathlib.Tactic.Module.qNF","line":219,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF","doc":"Basic meta-code \"normal form\" object of the `match_scalars` and `module` tactics: a type synonym\nfor a list of ordered triples comprising expressions representing terms of two types `R` and `M`\n(where typically `M` is an `R`-module), together with a natural number \"index\".\n\nThe natural number represents the index of the `M` term in the `AtomM` monad: this is not enforced,\nbut is sometimes assumed in operations.  Thus when items `((a₁, x₁), k)` and `((a₂, x₂), k)`\nappear in two different `Module.qNF` objects (i.e. with the same `ℕ`-index `k`), it is expected that\nthe expressions `x₁` and `x₂` are the same.  It is also expected that the items in a `Module.qNF`\nlist are in strictly increasing order by natural-number index.\n\nBy forgetting the natural number indices, an expression representing a `Mathlib.Tactic.Module.NF`\nobject can be built from a `Module.qNF` object; this construction is provided as\n`Mathlib.Tactic.Module.qNF.toNF`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">qNF</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L205-L211","name":"Mathlib.Tactic.Module.NF.eval_algebraMap","line":205,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_algebraMap","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_algebraMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eval_algebraMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">S</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Algebra/Defs.html#Algebra\">Algebra</a> <span class=\"fn\">S</span> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Notation/Defs.html#SMul\">SMul</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Action/Defs.html#MulAction\">MulAction</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Action/Defs.html#IsScalarTower\">IsScalarTower</a> <span class=\"fn\">S</span> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap\">algebraMap</a> <span class=\"fn\">R</span> <span class=\"fn\">l</span>)</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L199-L203","name":"Mathlib.Tactic.Module.NF.algebraMap","line":199,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap","doc":"Operate on a `Module.NF S M` object `l`, i.e. a list of pairs in `S × M`, where `S` is some\ncommutative semiring, by applying to each `S`-component the algebra-map from `S` into a specified\n`S`-algebra `R`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">algebraMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">S</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Algebra/Defs.html#Algebra\">Algebra</a> <span class=\"fn\">S</span> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L190-L195","name":"Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval","line":190,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eq_of_eval_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₁</span> : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₂</span> : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₁</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₂</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₂'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x₁ </span><span class=\"fn\">x₂</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₁</span> : <span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₂</span> : <span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x₂</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L184-L188","name":"Mathlib.Tactic.Module.NF.eq_const_cons","line":184,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_const_cons","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_const_cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eq_const_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">r</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">r</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">m</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L178-L182","name":"Mathlib.Tactic.Module.NF.eq_cons_const","line":178,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_const","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_const\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eq_cons_const</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">r</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">m</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L172-L176","name":"Mathlib.Tactic.Module.NF.eq_cons_cons","line":172,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_cons","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eq_cons_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Notation/Defs.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">r₁ </span><span class=\"fn\">r₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <span class=\"fn\">r₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">r₂</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₁</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">m</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">m</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L165-L170","name":"Mathlib.Tactic.Module.NF.smul_eq_eval","line":165,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_eq_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">smul_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₀</span> : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₀</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₀</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">S</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₀</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₀</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">S</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">r</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₀</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hl</span> : <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₀</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hs</span> : <span class=\"fn\">r</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">s</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">s</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">r</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L157-L163","name":"Mathlib.Tactic.Module.NF.eval_smul","line":157,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eval_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">r</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">r</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L154-L155","name":"Mathlib.Tactic.Module.NF.smul_apply","line":154,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_apply\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">smul_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Mul\">Mul</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">r</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Init/Data/List/Basic.html#List.map\">List.map</a>\n    <span class=\"fn\">(fun (<span class=\"fn\">x</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>) =&gt;\n      <span class=\"fn\">match <span class=\"fn\">x</span> with\n      | <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">a</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> =&gt; <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a></span>)</span>\n    <span class=\"fn\">l</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L151-L152","name":"Mathlib.Tactic.Module.NF.instSMulOfMul","line":151,"kind":"instance","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instSMulOfMul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instSMulOfMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">instSMulOfMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Mul\">Mul</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Algebra/Notation/Defs.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L146-L149","name":"Mathlib.Tactic.Module.NF.neg_eq_eval","line":146,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.neg_eq_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.neg_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">neg_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">S</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₀</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">S</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hl</span> : <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₀</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₀</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L142-L144","name":"Mathlib.Tactic.Module.NF.zero_sub_eq_eval","line":142,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_sub_eq_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_sub_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">zero_sub_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L136-L140","name":"Mathlib.Tactic.Module.NF.eval_neg","line":136,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_neg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eval_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L133-L134","name":"Mathlib.Tactic.Module.NF.instNeg","line":133,"kind":"instance","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instNeg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instNeg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">instNeg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Neg\">Neg</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg\">Neg</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L124-L131","name":"Mathlib.Tactic.Module.NF.sub_eq_eval","line":124,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">sub_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₁</span> : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₂</span> : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S₁</span> : <a href=\"./foundational_types.html\">Type</a> u_6}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">S₂</span> : <a href=\"./foundational_types.html\">Type</a> u_7}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₁</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₂</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">S₁</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">S₁</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">S₂</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">S₂</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₂'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁''</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">S₁</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₂''</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">S₂</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x₁ </span><span class=\"fn\">x₂</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₁</span> : <span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁''</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₂</span> : <span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂''</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁'</span> : <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁''</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂'</span> : <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂''</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L117-L122","name":"Mathlib.Tactic.Module.NF.sub_eq_eval₃","line":117,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₃","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₃\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">sub_eq_eval₃</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\"><span class=\"fn\">a₂</span>.1</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\"><span class=\"fn\">a₂</span>.2</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L108-L115","name":"Mathlib.Tactic.Module.NF.sub_eq_eval₂","line":108,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₂","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₂\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">sub_eq_eval₂</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r₁ </span><span class=\"fn\">r₂</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₁</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₁</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">r₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L103-L106","name":"Mathlib.Tactic.Module.NF.sub_eq_eval₁","line":103,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₁","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">sub_eq_eval₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Notation/Defs.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddGroup\">AddGroup</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L96-L101","name":"Mathlib.Tactic.Module.NF.add_eq_eval","line":96,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">add_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₁</span> : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R₂</span> : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₁</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R₂</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₁</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₂'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R₂</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x₁ </span><span class=\"fn\">x₂</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₁</span> : <span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx₂</span> : <span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">x₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L87-L94","name":"Mathlib.Tactic.Module.NF.add_eq_eval₃","line":87,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₃","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₃\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">add_eq_eval₃</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L78-L85","name":"Mathlib.Tactic.Module.NF.add_eq_eval₂","line":78,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₂","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₂\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">add_eq_eval₂</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Module/Defs.html#Module\">Module</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r₁ </span><span class=\"fn\">r₂</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₁</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">r₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L73-L76","name":"Mathlib.Tactic.Module.NF.add_eq_eval₁","line":73,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₁","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">add_eq_eval₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Notation/Defs.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l₁ </span><span class=\"fn\">l₂ </span><span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₁</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">(<span class=\"fn\">a₂</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l₂</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">a₁</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L71-L71","name":"Mathlib.Tactic.Module.NF.zero_eq_eval","line":71,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_eq_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">zero_eq_eval</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a> <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L68-L68","name":"Mathlib.Tactic.Module.NF.atom_eq_eval","line":68,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.atom_eq_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.atom_eq_eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">atom_eq_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">M</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a> <a href=\"./Init/Prelude.html#List.cons\">[</a><a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">1</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a><a href=\"./Init/Prelude.html#List.cons\">]</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L62-L66","name":"Mathlib.Tactic.Module.NF.eval_cons","line":62,"kind":"theorem","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_cons","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eval_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Notation/Defs.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">p</span> <a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\">::ᵣ</a> <span class=\"fn\">l</span>).<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">p</span>.1</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\"><span class=\"fn\">p</span>.2</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\">eval</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L57-L60","name":"Mathlib.Tactic.Module.NF.eval","line":57,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval","doc":"Evaluate a `Module.NF R M` object `l`, i.e. a list of pairs in `R × M`, to an element of `M`, by\nforming the \"linear combination\" it specifies: scalar-multiply each `R` term to the corresponding\n`M` term, then add them all up. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Add\">Add</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Zero\">Zero</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Notation/Defs.html#SMul\">SMul</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">M</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L55-L55","name":"Mathlib.Tactic.Module.NF.«term_::ᵣ_»","line":55,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.«term_::ᵣ_»","doc":"Augment a `Module.NF R M` object `l`, i.e. a list of pairs in `R × M`, by prepending another\npair `p : R × M`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.«term_::ᵣ_»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">«term_::ᵣ_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L50-L53","name":"Mathlib.Tactic.Module.NF.cons","line":50,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons","doc":"Augment a `Module.NF R M` object `l`, i.e. a list of pairs in `R × M`, by prepending another\npair `p : R × M`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span>.<span class=\"name\">cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">R</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">M</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\">NF</a> <span class=\"fn\">R</span> <span class=\"fn\">M</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Module.lean#L39-L45","name":"Mathlib.Tactic.Module.NF","line":39,"kind":"def","docLink":"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF","doc":"Basic theoretical \"normal form\" object of the `match_scalars` and `module` tactics: a type\nsynonym for a list of ordered pairs in `R × M`, where typically `M` is an `R`-module.  This is the\nform to which the tactics reduce module expressions.\n\n(It is not a full \"normal form\" because the scalars, i.e. `R` components, are not themselves\nring-normalized. But this partial normal form is more convenient for our purposes.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Module</span>.<span class=\"name\">NF</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_2)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u_2 u_1)</div></div>"}]}