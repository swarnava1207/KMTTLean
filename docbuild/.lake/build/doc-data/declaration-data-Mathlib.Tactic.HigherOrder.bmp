{"name":"Mathlib.Tactic.HigherOrder","instances":[],"imports":["Init","Lean.Elab.Term","Lean.Meta.Tactic.Apply","Lean.Meta.Tactic.Assumption","Lean.Meta.MatchUtil","Lean.Meta.Tactic.Intro","Lean.Elab.DeclarationRange","Mathlib.Tactic.Attr.Register"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/HigherOrder.lean#L106-L120","name":"Tactic.higherOrderAttr","line":106,"kind":"opaque","docLink":"./Mathlib/Tactic/HigherOrder.html#Tactic.higherOrderAttr","doc":"The `higher_order` attribute. From a lemma of the shape `∀ x, f (g x) = h x` derive an\nauxiliary lemma of the form `f ∘ g = h` for reasoning about higher-order functions.\n\nSyntax: `[higher_order]` or `[higher_order name]` where the given name is used for the\ngenerated theorem. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/HigherOrder.html#Tactic.higherOrderAttr\"><span class=\"name\">Tactic</span>.<span class=\"name\">higherOrderAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Attributes.html#Lean.ParametricAttribute\">Lean.ParametricAttribute</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/HigherOrder.lean#L65-L104","name":"Tactic.higherOrderGetParam","line":65,"kind":"def","docLink":"./Mathlib/Tactic/HigherOrder.html#Tactic.higherOrderGetParam","doc":"A user attribute that applies to lemmas of the shape `∀ x, f (g x) = h x`.\nIt derives an auxiliary lemma of the form `f ∘ g = h` for reasoning about higher-order functions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/HigherOrder.html#Tactic.higherOrderGetParam\"><span class=\"name\">Tactic</span>.<span class=\"name\">higherOrderGetParam</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">thm</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Attributes.html#Lean.AttrM\">Lean.AttrM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/HigherOrder.lean#L48-L63","name":"Tactic.mkHigherOrderType","line":48,"kind":"opaque","docLink":"./Mathlib/Tactic/HigherOrder.html#Tactic.mkHigherOrderType","doc":"From a lemma of the shape `∀ x, f (g x) = h x`\nderive an auxiliary lemma of the form `f ∘ g = h`\nfor reasoning about higher-order functions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/HigherOrder.html#Tactic.mkHigherOrderType\"><span class=\"name\">Tactic</span>.<span class=\"name\">mkHigherOrderType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/HigherOrder.lean#L32-L46","name":"Tactic.mkComp","line":32,"kind":"def","docLink":"./Mathlib/Tactic/HigherOrder.html#Tactic.mkComp","doc":"`mkComp v e` checks whether `e` is a sequence of nested applications `f (g (h v))`, and if so,\nreturns the expression `f ∘ g ∘ h`. If `e = v` it returns `id`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/HigherOrder.html#Tactic.mkComp\"><span class=\"name\">Tactic</span>.<span class=\"name\">mkComp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">v</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/HigherOrder.lean#L26-L26","name":"Lean.Parser.Attr.higherOrder","line":26,"kind":"def","docLink":"./Mathlib/Tactic/HigherOrder.html#Lean.Parser.Attr.higherOrder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/HigherOrder.html#Lean.Parser.Attr.higherOrder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">higherOrder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"}]}