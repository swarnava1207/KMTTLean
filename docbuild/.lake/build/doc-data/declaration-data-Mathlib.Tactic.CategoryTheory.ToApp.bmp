{"name":"Mathlib.Tactic.CategoryTheory.ToApp","instances":[],"imports":["Init","Mathlib.CategoryTheory.Category.Cat","Mathlib.Util.AddRelatedDecl"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/ToApp.lean#L133-L140","name":"CategoryTheory.«termTo_app_of%_»","line":133,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.«termTo_app_of%_»","doc":"Given an equation `t` of the form `η = θ` between 2-morphisms `f ⟶ g` with `f g : C ⟶ D` in the\nbicategory `Cat` (possibly after a `∀` binder), `to_app_of% t` produces the equation\n`∀ (X : C), η.app X = θ.app X` (where `X` is an object in the domain of `f` and `g`), and simplifies\nit suitably using basic lemmas about `NatTrans.app`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.«termTo_app_of%_»\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">«termTo_app_of%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/ToApp.lean#L94-L112","name":"CategoryTheory.to_app","line":94,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.to_app","doc":"Adding `@[to_app]` to a lemma named `F` of shape `∀ .., η = θ`, where `η θ : f ⟶ g` are 2-morphisms\nin some bicategory, create a new lemma named `F_app`. This lemma is obtained by first specializing\nthe bicategory in which the equality is taking place to `Cat`, then applying `NatTrans.congr_app`\nto obtain a proof of `∀ ... (X : Cat), η.app X = θ.app X`, and finally simplifying the conclusion\nusing some basic lemmas in the bicategory `Cat`:\n`Cat.whiskerLeft_app`, `Cat.whiskerRight_app`, `Cat.id_app`, `Cat.comp_app` and `Cat.eqToHom_app`\n\nSo, for example, if the conclusion of `F` is `f ◁ η = θ` then the conclusion of `F_app` will be\n`η.app (f.obj X) = θ.app X`.\n\nThis is useful for automatically generating lemmas that can be applied to expressions of 1-morphisms\nin `Cat` which contain components of 2-morphisms.\n\nNote that if you want both the lemma and the new lemma to be `simp` lemmas, you should tag the lemma\n`@[to_app (attr := simp)]`. The variant `@[simp, to_app]` on a lemma `F` will tag `F` with\n`@[simp]`, but not `F_app` (this is sometimes useful).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.to_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">to_app</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/ToApp.lean#L87-L92","name":"CategoryTheory.toAppExpr","line":87,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.toAppExpr","doc":"Given morphisms `f g : C ⟶ D` in the bicategory `Cat`, and an equation `η = θ` between 2-morphisms\n(possibly after a `∀` binder), produce the equation `∀ (X : C), f.app X = g.app X`, and simplify\nit using basic lemmas about `NatTrans.app`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.toAppExpr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">toAppExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/ToApp.lean#L75-L83","name":"CategoryTheory.toCatExpr.apprec","line":75,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.toCatExpr.apprec","doc":"Recursive function which applies `mkLambdaFVars` stepwise\n(so that each step can have different binderinfos) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.toCatExpr.apprec\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">toCatExpr</span>.<span class=\"name\">apprec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">binderInfos</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.BinderInfo\">Lean.BinderInfo</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">B </span><span class=\"fn\">inst</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/ToApp.lean#L40-L85","name":"CategoryTheory.toCatExpr","line":40,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.toCatExpr","doc":"Given a term of type `∀ ..., η = θ`, where `η θ : f ⟶ g` are 2-morphisms in some bicategory\n`B`, which is bound by the `∀` binder, get the corresponding equation in the bicategory `Cat`.\n\nIt is important here that the levels in the term are level metavariables, as otherwise these will\nnot be reassignable to the corresponding levels of `Cat`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.toCatExpr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">toCatExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/ToApp.lean#L33-L38","name":"CategoryTheory.catAppSimp","line":33,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.catAppSimp","doc":"Simplify an expression in `Cat` using basic properties of `NatTrans.app`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.catAppSimp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">catAppSimp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"}]}