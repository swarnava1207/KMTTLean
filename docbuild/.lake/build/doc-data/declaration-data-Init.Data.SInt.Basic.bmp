{"name":"Init.Data.SInt.Basic","instances":[{"typeNames":["Int8"],"name":"instToStringInt8","className":"ToString"},{"typeNames":["Int8"],"name":"instReprInt8","className":"Repr"},{"typeNames":["Int8"],"name":"instReprAtomInt8","className":"ReprAtom"},{"typeNames":["Int8"],"name":"instHashableInt8","className":"Hashable"},{"typeNames":["Int8"],"name":"Int8.instOfNat","className":"OfNat"},{"typeNames":["Int8"],"name":"Int8.instNeg","className":"Neg"},{"typeNames":["Int8"],"name":"instInhabitedInt8","className":"Inhabited"},{"typeNames":["Int8"],"name":"instAddInt8","className":"Add"},{"typeNames":["Int8"],"name":"instSubInt8","className":"Sub"},{"typeNames":["Int8"],"name":"instMulInt8","className":"Mul"},{"typeNames":["Int8"],"name":"instModInt8","className":"Mod"},{"typeNames":["Int8"],"name":"instDivInt8","className":"Div"},{"typeNames":["Int8"],"name":"instLTInt8","className":"LT"},{"typeNames":["Int8"],"name":"instLEInt8","className":"LE"},{"typeNames":["Int8"],"name":"instComplementInt8","className":"Complement"},{"typeNames":["Int8"],"name":"instAndOpInt8","className":"AndOp"},{"typeNames":["Int8"],"name":"instOrOpInt8","className":"OrOp"},{"typeNames":["Int8"],"name":"instXorInt8","className":"Xor"},{"typeNames":["Int8"],"name":"instShiftLeftInt8","className":"ShiftLeft"},{"typeNames":["Int8"],"name":"instShiftRightInt8","className":"ShiftRight"},{"typeNames":["Eq"],"name":"instDecidableEqInt8","className":"Decidable"},{"typeNames":["LT.lt"],"name":"instDecidableLtInt8","className":"Decidable"},{"typeNames":["LE.le"],"name":"instDecidableLeInt8","className":"Decidable"},{"typeNames":["Int8"],"name":"instMaxInt8","className":"Max"},{"typeNames":["Int8"],"name":"instMinInt8","className":"Min"},{"typeNames":["Int16"],"name":"instToStringInt16","className":"ToString"},{"typeNames":["Int16"],"name":"instReprInt16","className":"Repr"},{"typeNames":["Int16"],"name":"instReprAtomInt16","className":"ReprAtom"},{"typeNames":["Int16"],"name":"instHashableInt16","className":"Hashable"},{"typeNames":["Int16"],"name":"Int16.instOfNat","className":"OfNat"},{"typeNames":["Int16"],"name":"Int16.instNeg","className":"Neg"},{"typeNames":["Int16"],"name":"instInhabitedInt16","className":"Inhabited"},{"typeNames":["Int16"],"name":"instAddInt16","className":"Add"},{"typeNames":["Int16"],"name":"instSubInt16","className":"Sub"},{"typeNames":["Int16"],"name":"instMulInt16","className":"Mul"},{"typeNames":["Int16"],"name":"instModInt16","className":"Mod"},{"typeNames":["Int16"],"name":"instDivInt16","className":"Div"},{"typeNames":["Int16"],"name":"instLTInt16","className":"LT"},{"typeNames":["Int16"],"name":"instLEInt16","className":"LE"},{"typeNames":["Int16"],"name":"instComplementInt16","className":"Complement"},{"typeNames":["Int16"],"name":"instAndOpInt16","className":"AndOp"},{"typeNames":["Int16"],"name":"instOrOpInt16","className":"OrOp"},{"typeNames":["Int16"],"name":"instXorInt16","className":"Xor"},{"typeNames":["Int16"],"name":"instShiftLeftInt16","className":"ShiftLeft"},{"typeNames":["Int16"],"name":"instShiftRightInt16","className":"ShiftRight"},{"typeNames":["Eq"],"name":"instDecidableEqInt16","className":"Decidable"},{"typeNames":["LT.lt"],"name":"instDecidableLtInt16","className":"Decidable"},{"typeNames":["LE.le"],"name":"instDecidableLeInt16","className":"Decidable"},{"typeNames":["Int16"],"name":"instMaxInt16","className":"Max"},{"typeNames":["Int16"],"name":"instMinInt16","className":"Min"},{"typeNames":["Int32"],"name":"instToStringInt32","className":"ToString"},{"typeNames":["Int32"],"name":"instReprInt32","className":"Repr"},{"typeNames":["Int32"],"name":"instReprAtomInt32","className":"ReprAtom"},{"typeNames":["Int32"],"name":"instHashableInt32","className":"Hashable"},{"typeNames":["Int32"],"name":"Int32.instOfNat","className":"OfNat"},{"typeNames":["Int32"],"name":"Int32.instNeg","className":"Neg"},{"typeNames":["Int32"],"name":"instInhabitedInt32","className":"Inhabited"},{"typeNames":["Int32"],"name":"instAddInt32","className":"Add"},{"typeNames":["Int32"],"name":"instSubInt32","className":"Sub"},{"typeNames":["Int32"],"name":"instMulInt32","className":"Mul"},{"typeNames":["Int32"],"name":"instModInt32","className":"Mod"},{"typeNames":["Int32"],"name":"instDivInt32","className":"Div"},{"typeNames":["Int32"],"name":"instLTInt32","className":"LT"},{"typeNames":["Int32"],"name":"instLEInt32","className":"LE"},{"typeNames":["Int32"],"name":"instComplementInt32","className":"Complement"},{"typeNames":["Int32"],"name":"instAndOpInt32","className":"AndOp"},{"typeNames":["Int32"],"name":"instOrOpInt32","className":"OrOp"},{"typeNames":["Int32"],"name":"instXorInt32","className":"Xor"},{"typeNames":["Int32"],"name":"instShiftLeftInt32","className":"ShiftLeft"},{"typeNames":["Int32"],"name":"instShiftRightInt32","className":"ShiftRight"},{"typeNames":["Eq"],"name":"instDecidableEqInt32","className":"Decidable"},{"typeNames":["LT.lt"],"name":"instDecidableLtInt32","className":"Decidable"},{"typeNames":["LE.le"],"name":"instDecidableLeInt32","className":"Decidable"},{"typeNames":["Int32"],"name":"instMaxInt32","className":"Max"},{"typeNames":["Int32"],"name":"instMinInt32","className":"Min"},{"typeNames":["Int64"],"name":"instToStringInt64","className":"ToString"},{"typeNames":["Int64"],"name":"instReprInt64","className":"Repr"},{"typeNames":["Int64"],"name":"instReprAtomInt64","className":"ReprAtom"},{"typeNames":["Int64"],"name":"instHashableInt64","className":"Hashable"},{"typeNames":["Int64"],"name":"Int64.instOfNat","className":"OfNat"},{"typeNames":["Int64"],"name":"Int64.instNeg","className":"Neg"},{"typeNames":["Int64"],"name":"instInhabitedInt64","className":"Inhabited"},{"typeNames":["Int64"],"name":"instAddInt64","className":"Add"},{"typeNames":["Int64"],"name":"instSubInt64","className":"Sub"},{"typeNames":["Int64"],"name":"instMulInt64","className":"Mul"},{"typeNames":["Int64"],"name":"instModInt64","className":"Mod"},{"typeNames":["Int64"],"name":"instDivInt64","className":"Div"},{"typeNames":["Int64"],"name":"instLTInt64","className":"LT"},{"typeNames":["Int64"],"name":"instLEInt64","className":"LE"},{"typeNames":["Int64"],"name":"instComplementInt64","className":"Complement"},{"typeNames":["Int64"],"name":"instAndOpInt64","className":"AndOp"},{"typeNames":["Int64"],"name":"instOrOpInt64","className":"OrOp"},{"typeNames":["Int64"],"name":"instXorInt64","className":"Xor"},{"typeNames":["Int64"],"name":"instShiftLeftInt64","className":"ShiftLeft"},{"typeNames":["Int64"],"name":"instShiftRightInt64","className":"ShiftRight"},{"typeNames":["Eq"],"name":"instDecidableEqInt64","className":"Decidable"},{"typeNames":["LT.lt"],"name":"instDecidableLtInt64","className":"Decidable"},{"typeNames":["LE.le"],"name":"instDecidableLeInt64","className":"Decidable"},{"typeNames":["Int64"],"name":"instMaxInt64","className":"Max"},{"typeNames":["Int64"],"name":"instMinInt64","className":"Min"},{"typeNames":["ISize"],"name":"instToStringISize","className":"ToString"},{"typeNames":["ISize"],"name":"instReprISize","className":"Repr"},{"typeNames":["ISize"],"name":"instReprAtomISize","className":"ReprAtom"},{"typeNames":["ISize"],"name":"instHashableISize","className":"Hashable"},{"typeNames":["ISize"],"name":"ISize.instOfNat","className":"OfNat"},{"typeNames":["ISize"],"name":"ISize.instNeg","className":"Neg"},{"typeNames":["ISize"],"name":"instInhabitedISize","className":"Inhabited"},{"typeNames":["ISize"],"name":"instAddISize","className":"Add"},{"typeNames":["ISize"],"name":"instSubISize","className":"Sub"},{"typeNames":["ISize"],"name":"instMulISize","className":"Mul"},{"typeNames":["ISize"],"name":"instModISize","className":"Mod"},{"typeNames":["ISize"],"name":"instDivISize","className":"Div"},{"typeNames":["ISize"],"name":"instLTISize","className":"LT"},{"typeNames":["ISize"],"name":"instLEISize","className":"LE"},{"typeNames":["ISize"],"name":"instComplementISize","className":"Complement"},{"typeNames":["ISize"],"name":"instAndOpISize","className":"AndOp"},{"typeNames":["ISize"],"name":"instOrOpISize","className":"OrOp"},{"typeNames":["ISize"],"name":"instXorISize","className":"Xor"},{"typeNames":["ISize"],"name":"instShiftLeftISize","className":"ShiftLeft"},{"typeNames":["ISize"],"name":"instShiftRightISize","className":"ShiftRight"},{"typeNames":["Eq"],"name":"instDecidableEqISize","className":"Decidable"},{"typeNames":["LT.lt"],"name":"instDecidableLtISize","className":"Decidable"},{"typeNames":["LE.le"],"name":"instDecidableLeISize","className":"Decidable"},{"typeNames":["ISize"],"name":"instMaxISize","className":"Max"},{"typeNames":["ISize"],"name":"instMinISize","className":"Min"}],"imports":["Init.Data.UInt.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1930-L1930","name":"instMinISize","line":1930,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMinISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMinISize\"><span class=\"name\">instMinISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1929-L1929","name":"instMaxISize","line":1929,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMaxISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMaxISize\"><span class=\"name\">instMaxISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1928-L1928","name":"instDecidableLeISize","line":1928,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableLeISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableLeISize\"><span class=\"name\">instDecidableLeISize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1927-L1927","name":"instDecidableLtISize","line":1927,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableLtISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableLtISize\"><span class=\"name\">instDecidableLtISize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1911-L1925","name":"ISize.decLe","line":1911,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.decLe","doc":"Decides whether one word-sized signed integer is less than or equal to another. Usually accessed via\nthe `DecidableLE ISize` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `(if ((-7) : ISize) ≤ 7 then \"yes\" else \"no\") = \"yes\"`\n * `(if (15 : ISize) ≤ 15 then \"yes\" else \"no\") = \"yes\"`\n * `(if (15 : ISize) ≤ 5 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : ISize) ≤ 7 by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.decLe\"><span class=\"name\">ISize</span>.<span class=\"name\">decLe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1896-L1909","name":"ISize.decLt","line":1896,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.decLt","doc":"Decides whether one word-sized signed integer is strictly less than another. Usually accessed via the\n`DecidableLT ISize` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `(if ((-7) : ISize) < 7 then \"yes\" else \"no\") = \"yes\"`\n * `(if (5 : ISize) < 5 then \"yes\" else \"no\") = \"no\"`\n * `show ¬((7 : ISize) < 7) by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.decLt\"><span class=\"name\">ISize</span>.<span class=\"name\">decLt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1890-L1894","name":"Bool.toISize","line":1890,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Bool.toISize","doc":"Converts `true` to `1` and `false` to `0`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Bool.toISize\"><span class=\"name\">Bool</span>.<span class=\"name\">toISize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1888-L1888","name":"instDecidableEqISize","line":1888,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableEqISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableEqISize\"><span class=\"name\">instDecidableEqISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1887-L1887","name":"instShiftRightISize","line":1887,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instShiftRightISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instShiftRightISize\"><span class=\"name\">instShiftRightISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ShiftRight\">ShiftRight</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1886-L1886","name":"instShiftLeftISize","line":1886,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instShiftLeftISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instShiftLeftISize\"><span class=\"name\">instShiftLeftISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ShiftLeft\">ShiftLeft</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1885-L1885","name":"instXorISize","line":1885,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instXorISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instXorISize\"><span class=\"name\">instXorISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Xor\">Xor</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1884-L1884","name":"instOrOpISize","line":1884,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instOrOpISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instOrOpISize\"><span class=\"name\">instOrOpISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#OrOp\">OrOp</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1883-L1883","name":"instAndOpISize","line":1883,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instAndOpISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instAndOpISize\"><span class=\"name\">instAndOpISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#AndOp\">AndOp</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1882-L1882","name":"instComplementISize","line":1882,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instComplementISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instComplementISize\"><span class=\"name\">instComplementISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Complement\">Complement</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1881-L1881","name":"instLEISize","line":1881,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instLEISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instLEISize\"><span class=\"name\">instLEISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1880-L1880","name":"instLTISize","line":1880,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instLTISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instLTISize\"><span class=\"name\">instLTISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1879-L1879","name":"instDivISize","line":1879,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDivISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDivISize\"><span class=\"name\">instDivISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Div\">Div</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1878-L1878","name":"instModISize","line":1878,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instModISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instModISize\"><span class=\"name\">instModISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mod\">Mod</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1877-L1877","name":"instMulISize","line":1877,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMulISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMulISize\"><span class=\"name\">instMulISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mul\">Mul</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1876-L1876","name":"instSubISize","line":1876,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instSubISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instSubISize\"><span class=\"name\">instSubISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Sub\">Sub</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1875-L1875","name":"instAddISize","line":1875,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instAddISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instAddISize\"><span class=\"name\">instAddISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Add\">Add</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1872-L1873","name":"instInhabitedISize","line":1872,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instInhabitedISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instInhabitedISize\"><span class=\"name\">instInhabitedISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1866-L1870","name":"ISize.le","line":1866,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.le","doc":"Non-strict inequality of word-sized signed integers, defined as inequality of the corresponding\nintegers. Usually accessed via the `≤` operator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.le\"><span class=\"name\">ISize</span>.<span class=\"name\">le</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1861-L1865","name":"ISize.lt","line":1861,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.lt","doc":"Strict inequality of word-sized signed integers, defined as inequality of the corresponding\nintegers. Usually accessed via the `<` operator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.lt\"><span class=\"name\">ISize</span>.<span class=\"name\">lt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1841-L1859","name":"ISize.decEq","line":1841,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.decEq","doc":"Decides whether two word-sized signed integers are equal. Usually accessed via the\n`DecidableEq ISize` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `ISize.decEq 123 123 = .isTrue rfl`\n * `(if ((-7) : ISize) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : ISize) = 7 by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.decEq\"><span class=\"name\">ISize</span>.<span class=\"name\">decEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1830-L1839","name":"ISize.abs","line":1830,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.abs","doc":"Computes the absolute value of a word-sized signed integer.\n\nThis function is equivalent to `if a < 0 then -a else a`, so in particular `ISize.minValue` will be\nmapped to `ISize.minValue`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.abs\"><span class=\"name\">ISize</span>.<span class=\"name\">abs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1818-L1828","name":"ISize.complement","line":1818,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.complement","doc":"Bitwise complement, also known as bitwise negation, for word-sized signed integers. Usually accessed\nvia the `~~~` prefix operator.\n\nEach bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so `ISize.complement a = -(a + 1)`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.complement\"><span class=\"name\">ISize</span>.<span class=\"name\">complement</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1808-L1817","name":"ISize.shiftRight","line":1808,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.shiftRight","doc":"Arithmetic right shift for word-sized signed integers. Usually accessed via the `<<<` operator.\n\nThe high bits are filled with the value of\nthe most significant bit.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.shiftRight\"><span class=\"name\">ISize</span>.<span class=\"name\">shiftRight</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1799-L1807","name":"ISize.shiftLeft","line":1799,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.shiftLeft","doc":"Bitwise left shift for word-sized signed integers. Usually accessed via the `<<<` operator.\n\nSigned integers are interpreted as bitvectors according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.shiftLeft\"><span class=\"name\">ISize</span>.<span class=\"name\">shiftLeft</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1789-L1798","name":"ISize.xor","line":1789,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.xor","doc":"Bitwise exclusive or for word-sized signed integers. Usually accessed via the `^^^` operator.\n\nEach bit of the resulting integer is set if exactly one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.xor\"><span class=\"name\">ISize</span>.<span class=\"name\">xor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1779-L1788","name":"ISize.lor","line":1779,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.lor","doc":"Bitwise or for word-sized signed integers. Usually accessed via the `|||` operator.\n\nEach bit of the resulting integer is set if at least one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.lor\"><span class=\"name\">ISize</span>.<span class=\"name\">lor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1769-L1778","name":"ISize.land","line":1769,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.land","doc":"Bitwise and for word-sized signed integers. Usually accessed via the `&&&` operator.\n\nEach bit of the resulting integer is set if the corresponding bits of both input integers are set,\naccording to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.land\"><span class=\"name\">ISize</span>.<span class=\"name\">land</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1748-L1768","name":"ISize.mod","line":1748,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.mod","doc":"The modulo operator for word-sized signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by `ISize.div`. Usually accessed via the `%`\noperator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `ISize.mod 5 2 = 1`\n* `ISize.mod 5 (-2) = 1`\n* `ISize.mod (-5) 2 = (-1)`\n* `ISize.mod (-5) (-2) = (-1)`\n* `ISize.mod 4 2 = 0`\n* `ISize.mod 4 (-2) = 0`\n* `ISize.mod 4 0 = 4`\n* `ISize.mod (-4) 0 = (-4)`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.mod\"><span class=\"name\">ISize</span>.<span class=\"name\">mod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1731-L1747","name":"ISize.div","line":1731,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.div","doc":"Truncating division for word-sized signed integers, rounding towards zero. Usually accessed via the\n`/` operator.\n\nDivision by zero is defined to be zero.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `ISize.div 10 3 = 3`\n* `ISize.div 10 (-3) = (-3)`\n* `ISize.div (-10) (-3) = 3`\n* `ISize.div (-10) 3 = (-3)`\n* `ISize.div 10 0 = 0`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.div\"><span class=\"name\">ISize</span>.<span class=\"name\">div</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1723-L1730","name":"ISize.mul","line":1723,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.mul","doc":"Multiplies two word-sized signed integers, wrapping around on over- or underflow.  Usually accessed\nvia the `*` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.mul\"><span class=\"name\">ISize</span>.<span class=\"name\">mul</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1715-L1722","name":"ISize.sub","line":1715,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.sub","doc":"Subtracts one word-sized signed integer from another, wrapping around on over- or underflow. Usually\naccessed via the `-` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.sub\"><span class=\"name\">ISize</span>.<span class=\"name\">sub</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1707-L1714","name":"ISize.add","line":1707,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.add","doc":"Adds two word-sized signed integers, wrapping around on over- or underflow.  Usually accessed via\nthe `+` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.add\"><span class=\"name\">ISize</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1697-L1705","name":"ISize.ofIntTruncate","line":1697,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.ofIntTruncate","doc":"Constructs an `ISize` from an `Int`, clamping if the value is too small or too large. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.ofIntTruncate\"><span class=\"name\">ISize</span>.<span class=\"name\">ofIntTruncate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1693-L1696","name":"ISize.ofIntLE","line":1693,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.ofIntLE","doc":"Constructs an `ISize` from an `Int` that is known to be in bounds. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.ofIntLE\"><span class=\"name\">ISize</span>.<span class=\"name\">ofIntLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_hl</span> : <span class=\"fn\"><a href=\"./Init/Data/SInt/Basic.html#ISize.minValue\">minValue</a>.<a href=\"./Init/Data/SInt/Basic.html#ISize.toInt\">toInt</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">i</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_hr</span> : <span class=\"fn\">i</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Init/Data/SInt/Basic.html#ISize.maxValue\">maxValue</a>.<a href=\"./Init/Data/SInt/Basic.html#ISize.toInt\">toInt</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1690-L1691","name":"ISize.minValue","line":1690,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.minValue","doc":"The smallest number that `ISize` can represent: `-2^(System.Platform.numBits - 1)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.minValue\"><span class=\"name\">ISize</span>.<span class=\"name\">minValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1688-L1689","name":"ISize.maxValue","line":1688,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.maxValue","doc":"The largest number that `ISize` can represent: `2^(System.Platform.numBits - 1) - 1`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.maxValue\"><span class=\"name\">ISize</span>.<span class=\"name\">maxValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1685-L1686","name":"ISize.instNeg","line":1685,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#ISize.instNeg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.instNeg\"><span class=\"name\">ISize</span>.<span class=\"name\">instNeg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg\">Neg</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1684-L1684","name":"ISize.instOfNat","line":1684,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#ISize.instOfNat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.instOfNat\"><span class=\"name\">ISize</span>.<span class=\"name\">instOfNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat\">OfNat</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a> <span class=\"fn\">n</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1681-L1682","name":"instHashableISize","line":1681,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instHashableISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instHashableISize\"><span class=\"name\">instHashableISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1679-L1679","name":"instReprAtomISize","line":1679,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instReprAtomISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instReprAtomISize\"><span class=\"name\">instReprAtomISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#ReprAtom\">ReprAtom</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1677-L1678","name":"instReprISize","line":1677,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instReprISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instReprISize\"><span class=\"name\">instReprISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1675-L1676","name":"instToStringISize","line":1675,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instToStringISize","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instToStringISize\"><span class=\"name\">instToStringISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1667-L1673","name":"ISize.neg","line":1667,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.neg","doc":"Negates word-sized signed integers. Usually accessed via the `-` prefix operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.neg\"><span class=\"name\">ISize</span>.<span class=\"name\">neg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1659-L1666","name":"Int64.toISize","line":1659,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.toISize","doc":"Converts 64-bit signed integers to word-sized signed integers, truncating the bitvector\nrepresentation on 32-bit platforms. This conversion is lossless on 64-bit platforms.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.toISize\"><span class=\"name\">Int64</span>.<span class=\"name\">toISize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1651-L1658","name":"Int32.toISize","line":1651,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.toISize","doc":"Converts 32-bit signed integers to word-sized signed integers that denote the same number. This\nconversion is lossless, because `ISize` is either `Int32` or `Int64`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.toISize\"><span class=\"name\">Int32</span>.<span class=\"name\">toISize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1643-L1650","name":"Int16.toISize","line":1643,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.toISize","doc":"Converts 16-bit signed integers to word-sized signed integers that denote the same number. This conversion is lossless, because\n`ISize` is either `Int32` or `Int64`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.toISize\"><span class=\"name\">Int16</span>.<span class=\"name\">toISize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1635-L1642","name":"Int8.toISize","line":1635,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.toISize","doc":"Converts 8-bit signed integers to word-sized signed integers that denote the same number. This\nconversion is lossless, because `ISize` is either `Int32` or `Int64`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.toISize\"><span class=\"name\">Int8</span>.<span class=\"name\">toISize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1627-L1634","name":"ISize.toInt64","line":1627,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.toInt64","doc":"Converts word-sized signed integers to 64-bit signed integers that denote the same number. This\nconversion is lossless, because `ISize` is either `Int32` or `Int64`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.toInt64\"><span class=\"name\">ISize</span>.<span class=\"name\">toInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1616-L1626","name":"ISize.toInt32","line":1616,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.toInt32","doc":"Converts a word-sized signed integer to a 32-bit signed integer.\n\nOn 32-bit platforms, this conversion is lossless. On 64-bit platforms, the integer's bitvector\nrepresentation is truncated to 32 bits. This function is overridden at runtime with an efficient\nimplementation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.toInt32\"><span class=\"name\">ISize</span>.<span class=\"name\">toInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1609-L1615","name":"ISize.toInt16","line":1609,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.toInt16","doc":"Converts a word-sized integer to a 16-bit integer by truncating its bitvector representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.toInt16\"><span class=\"name\">ISize</span>.<span class=\"name\">toInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1602-L1608","name":"ISize.toInt8","line":1602,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.toInt8","doc":"Converts a word-sized signed integer to an 8-bit signed integer by truncating its bitvector representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.toInt8\"><span class=\"name\">ISize</span>.<span class=\"name\">toInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1600-L1601","name":"ISize.ofBitVec","line":1600,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.ofBitVec","doc":"Obtains the `ISize` whose 2's complement representation is the given `BitVec`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.ofBitVec\"><span class=\"name\">ISize</span>.<span class=\"name\">ofBitVec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#BitVec\">BitVec</a> <a href=\"./Init/Prelude.html#System.Platform.numBits\">System.Platform.numBits</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1598-L1599","name":"ISize.toNat","line":1598,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.toNat","doc":"Converts a word-sized signed integer to a natural number, mapping all negative numbers to `0`.\n\nUse `ISize.toBitVec` to obtain the two's complement representation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.toNat\"><span class=\"name\">ISize</span>.<span class=\"name\">toNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1592-L1597","name":"ISize.toNatClampNeg","line":1592,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.toNatClampNeg","doc":"Converts a word-sized signed integer to a natural number, mapping all negative numbers to `0`.\n\nUse `ISize.toBitVec` to obtain the two's complement representation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.toNatClampNeg\"><span class=\"name\">ISize</span>.<span class=\"name\">toNatClampNeg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1585-L1591","name":"ISize.toInt","line":1585,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.toInt","doc":"Converts a word-sized signed integer to an arbitrary-precision integer that denotes the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.toInt\"><span class=\"name\">ISize</span>.<span class=\"name\">toInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1584-L1584","name":"Nat.toISize","line":1584,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Nat.toISize","doc":"Converts an arbitrary-precision natural number to a word-sized signed integer, wrapping around on\noverflow.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Nat.toISize\"><span class=\"name\">Nat</span>.<span class=\"name\">toISize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1582-L1583","name":"Int.toISize","line":1582,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int.toISize","doc":"Converts an arbitrary-precision integer to a word-sized signed integer, wrapping around on over- or\nunderflow.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int.toISize\"><span class=\"name\">Int</span>.<span class=\"name\">toISize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1574-L1581","name":"ISize.ofNat","line":1574,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.ofNat","doc":"Converts an arbitrary-precision natural number to a word-sized signed integer, wrapping around on\noverflow.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.ofNat\"><span class=\"name\">ISize</span>.<span class=\"name\">ofNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1566-L1573","name":"ISize.ofInt","line":1566,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.ofInt","doc":"Converts an arbitrary-precision integer to a word-sized signed integer, wrapping around on over- or\nunderflow.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.ofInt\"><span class=\"name\">ISize</span>.<span class=\"name\">ofInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1564-L1565","name":"ISize.mk","line":1564,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.mk","doc":"Obtains the `ISize` that is 2's complement equivalent to the `USize`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.mk\"><span class=\"name\">ISize</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#USize\">USize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1562-L1563","name":"USize.toISize","line":1562,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#USize.toISize","doc":"Obtains the `ISize` that is 2's complement equivalent to the `USize`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#USize.toISize\"><span class=\"name\">USize</span>.<span class=\"name\">toISize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#USize\">USize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1559-L1560","name":"ISize.toBitVec.inj","line":1559,"kind":"theorem","docLink":"./Init/Data/SInt/Basic.html#ISize.toBitVec.inj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.toBitVec.inj\"><span class=\"name\">ISize</span>.<span class=\"name\">toBitVec</span>.<span class=\"name\">inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Data/SInt/Basic.html#ISize.toBitVec\">toBitVec</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Data/SInt/Basic.html#ISize.toBitVec\">toBitVec</a></span> → <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1554-L1557","name":"ISize.toBitVec","line":1554,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.toBitVec","doc":"Obtain the `BitVec` that contains the 2's complement representation of the `ISize`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.toBitVec\"><span class=\"name\">ISize</span>.<span class=\"name\">toBitVec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BitVec\">BitVec</a> <a href=\"./Init/Prelude.html#System.Platform.numBits\">System.Platform.numBits</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1551-L1552","name":"ISize.size","line":1551,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.size","doc":"The number of distinct values representable by `ISize`, that is, `2^System.Platform.numBits`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.size\"><span class=\"name\">ISize</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1549-L1549","name":"instMinInt64","line":1549,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMinInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMinInt64\"><span class=\"name\">instMinInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1548-L1548","name":"instMaxInt64","line":1548,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMaxInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMaxInt64\"><span class=\"name\">instMaxInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1547-L1547","name":"instDecidableLeInt64","line":1547,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableLeInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableLeInt64\"><span class=\"name\">instDecidableLeInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1546-L1546","name":"instDecidableLtInt64","line":1546,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableLtInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableLtInt64\"><span class=\"name\">instDecidableLtInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1530-L1544","name":"Int64.decLe","line":1530,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.decLe","doc":"Decides whether one 8-bit signed integer is less than or equal to another. Usually accessed via the\n`DecidableLE Int64` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `(if ((-7) : Int64) ≤ 7 then \"yes\" else \"no\") = \"yes\"`\n * `(if (15 : Int64) ≤ 15 then \"yes\" else \"no\") = \"yes\"`\n * `(if (15 : Int64) ≤ 5 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int64) ≤ 7 by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.decLe\"><span class=\"name\">Int64</span>.<span class=\"name\">decLe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1516-L1529","name":"Int64.decLt","line":1516,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.decLt","doc":"Decides whether one 8-bit signed integer is strictly less than another. Usually accessed via the\n`DecidableLT Int64` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `(if ((-7) : Int64) < 7 then \"yes\" else \"no\") = \"yes\"`\n * `(if (5 : Int64) < 5 then \"yes\" else \"no\") = \"no\"`\n * `show ¬((7 : Int64) < 7) by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.decLt\"><span class=\"name\">Int64</span>.<span class=\"name\">decLt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1510-L1514","name":"Bool.toInt64","line":1510,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Bool.toInt64","doc":"Converts `true` to `1` and `false` to `0`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Bool.toInt64\"><span class=\"name\">Bool</span>.<span class=\"name\">toInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1508-L1508","name":"instDecidableEqInt64","line":1508,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableEqInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableEqInt64\"><span class=\"name\">instDecidableEqInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1507-L1507","name":"instShiftRightInt64","line":1507,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instShiftRightInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instShiftRightInt64\"><span class=\"name\">instShiftRightInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ShiftRight\">ShiftRight</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1506-L1506","name":"instShiftLeftInt64","line":1506,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instShiftLeftInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instShiftLeftInt64\"><span class=\"name\">instShiftLeftInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ShiftLeft\">ShiftLeft</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1505-L1505","name":"instXorInt64","line":1505,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instXorInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instXorInt64\"><span class=\"name\">instXorInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Xor\">Xor</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1504-L1504","name":"instOrOpInt64","line":1504,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instOrOpInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instOrOpInt64\"><span class=\"name\">instOrOpInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#OrOp\">OrOp</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1503-L1503","name":"instAndOpInt64","line":1503,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instAndOpInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instAndOpInt64\"><span class=\"name\">instAndOpInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#AndOp\">AndOp</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1502-L1502","name":"instComplementInt64","line":1502,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instComplementInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instComplementInt64\"><span class=\"name\">instComplementInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Complement\">Complement</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1501-L1501","name":"instLEInt64","line":1501,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instLEInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instLEInt64\"><span class=\"name\">instLEInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1500-L1500","name":"instLTInt64","line":1500,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instLTInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instLTInt64\"><span class=\"name\">instLTInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1499-L1499","name":"instDivInt64","line":1499,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDivInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDivInt64\"><span class=\"name\">instDivInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Div\">Div</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1498-L1498","name":"instModInt64","line":1498,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instModInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instModInt64\"><span class=\"name\">instModInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mod\">Mod</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1497-L1497","name":"instMulInt64","line":1497,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMulInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMulInt64\"><span class=\"name\">instMulInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mul\">Mul</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1496-L1496","name":"instSubInt64","line":1496,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instSubInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instSubInt64\"><span class=\"name\">instSubInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Sub\">Sub</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1495-L1495","name":"instAddInt64","line":1495,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instAddInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instAddInt64\"><span class=\"name\">instAddInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Add\">Add</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1492-L1493","name":"instInhabitedInt64","line":1492,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instInhabitedInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instInhabitedInt64\"><span class=\"name\">instInhabitedInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1486-L1490","name":"Int64.le","line":1486,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.le","doc":"Non-strict inequality of 64-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the `≤` operator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.le\"><span class=\"name\">Int64</span>.<span class=\"name\">le</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1481-L1485","name":"Int64.lt","line":1481,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.lt","doc":"Strict inequality of 64-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the `<` operator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.lt\"><span class=\"name\">Int64</span>.<span class=\"name\">lt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1461-L1479","name":"Int64.decEq","line":1461,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.decEq","doc":"Decides whether two 64-bit signed integers are equal. Usually accessed via the `DecidableEq Int64`\ninstance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `Int64.decEq 123 123 = .isTrue rfl`\n * `(if ((-7) : Int64) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int64) = 7 by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.decEq\"><span class=\"name\">Int64</span>.<span class=\"name\">decEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1450-L1459","name":"Int64.abs","line":1450,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.abs","doc":"Computes the absolute value of a 64-bit signed integer.\n\nThis function is equivalent to `if a < 0 then -a else a`, so in particular `Int64.minValue` will be\nmapped to `Int64.minValue`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.abs\"><span class=\"name\">Int64</span>.<span class=\"name\">abs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1439-L1449","name":"Int64.complement","line":1439,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.complement","doc":"Bitwise complement, also known as bitwise negation, for 64-bit signed integers. Usually accessed via\nthe `~~~` prefix operator.\n\nEach bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so `Int64.complement a = -(a + 1)`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.complement\"><span class=\"name\">Int64</span>.<span class=\"name\">complement</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1430-L1438","name":"Int64.shiftRight","line":1430,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.shiftRight","doc":"Arithmetic right shift for 64-bit signed integers. Usually accessed via the `<<<` operator.\n\nThe high bits are filled with the value of the most significant bit.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.shiftRight\"><span class=\"name\">Int64</span>.<span class=\"name\">shiftRight</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1421-L1429","name":"Int64.shiftLeft","line":1421,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.shiftLeft","doc":"Bitwise left shift for 64-bit signed integers. Usually accessed via the `<<<` operator.\n\nSigned integers are interpreted as bitvectors according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.shiftLeft\"><span class=\"name\">Int64</span>.<span class=\"name\">shiftLeft</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1411-L1420","name":"Int64.xor","line":1411,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.xor","doc":"Bitwise exclusive or for 64-bit signed integers. Usually accessed via the `^^^` operator.\n\nEach bit of the resulting integer is set if exactly one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.xor\"><span class=\"name\">Int64</span>.<span class=\"name\">xor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1401-L1410","name":"Int64.lor","line":1401,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.lor","doc":"Bitwise or for 64-bit signed integers. Usually accessed via the `|||` operator.\n\nEach bit of the resulting integer is set if at least one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.lor\"><span class=\"name\">Int64</span>.<span class=\"name\">lor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1391-L1400","name":"Int64.land","line":1391,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.land","doc":"Bitwise and for 64-bit signed integers. Usually accessed via the `&&&` operator.\n\nEach bit of the resulting integer is set if the corresponding bits of both input integers are set,\naccording to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.land\"><span class=\"name\">Int64</span>.<span class=\"name\">land</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1370-L1390","name":"Int64.mod","line":1370,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.mod","doc":"The modulo operator for 64-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by `Int64.div`. Usually accessed via the `%`\noperator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int64.mod 5 2 = 1`\n* `Int64.mod 5 (-2) = 1`\n* `Int64.mod (-5) 2 = (-1)`\n* `Int64.mod (-5) (-2) = (-1)`\n* `Int64.mod 4 2 = 0`\n* `Int64.mod 4 (-2) = 0`\n* `Int64.mod 4 0 = 4`\n* `Int64.mod (-4) 0 = (-4)`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.mod\"><span class=\"name\">Int64</span>.<span class=\"name\">mod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1353-L1369","name":"Int64.div","line":1353,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.div","doc":"Truncating division for 64-bit signed integers, rounding towards zero. Usually accessed via the `/`\noperator.\n\nDivision by zero is defined to be zero.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int64.div 10 3 = 3`\n* `Int64.div 10 (-3) = (-3)`\n* `Int64.div (-10) (-3) = 3`\n* `Int64.div (-10) 3 = (-3)`\n* `Int64.div 10 0 = 0`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.div\"><span class=\"name\">Int64</span>.<span class=\"name\">div</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1345-L1352","name":"Int64.mul","line":1345,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.mul","doc":"Multiplies two 64-bit signed integers, wrapping around on over- or underflow.  Usually accessed via\nthe `*` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.mul\"><span class=\"name\">Int64</span>.<span class=\"name\">mul</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1337-L1344","name":"Int64.sub","line":1337,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.sub","doc":"Subtracts one 64-bit signed integer from another, wrapping around on over- or underflow. Usually\naccessed via the `-` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.sub\"><span class=\"name\">Int64</span>.<span class=\"name\">sub</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1329-L1336","name":"Int64.add","line":1329,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.add","doc":"Adds two 64-bit signed integers, wrapping around on over- or underflow.  Usually accessed via the\n`+` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.add\"><span class=\"name\">Int64</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1319-L1327","name":"Int64.ofIntTruncate","line":1319,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.ofIntTruncate","doc":"Constructs an `Int64` from an `Int`, clamping if the value is too small or too large. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.ofIntTruncate\"><span class=\"name\">Int64</span>.<span class=\"name\">ofIntTruncate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1315-L1318","name":"Int64.ofIntLE","line":1315,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.ofIntLE","doc":"Constructs an `Int64` from an `Int` that is known to be in bounds. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.ofIntLE\"><span class=\"name\">Int64</span>.<span class=\"name\">ofIntLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_hl</span> : <span class=\"fn\"><a href=\"./Init/Data/SInt/Basic.html#Int64.minValue\">minValue</a>.<a href=\"./Init/Data/SInt/Basic.html#Int64.toInt\">toInt</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">i</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_hr</span> : <span class=\"fn\">i</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Init/Data/SInt/Basic.html#Int64.maxValue\">maxValue</a>.<a href=\"./Init/Data/SInt/Basic.html#Int64.toInt\">toInt</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1313-L1314","name":"Int64.minValue","line":1313,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.minValue","doc":"The smallest number that `Int64` can represent: `-2^63 = -9223372036854775808`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.minValue\"><span class=\"name\">Int64</span>.<span class=\"name\">minValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1311-L1312","name":"Int64.maxValue","line":1311,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.maxValue","doc":"The largest number that `Int64` can represent: `2^63 - 1 = 9223372036854775807`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.maxValue\"><span class=\"name\">Int64</span>.<span class=\"name\">maxValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1308-L1309","name":"Int64.instNeg","line":1308,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#Int64.instNeg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.instNeg\"><span class=\"name\">Int64</span>.<span class=\"name\">instNeg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg\">Neg</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1307-L1307","name":"Int64.instOfNat","line":1307,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#Int64.instOfNat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.instOfNat\"><span class=\"name\">Int64</span>.<span class=\"name\">instOfNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat\">OfNat</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a> <span class=\"fn\">n</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1304-L1305","name":"instHashableInt64","line":1304,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instHashableInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instHashableInt64\"><span class=\"name\">instHashableInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1302-L1302","name":"instReprAtomInt64","line":1302,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instReprAtomInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instReprAtomInt64\"><span class=\"name\">instReprAtomInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#ReprAtom\">ReprAtom</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1300-L1301","name":"instReprInt64","line":1300,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instReprInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instReprInt64\"><span class=\"name\">instReprInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1298-L1299","name":"instToStringInt64","line":1298,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instToStringInt64","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instToStringInt64\"><span class=\"name\">instToStringInt64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1290-L1296","name":"Int64.neg","line":1290,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.neg","doc":"Negates 64-bit signed integers. Usually accessed via the `-` prefix operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.neg\"><span class=\"name\">Int64</span>.<span class=\"name\">neg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1283-L1289","name":"Int32.toInt64","line":1283,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.toInt64","doc":"Converts 32-bit signed integers to 64-bit signed integers that denote the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.toInt64\"><span class=\"name\">Int32</span>.<span class=\"name\">toInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1276-L1282","name":"Int16.toInt64","line":1276,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.toInt64","doc":"Converts 16-bit signed integers to 64-bit signed integers that denote the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.toInt64\"><span class=\"name\">Int16</span>.<span class=\"name\">toInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1269-L1275","name":"Int8.toInt64","line":1269,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.toInt64","doc":"Converts 8-bit signed integers to 64-bit signed integers that denote the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.toInt64\"><span class=\"name\">Int8</span>.<span class=\"name\">toInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1261-L1268","name":"Int64.toInt32","line":1261,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.toInt32","doc":"Converts a 64-bit signed integer to a 32-bit signed integer by truncating its bitvector\nrepresentation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.toInt32\"><span class=\"name\">Int64</span>.<span class=\"name\">toInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1253-L1260","name":"Int64.toInt16","line":1253,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.toInt16","doc":"Converts a 64-bit signed integer to a 16-bit signed integer by truncating its bitvector\nrepresentation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.toInt16\"><span class=\"name\">Int64</span>.<span class=\"name\">toInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1245-L1252","name":"Int64.toInt8","line":1245,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.toInt8","doc":"Converts a 64-bit signed integer to an 8-bit signed integer by truncating its bitvector\nrepresentation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.toInt8\"><span class=\"name\">Int64</span>.<span class=\"name\">toInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1243-L1244","name":"Int64.ofBitVec","line":1243,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.ofBitVec","doc":"Obtains the `Int64` whose 2's complement representation is the given `BitVec 64`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.ofBitVec\"><span class=\"name\">Int64</span>.<span class=\"name\">ofBitVec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#BitVec\">BitVec</a> <span class=\"fn\">64</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1241-L1242","name":"Int64.toNat","line":1241,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.toNat","doc":"Converts a 64-bit signed integer to a natural number, mapping all negative numbers to `0`.\n\nUse `Int64.toBitVec` to obtain the two's complement representation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.toNat\"><span class=\"name\">Int64</span>.<span class=\"name\">toNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1235-L1240","name":"Int64.toNatClampNeg","line":1235,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.toNatClampNeg","doc":"Converts a 64-bit signed integer to a natural number, mapping all negative numbers to `0`.\n\nUse `Int64.toBitVec` to obtain the two's complement representation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.toNatClampNeg\"><span class=\"name\">Int64</span>.<span class=\"name\">toNatClampNeg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1228-L1234","name":"Int64.toInt","line":1228,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.toInt","doc":"Converts a 64-bit signed integer to an arbitrary-precision integer that denotes the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.toInt\"><span class=\"name\">Int64</span>.<span class=\"name\">toInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1216-L1227","name":"Nat.toInt64","line":1216,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Nat.toInt64","doc":"Converts a natural number to a 64-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt64 127 = 127`\n * `Nat.toInt64 2_147_483_648 = 2_147_483_648`\n * `Nat.toInt64 9_223_372_036_854_775_807 = 9_223_372_036_854_775_807`\n * `Nat.toInt64 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n * `Nat.toInt64 18_446_744_073_709_551_618 = 0`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Nat.toInt64\"><span class=\"name\">Nat</span>.<span class=\"name\">toInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1202-L1215","name":"Int.toInt64","line":1202,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int.toInt64","doc":"Converts an arbitrary-precision integer to a 64-bit integer, wrapping on overflow or underflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int.toInt64 48 = 48`\n* `Int.toInt64 (-40_000) = -40_000`\n* `Int.toInt64 2_147_483_648 = 2_147_483_648`\n* `Int.toInt64 (-2_147_483_649) = -2_147_483_649`\n* `Int.toInt64 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n* `Int.toInt64 (-9_223_372_036_854_775_809) = 9_223_372_036_854_775_807`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int.toInt64\"><span class=\"name\">Int</span>.<span class=\"name\">toInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1187-L1201","name":"Int64.ofNat","line":1187,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.ofNat","doc":"Converts a natural number to a 64-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `Int64.ofNat 127 = 127`\n * `Int64.ofNat 2_147_483_648 = 2_147_483_648`\n * `Int64.ofNat 9_223_372_036_854_775_807 = 9_223_372_036_854_775_807`\n * `Int64.ofNat 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n * `Int64.ofNat 18_446_744_073_709_551_618 = 0`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.ofNat\"><span class=\"name\">Int64</span>.<span class=\"name\">ofNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1172-L1186","name":"Int64.ofInt","line":1172,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.ofInt","doc":"Converts an arbitrary-precision integer to a 64-bit integer, wrapping on overflow or underflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int64.ofInt 48 = 48`\n* `Int64.ofInt (-40_000) = -40_000`\n* `Int64.ofInt 2_147_483_648 = 2_147_483_648`\n* `Int64.ofInt (-2_147_483_649) = -2_147_483_649`\n* `Int64.ofInt 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808`\n* `Int64.ofInt (-9_223_372_036_854_775_809) = 9_223_372_036_854_775_807`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.ofInt\"><span class=\"name\">Int64</span>.<span class=\"name\">ofInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1170-L1171","name":"Int64.mk","line":1170,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.mk","doc":"Obtains the `Int64` that is 2's complement equivalent to the `UInt64`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.mk\"><span class=\"name\">Int64</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#UInt64\">UInt64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1168-L1169","name":"UInt64.toInt64","line":1168,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#UInt64.toInt64","doc":"Obtains the `Int64` that is 2's complement equivalent to the `UInt64`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#UInt64.toInt64\"><span class=\"name\">UInt64</span>.<span class=\"name\">toInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#UInt64\">UInt64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1165-L1166","name":"Int64.toBitVec.inj","line":1165,"kind":"theorem","docLink":"./Init/Data/SInt/Basic.html#Int64.toBitVec.inj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.toBitVec.inj\"><span class=\"name\">Int64</span>.<span class=\"name\">toBitVec</span>.<span class=\"name\">inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Data/SInt/Basic.html#Int64.toBitVec\">toBitVec</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Data/SInt/Basic.html#Int64.toBitVec\">toBitVec</a></span> → <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1160-L1163","name":"Int64.toBitVec","line":1160,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.toBitVec","doc":"Obtain the `BitVec` that contains the 2's complement representation of the `Int64`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.toBitVec\"><span class=\"name\">Int64</span>.<span class=\"name\">toBitVec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BitVec\">BitVec</a> <span class=\"fn\">64</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1157-L1158","name":"Int64.size","line":1157,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.size","doc":"The number of distinct values representable by `Int64`, that is, `2^64 = 18446744073709551616`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.size\"><span class=\"name\">Int64</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1155-L1155","name":"instMinInt32","line":1155,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMinInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMinInt32\"><span class=\"name\">instMinInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1154-L1154","name":"instMaxInt32","line":1154,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMaxInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMaxInt32\"><span class=\"name\">instMaxInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1153-L1153","name":"instDecidableLeInt32","line":1153,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableLeInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableLeInt32\"><span class=\"name\">instDecidableLeInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1152-L1152","name":"instDecidableLtInt32","line":1152,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableLtInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableLtInt32\"><span class=\"name\">instDecidableLtInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1136-L1150","name":"Int32.decLe","line":1136,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.decLe","doc":"Decides whether one 32-bit signed integer is less than or equal to another. Usually accessed via the\n`DecidableLE Int32` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `(if ((-7) : Int32) ≤ 7 then \"yes\" else \"no\") = \"yes\"`\n * `(if (15 : Int32) ≤ 15 then \"yes\" else \"no\") = \"yes\"`\n * `(if (15 : Int32) ≤ 5 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int32) ≤ 7 by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.decLe\"><span class=\"name\">Int32</span>.<span class=\"name\">decLe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1121-L1134","name":"Int32.decLt","line":1121,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.decLt","doc":"Decides whether one 32-bit signed integer is strictly less than another. Usually accessed via the\n`DecidableLT Int32` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `(if ((-7) : Int32) < 7 then \"yes\" else \"no\") = \"yes\"`\n * `(if (5 : Int32) < 5 then \"yes\" else \"no\") = \"no\"`\n * `show ¬((7 : Int32) < 7) by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.decLt\"><span class=\"name\">Int32</span>.<span class=\"name\">decLt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1115-L1119","name":"Bool.toInt32","line":1115,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Bool.toInt32","doc":"Converts `true` to `1` and `false` to `0`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Bool.toInt32\"><span class=\"name\">Bool</span>.<span class=\"name\">toInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1113-L1113","name":"instDecidableEqInt32","line":1113,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableEqInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableEqInt32\"><span class=\"name\">instDecidableEqInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1112-L1112","name":"instShiftRightInt32","line":1112,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instShiftRightInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instShiftRightInt32\"><span class=\"name\">instShiftRightInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ShiftRight\">ShiftRight</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1111-L1111","name":"instShiftLeftInt32","line":1111,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instShiftLeftInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instShiftLeftInt32\"><span class=\"name\">instShiftLeftInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ShiftLeft\">ShiftLeft</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1110-L1110","name":"instXorInt32","line":1110,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instXorInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instXorInt32\"><span class=\"name\">instXorInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Xor\">Xor</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1109-L1109","name":"instOrOpInt32","line":1109,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instOrOpInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instOrOpInt32\"><span class=\"name\">instOrOpInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#OrOp\">OrOp</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1108-L1108","name":"instAndOpInt32","line":1108,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instAndOpInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instAndOpInt32\"><span class=\"name\">instAndOpInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#AndOp\">AndOp</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1107-L1107","name":"instComplementInt32","line":1107,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instComplementInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instComplementInt32\"><span class=\"name\">instComplementInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Complement\">Complement</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1106-L1106","name":"instLEInt32","line":1106,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instLEInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instLEInt32\"><span class=\"name\">instLEInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1105-L1105","name":"instLTInt32","line":1105,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instLTInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instLTInt32\"><span class=\"name\">instLTInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1104-L1104","name":"instDivInt32","line":1104,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDivInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDivInt32\"><span class=\"name\">instDivInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Div\">Div</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1103-L1103","name":"instModInt32","line":1103,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instModInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instModInt32\"><span class=\"name\">instModInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mod\">Mod</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1102-L1102","name":"instMulInt32","line":1102,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMulInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMulInt32\"><span class=\"name\">instMulInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mul\">Mul</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1101-L1101","name":"instSubInt32","line":1101,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instSubInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instSubInt32\"><span class=\"name\">instSubInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Sub\">Sub</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1100-L1100","name":"instAddInt32","line":1100,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instAddInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instAddInt32\"><span class=\"name\">instAddInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Add\">Add</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1097-L1098","name":"instInhabitedInt32","line":1097,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instInhabitedInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instInhabitedInt32\"><span class=\"name\">instInhabitedInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1091-L1095","name":"Int32.le","line":1091,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.le","doc":"Non-strict inequality of 32-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the `≤` operator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.le\"><span class=\"name\">Int32</span>.<span class=\"name\">le</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1086-L1090","name":"Int32.lt","line":1086,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.lt","doc":"Strict inequality of 32-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the `<` operator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.lt\"><span class=\"name\">Int32</span>.<span class=\"name\">lt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1066-L1084","name":"Int32.decEq","line":1066,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.decEq","doc":"Decides whether two 32-bit signed integers are equal. Usually accessed via the `DecidableEq Int32`\ninstance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `Int32.decEq 123 123 = .isTrue rfl`\n * `(if ((-7) : Int32) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int32) = 7 by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.decEq\"><span class=\"name\">Int32</span>.<span class=\"name\">decEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1055-L1064","name":"Int32.abs","line":1055,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.abs","doc":"Computes the absolute value of a 32-bit signed integer.\n\nThis function is equivalent to `if a < 0 then -a else a`, so in particular `Int32.minValue` will be\nmapped to `Int32.minValue`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.abs\"><span class=\"name\">Int32</span>.<span class=\"name\">abs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1044-L1054","name":"Int32.complement","line":1044,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.complement","doc":"Bitwise complement, also known as bitwise negation, for 32-bit signed integers. Usually accessed via\nthe `~~~` prefix operator.\n\nEach bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so `Int32.complement a = -(a + 1)`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.complement\"><span class=\"name\">Int32</span>.<span class=\"name\">complement</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1035-L1043","name":"Int32.shiftRight","line":1035,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.shiftRight","doc":"Arithmetic right shift for 32-bit signed integers. Usually accessed via the `<<<` operator.\n\nThe high bits are filled with the value of the most significant bit.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.shiftRight\"><span class=\"name\">Int32</span>.<span class=\"name\">shiftRight</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1026-L1034","name":"Int32.shiftLeft","line":1026,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.shiftLeft","doc":"Bitwise left shift for 32-bit signed integers. Usually accessed via the `<<<` operator.\n\nSigned integers are interpreted as bitvectors according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.shiftLeft\"><span class=\"name\">Int32</span>.<span class=\"name\">shiftLeft</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1016-L1025","name":"Int32.xor","line":1016,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.xor","doc":"Bitwise exclusive or for 32-bit signed integers. Usually accessed via the `^^^` operator.\n\nEach bit of the resulting integer is set if exactly one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.xor\"><span class=\"name\">Int32</span>.<span class=\"name\">xor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L1006-L1015","name":"Int32.lor","line":1006,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.lor","doc":"Bitwise or for 32-bit signed integers. Usually accessed via the `|||` operator.\n\nEach bit of the resulting integer is set if at least one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.lor\"><span class=\"name\">Int32</span>.<span class=\"name\">lor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L996-L1005","name":"Int32.land","line":996,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.land","doc":"Bitwise and for 32-bit signed integers. Usually accessed via the `&&&` operator.\n\nEach bit of the resulting integer is set if the corresponding bits of both input integers are set,\naccording to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.land\"><span class=\"name\">Int32</span>.<span class=\"name\">land</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L975-L995","name":"Int32.mod","line":975,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.mod","doc":"The modulo operator for 32-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by `Int32.div`. Usually accessed via the `%`\noperator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int32.mod 5 2 = 1`\n* `Int32.mod 5 (-2) = 1`\n* `Int32.mod (-5) 2 = (-1)`\n* `Int32.mod (-5) (-2) = (-1)`\n* `Int32.mod 4 2 = 0`\n* `Int32.mod 4 (-2) = 0`\n* `Int32.mod 4 0 = 4`\n* `Int32.mod (-4) 0 = (-4)`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.mod\"><span class=\"name\">Int32</span>.<span class=\"name\">mod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L958-L974","name":"Int32.div","line":958,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.div","doc":"Truncating division for 32-bit signed integers, rounding towards zero. Usually accessed via the `/`\noperator.\n\nDivision by zero is defined to be zero.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int32.div 10 3 = 3`\n* `Int32.div 10 (-3) = (-3)`\n* `Int32.div (-10) (-3) = 3`\n* `Int32.div (-10) 3 = (-3)`\n* `Int32.div 10 0 = 0`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.div\"><span class=\"name\">Int32</span>.<span class=\"name\">div</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L950-L957","name":"Int32.mul","line":950,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.mul","doc":"Multiplies two 32-bit signed integers, wrapping around on over- or underflow.  Usually accessed via\nthe `*` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.mul\"><span class=\"name\">Int32</span>.<span class=\"name\">mul</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L942-L949","name":"Int32.sub","line":942,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.sub","doc":"Subtracts one 32-bit signed integer from another, wrapping around on over- or underflow. Usually\naccessed via the `-` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.sub\"><span class=\"name\">Int32</span>.<span class=\"name\">sub</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L934-L941","name":"Int32.add","line":934,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.add","doc":"Adds two 32-bit signed integers, wrapping around on over- or underflow.  Usually accessed via the\n`+` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.add\"><span class=\"name\">Int32</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L924-L932","name":"Int32.ofIntTruncate","line":924,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.ofIntTruncate","doc":"Constructs an `Int32` from an `Int`, clamping if the value is too small or too large. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.ofIntTruncate\"><span class=\"name\">Int32</span>.<span class=\"name\">ofIntTruncate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L920-L923","name":"Int32.ofIntLE","line":920,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.ofIntLE","doc":"Constructs an `Int32` from an `Int` that is known to be in bounds. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.ofIntLE\"><span class=\"name\">Int32</span>.<span class=\"name\">ofIntLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_hl</span> : <span class=\"fn\"><a href=\"./Init/Data/SInt/Basic.html#Int32.minValue\">minValue</a>.<a href=\"./Init/Data/SInt/Basic.html#Int32.toInt\">toInt</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">i</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_hr</span> : <span class=\"fn\">i</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Init/Data/SInt/Basic.html#Int32.maxValue\">maxValue</a>.<a href=\"./Init/Data/SInt/Basic.html#Int32.toInt\">toInt</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L918-L919","name":"Int32.minValue","line":918,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.minValue","doc":"The smallest number that `Int32` can represent: `-2^31 = -2147483648`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.minValue\"><span class=\"name\">Int32</span>.<span class=\"name\">minValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L916-L917","name":"Int32.maxValue","line":916,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.maxValue","doc":"The largest number that `Int32` can represent: `2^31 - 1 = 2147483647`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.maxValue\"><span class=\"name\">Int32</span>.<span class=\"name\">maxValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L913-L914","name":"Int32.instNeg","line":913,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#Int32.instNeg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.instNeg\"><span class=\"name\">Int32</span>.<span class=\"name\">instNeg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg\">Neg</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L912-L912","name":"Int32.instOfNat","line":912,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#Int32.instOfNat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.instOfNat\"><span class=\"name\">Int32</span>.<span class=\"name\">instOfNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat\">OfNat</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a> <span class=\"fn\">n</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L909-L910","name":"instHashableInt32","line":909,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instHashableInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instHashableInt32\"><span class=\"name\">instHashableInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L907-L907","name":"instReprAtomInt32","line":907,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instReprAtomInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instReprAtomInt32\"><span class=\"name\">instReprAtomInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#ReprAtom\">ReprAtom</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L905-L906","name":"instReprInt32","line":905,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instReprInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instReprInt32\"><span class=\"name\">instReprInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L903-L904","name":"instToStringInt32","line":903,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instToStringInt32","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instToStringInt32\"><span class=\"name\">instToStringInt32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L895-L901","name":"Int32.neg","line":895,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.neg","doc":"Negates 32-bit signed integers. Usually accessed via the `-` prefix operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.neg\"><span class=\"name\">Int32</span>.<span class=\"name\">neg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L888-L894","name":"Int16.toInt32","line":888,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.toInt32","doc":"Converts 8-bit signed integers to 32-bit signed integers that denote the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.toInt32\"><span class=\"name\">Int16</span>.<span class=\"name\">toInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L881-L887","name":"Int8.toInt32","line":881,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.toInt32","doc":"Converts 8-bit signed integers to 32-bit signed integers that denote the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.toInt32\"><span class=\"name\">Int8</span>.<span class=\"name\">toInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L873-L880","name":"Int32.toInt16","line":873,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.toInt16","doc":"Converts a 32-bit signed integer to an 16-bit signed integer by truncating its bitvector\nrepresentation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.toInt16\"><span class=\"name\">Int32</span>.<span class=\"name\">toInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L865-L872","name":"Int32.toInt8","line":865,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.toInt8","doc":"Converts a 32-bit signed integer to an 8-bit signed integer by truncating its bitvector\nrepresentation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.toInt8\"><span class=\"name\">Int32</span>.<span class=\"name\">toInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L863-L864","name":"Int32.ofBitVec","line":863,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.ofBitVec","doc":"Obtains the `Int32` whose 2's complement representation is the given `BitVec 32`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.ofBitVec\"><span class=\"name\">Int32</span>.<span class=\"name\">ofBitVec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#BitVec\">BitVec</a> <span class=\"fn\">32</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L861-L862","name":"Int32.toNat","line":861,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.toNat","doc":"Converts a 32-bit signed integer to a natural number, mapping all negative numbers to `0`.\n\nUse `Int32.toBitVec` to obtain the two's complement representation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.toNat\"><span class=\"name\">Int32</span>.<span class=\"name\">toNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L855-L860","name":"Int32.toNatClampNeg","line":855,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.toNatClampNeg","doc":"Converts a 32-bit signed integer to a natural number, mapping all negative numbers to `0`.\n\nUse `Int32.toBitVec` to obtain the two's complement representation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.toNatClampNeg\"><span class=\"name\">Int32</span>.<span class=\"name\">toNatClampNeg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L848-L854","name":"Int32.toInt","line":848,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.toInt","doc":"Converts a 32-bit signed integer to an arbitrary-precision integer that denotes the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.toInt\"><span class=\"name\">Int32</span>.<span class=\"name\">toInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L837-L847","name":"Nat.toInt32","line":837,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Nat.toInt32","doc":"Converts a natural number to a 32-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt32 127 = 127`\n * `Nat.toInt32 32770 = 32770`\n * `Nat.toInt32 2_147_483_647 = 2_147_483_647`\n * `Nat.toInt32 2_147_483_648 = -2_147_483_648`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Nat.toInt32\"><span class=\"name\">Nat</span>.<span class=\"name\">toInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L825-L836","name":"Int.toInt32","line":825,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int.toInt32","doc":"Converts an arbitrary-precision integer to a 32-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int.toInt32 48 = 48`\n* `Int.toInt32 (-129) = -129`\n* `Int.toInt32 70000 = 70000`\n* `Int.toInt32 (-40000) = -40000`\n* `Int.toInt32 2147483648 = -2147483648`\n* `Int.toInt32 (-2147483649) = 2147483647`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int.toInt32\"><span class=\"name\">Int</span>.<span class=\"name\">toInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L812-L824","name":"Int32.ofNat","line":812,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.ofNat","doc":"Converts a natural number to a 32-bit signed integer, wrapping around on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int32.ofNat 127 = 127`\n* `Int32.ofNat 32770 = 32770`\n* `Int32.ofNat 2_147_483_647 = 2_147_483_647`\n* `Int32.ofNat 2_147_483_648 = -2_147_483_648`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.ofNat\"><span class=\"name\">Int32</span>.<span class=\"name\">ofNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L797-L811","name":"Int32.ofInt","line":797,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.ofInt","doc":"Converts an arbitrary-precision integer to a 32-bit integer, wrapping on overflow or underflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int32.ofInt 48 = 48`\n* `Int32.ofInt (-129) = -129`\n* `Int32.ofInt 70000 = 70000`\n* `Int32.ofInt (-40000) = -40000`\n* `Int32.ofInt 2147483648 = -2147483648`\n* `Int32.ofInt (-2147483649) = 2147483647`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.ofInt\"><span class=\"name\">Int32</span>.<span class=\"name\">ofInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L795-L796","name":"Int32.mk","line":795,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.mk","doc":"Obtains the `Int32` that is 2's complement equivalent to the `UInt32`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.mk\"><span class=\"name\">Int32</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#UInt32\">UInt32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L793-L794","name":"UInt32.toInt32","line":793,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#UInt32.toInt32","doc":"Obtains the `Int32` that is 2's complement equivalent to the `UInt32`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#UInt32.toInt32\"><span class=\"name\">UInt32</span>.<span class=\"name\">toInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#UInt32\">UInt32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L790-L791","name":"Int32.toBitVec.inj","line":790,"kind":"theorem","docLink":"./Init/Data/SInt/Basic.html#Int32.toBitVec.inj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.toBitVec.inj\"><span class=\"name\">Int32</span>.<span class=\"name\">toBitVec</span>.<span class=\"name\">inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Data/SInt/Basic.html#Int32.toBitVec\">toBitVec</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Data/SInt/Basic.html#Int32.toBitVec\">toBitVec</a></span> → <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L785-L788","name":"Int32.toBitVec","line":785,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.toBitVec","doc":"Obtain the `BitVec` that contains the 2's complement representation of the `Int32`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.toBitVec\"><span class=\"name\">Int32</span>.<span class=\"name\">toBitVec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BitVec\">BitVec</a> <span class=\"fn\">32</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L782-L783","name":"Int32.size","line":782,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.size","doc":"The number of distinct values representable by `Int32`, that is, `2^32 = 4294967296`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.size\"><span class=\"name\">Int32</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L780-L780","name":"instMinInt16","line":780,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMinInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMinInt16\"><span class=\"name\">instMinInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L779-L779","name":"instMaxInt16","line":779,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMaxInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMaxInt16\"><span class=\"name\">instMaxInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L778-L778","name":"instDecidableLeInt16","line":778,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableLeInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableLeInt16\"><span class=\"name\">instDecidableLeInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L777-L777","name":"instDecidableLtInt16","line":777,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableLtInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableLtInt16\"><span class=\"name\">instDecidableLtInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L761-L775","name":"Int16.decLe","line":761,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.decLe","doc":"Decides whether one 16-bit signed integer is less than or equal to another. Usually accessed via the\n`DecidableLE Int16` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `(if ((-7) : Int16) ≤ 7 then \"yes\" else \"no\") = \"yes\"`\n * `(if (15 : Int16) ≤ 15 then \"yes\" else \"no\") = \"yes\"`\n * `(if (15 : Int16) ≤ 5 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int16) ≤ 7 by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.decLe\"><span class=\"name\">Int16</span>.<span class=\"name\">decLe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L746-L759","name":"Int16.decLt","line":746,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.decLt","doc":"Decides whether one 16-bit signed integer is strictly less than another. Usually accessed via the\n`DecidableLT Int16` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `(if ((-7) : Int16) < 7 then \"yes\" else \"no\") = \"yes\"`\n * `(if (5 : Int16) < 5 then \"yes\" else \"no\") = \"no\"`\n * `show ¬((7 : Int16) < 7) by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.decLt\"><span class=\"name\">Int16</span>.<span class=\"name\">decLt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L740-L744","name":"Bool.toInt16","line":740,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Bool.toInt16","doc":"Converts `true` to `1` and `false` to `0`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Bool.toInt16\"><span class=\"name\">Bool</span>.<span class=\"name\">toInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L738-L738","name":"instDecidableEqInt16","line":738,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableEqInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableEqInt16\"><span class=\"name\">instDecidableEqInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L737-L737","name":"instShiftRightInt16","line":737,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instShiftRightInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instShiftRightInt16\"><span class=\"name\">instShiftRightInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ShiftRight\">ShiftRight</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L736-L736","name":"instShiftLeftInt16","line":736,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instShiftLeftInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instShiftLeftInt16\"><span class=\"name\">instShiftLeftInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ShiftLeft\">ShiftLeft</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L735-L735","name":"instXorInt16","line":735,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instXorInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instXorInt16\"><span class=\"name\">instXorInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Xor\">Xor</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L734-L734","name":"instOrOpInt16","line":734,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instOrOpInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instOrOpInt16\"><span class=\"name\">instOrOpInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#OrOp\">OrOp</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L733-L733","name":"instAndOpInt16","line":733,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instAndOpInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instAndOpInt16\"><span class=\"name\">instAndOpInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#AndOp\">AndOp</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L732-L732","name":"instComplementInt16","line":732,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instComplementInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instComplementInt16\"><span class=\"name\">instComplementInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Complement\">Complement</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L731-L731","name":"instLEInt16","line":731,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instLEInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instLEInt16\"><span class=\"name\">instLEInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L730-L730","name":"instLTInt16","line":730,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instLTInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instLTInt16\"><span class=\"name\">instLTInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L729-L729","name":"instDivInt16","line":729,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDivInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDivInt16\"><span class=\"name\">instDivInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Div\">Div</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L728-L728","name":"instModInt16","line":728,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instModInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instModInt16\"><span class=\"name\">instModInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mod\">Mod</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L727-L727","name":"instMulInt16","line":727,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMulInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMulInt16\"><span class=\"name\">instMulInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mul\">Mul</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L726-L726","name":"instSubInt16","line":726,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instSubInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instSubInt16\"><span class=\"name\">instSubInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Sub\">Sub</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L725-L725","name":"instAddInt16","line":725,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instAddInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instAddInt16\"><span class=\"name\">instAddInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Add\">Add</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L722-L723","name":"instInhabitedInt16","line":722,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instInhabitedInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instInhabitedInt16\"><span class=\"name\">instInhabitedInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L716-L720","name":"Int16.le","line":716,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.le","doc":"Non-strict inequality of 16-bit signed integers, defined as inequality of the corresponding\nintegers. Usually accessed via the `≤` operator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.le\"><span class=\"name\">Int16</span>.<span class=\"name\">le</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L711-L715","name":"Int16.lt","line":711,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.lt","doc":"Strict inequality of 16-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the `<` operator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.lt\"><span class=\"name\">Int16</span>.<span class=\"name\">lt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L691-L709","name":"Int16.decEq","line":691,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.decEq","doc":"Decides whether two 16-bit signed integers are equal. Usually accessed via the `DecidableEq Int16`\ninstance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `Int16.decEq 123 123 = .isTrue rfl`\n * `(if ((-7) : Int16) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int16) = 7 by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.decEq\"><span class=\"name\">Int16</span>.<span class=\"name\">decEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L680-L689","name":"Int16.abs","line":680,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.abs","doc":"Computes the absolute value of a 16-bit signed integer.\n\nThis function is equivalent to `if a < 0 then -a else a`, so in particular `Int16.minValue` will be\nmapped to `Int16.minValue`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.abs\"><span class=\"name\">Int16</span>.<span class=\"name\">abs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L669-L679","name":"Int16.complement","line":669,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.complement","doc":"Bitwise complement, also known as bitwise negation, for 16-bit signed integers. Usually accessed via\nthe `~~~` prefix operator.\n\nEach bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so `Int16.complement a = -(a + 1)`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.complement\"><span class=\"name\">Int16</span>.<span class=\"name\">complement</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L660-L668","name":"Int16.shiftRight","line":660,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.shiftRight","doc":"Arithmetic right shift for 16-bit signed integers. Usually accessed via the `<<<` operator.\n\nThe high bits are filled with the value of the most significant bit.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.shiftRight\"><span class=\"name\">Int16</span>.<span class=\"name\">shiftRight</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L651-L659","name":"Int16.shiftLeft","line":651,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.shiftLeft","doc":"Bitwise left shift for 16-bit signed integers. Usually accessed via the `<<<` operator.\n\nSigned integers are interpreted as bitvectors according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.shiftLeft\"><span class=\"name\">Int16</span>.<span class=\"name\">shiftLeft</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L641-L650","name":"Int16.xor","line":641,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.xor","doc":"Bitwise exclusive or for 16-bit signed integers. Usually accessed via the `^^^` operator.\n\nEach bit of the resulting integer is set if exactly one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.xor\"><span class=\"name\">Int16</span>.<span class=\"name\">xor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L631-L640","name":"Int16.lor","line":631,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.lor","doc":"Bitwise or for 16-bit signed integers. Usually accessed via the `|||` operator.\n\nEach bit of the resulting integer is set if at least one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.lor\"><span class=\"name\">Int16</span>.<span class=\"name\">lor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L621-L630","name":"Int16.land","line":621,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.land","doc":"Bitwise and for 16-bit signed integers. Usually accessed via the `&&&` operator.\n\nEach bit of the resulting integer is set if the corresponding bits of both input integers are set,\naccording to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.land\"><span class=\"name\">Int16</span>.<span class=\"name\">land</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L600-L620","name":"Int16.mod","line":600,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.mod","doc":"The modulo operator for 16-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by `Int16.div`. Usually accessed via the `%`\noperator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int16.mod 5 2 = 1`\n* `Int16.mod 5 (-2) = 1`\n* `Int16.mod (-5) 2 = (-1)`\n* `Int16.mod (-5) (-2) = (-1)`\n* `Int16.mod 4 2 = 0`\n* `Int16.mod 4 (-2) = 0`\n* `Int16.mod 4 0 = 4`\n* `Int16.mod (-4) 0 = (-4)`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.mod\"><span class=\"name\">Int16</span>.<span class=\"name\">mod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L583-L599","name":"Int16.div","line":583,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.div","doc":"Truncating division for 16-bit signed integers, rounding towards zero. Usually accessed via the `/`\noperator.\n\nDivision by zero is defined to be zero.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int16.div 10 3 = 3`\n* `Int16.div 10 (-3) = (-3)`\n* `Int16.div (-10) (-3) = 3`\n* `Int16.div (-10) 3 = (-3)`\n* `Int16.div 10 0 = 0`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.div\"><span class=\"name\">Int16</span>.<span class=\"name\">div</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L575-L582","name":"Int16.mul","line":575,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.mul","doc":"Multiplies two 16-bit signed integers, wrapping around on over- or underflow.  Usually accessed via\nthe `*` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.mul\"><span class=\"name\">Int16</span>.<span class=\"name\">mul</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L567-L574","name":"Int16.sub","line":567,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.sub","doc":"Subtracts one 16-bit signed integer from another, wrapping around on over- or underflow. Usually\naccessed via the `-` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.sub\"><span class=\"name\">Int16</span>.<span class=\"name\">sub</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L559-L566","name":"Int16.add","line":559,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.add","doc":"Adds two 16-bit signed integers, wrapping around on over- or underflow.  Usually accessed via the `+`\noperator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.add\"><span class=\"name\">Int16</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L549-L557","name":"Int16.ofIntTruncate","line":549,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.ofIntTruncate","doc":"Constructs an `Int16` from an `Int`, clamping if the value is too small or too large. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.ofIntTruncate\"><span class=\"name\">Int16</span>.<span class=\"name\">ofIntTruncate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L545-L548","name":"Int16.ofIntLE","line":545,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.ofIntLE","doc":"Constructs an `Int16` from an `Int` that is known to be in bounds. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.ofIntLE\"><span class=\"name\">Int16</span>.<span class=\"name\">ofIntLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_hl</span> : <span class=\"fn\"><a href=\"./Init/Data/SInt/Basic.html#Int16.minValue\">minValue</a>.<a href=\"./Init/Data/SInt/Basic.html#Int16.toInt\">toInt</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">i</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_hr</span> : <span class=\"fn\">i</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Init/Data/SInt/Basic.html#Int16.maxValue\">maxValue</a>.<a href=\"./Init/Data/SInt/Basic.html#Int16.toInt\">toInt</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L543-L544","name":"Int16.minValue","line":543,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.minValue","doc":"The smallest number that `Int16` can represent: `-2^15 = -32768`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.minValue\"><span class=\"name\">Int16</span>.<span class=\"name\">minValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L541-L542","name":"Int16.maxValue","line":541,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.maxValue","doc":"The largest number that `Int16` can represent: `2^15 - 1 = 32767`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.maxValue\"><span class=\"name\">Int16</span>.<span class=\"name\">maxValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L538-L539","name":"Int16.instNeg","line":538,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#Int16.instNeg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.instNeg\"><span class=\"name\">Int16</span>.<span class=\"name\">instNeg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg\">Neg</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L537-L537","name":"Int16.instOfNat","line":537,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#Int16.instOfNat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.instOfNat\"><span class=\"name\">Int16</span>.<span class=\"name\">instOfNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat\">OfNat</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a> <span class=\"fn\">n</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L534-L535","name":"instHashableInt16","line":534,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instHashableInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instHashableInt16\"><span class=\"name\">instHashableInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L532-L532","name":"instReprAtomInt16","line":532,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instReprAtomInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instReprAtomInt16\"><span class=\"name\">instReprAtomInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#ReprAtom\">ReprAtom</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L530-L531","name":"instReprInt16","line":530,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instReprInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instReprInt16\"><span class=\"name\">instReprInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L528-L529","name":"instToStringInt16","line":528,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instToStringInt16","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instToStringInt16\"><span class=\"name\">instToStringInt16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L520-L526","name":"Int16.neg","line":520,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.neg","doc":"Negates 16-bit signed integers. Usually accessed via the `-` prefix operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.neg\"><span class=\"name\">Int16</span>.<span class=\"name\">neg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L513-L519","name":"Int8.toInt16","line":513,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.toInt16","doc":"Converts 8-bit signed integers to 16-bit signed integers that denote the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.toInt16\"><span class=\"name\">Int8</span>.<span class=\"name\">toInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L505-L512","name":"Int16.toInt8","line":505,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.toInt8","doc":"Converts 16-bit signed integers to 8-bit signed integers by truncating their bitvector\nrepresentation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.toInt8\"><span class=\"name\">Int16</span>.<span class=\"name\">toInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L503-L504","name":"Int16.ofBitVec","line":503,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.ofBitVec","doc":"Obtains the `Int16` whose 2's complement representation is the given `BitVec 16`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.ofBitVec\"><span class=\"name\">Int16</span>.<span class=\"name\">ofBitVec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#BitVec\">BitVec</a> <span class=\"fn\">16</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L501-L502","name":"Int16.toNat","line":501,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.toNat","doc":"Converts a 16-bit signed integer to a natural number, mapping all negative numbers to `0`.\n\nUse `Int16.toBitVec` to obtain the two's complement representation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.toNat\"><span class=\"name\">Int16</span>.<span class=\"name\">toNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L495-L500","name":"Int16.toNatClampNeg","line":495,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.toNatClampNeg","doc":"Converts a 16-bit signed integer to a natural number, mapping all negative numbers to `0`.\n\nUse `Int16.toBitVec` to obtain the two's complement representation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.toNatClampNeg\"><span class=\"name\">Int16</span>.<span class=\"name\">toNatClampNeg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L488-L494","name":"Int16.toInt","line":488,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.toInt","doc":"Converts a 16-bit signed integer to an arbitrary-precision integer that denotes the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.toInt\"><span class=\"name\">Int16</span>.<span class=\"name\">toInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L476-L486","name":"Nat.toInt16","line":476,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Nat.toInt16","doc":"Converts a natural number to a 16-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt16 127 = 127`\n * `Nat.toInt16 32767 = 32767`\n * `Nat.toInt16 32768 = -32768`\n * `Nat.toInt16 32770 = -32766`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Nat.toInt16\"><span class=\"name\">Nat</span>.<span class=\"name\">toInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L465-L475","name":"Int.toInt16","line":465,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int.toInt16","doc":"Converts an arbitrary-precision integer to a 16-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int.toInt16 48 = 48`\n* `Int.toInt16 (-129) = -129`\n* `Int.toInt16 (128) = 128`\n* `Int.toInt16 70000 = 4464`\n* `Int.toInt16 (-40000) = 25536`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int.toInt16\"><span class=\"name\">Int</span>.<span class=\"name\">toInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L452-L464","name":"Int16.ofNat","line":452,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.ofNat","doc":"Converts a natural number to a 16-bit signed integer, wrapping around on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int16.ofNat 127 = 127`\n* `Int16.ofNat 32767 = 32767`\n* `Int16.ofNat 32768 = -32768`\n* `Int16.ofNat 32770 = -32766`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.ofNat\"><span class=\"name\">Int16</span>.<span class=\"name\">ofNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L438-L451","name":"Int16.ofInt","line":438,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.ofInt","doc":"Converts an arbitrary-precision integer to a 16-bit signed integer, wrapping on overflow or underflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int16.ofInt 48 = 48`\n* `Int16.ofInt (-129) = -129`\n* `Int16.ofInt (128) = 128`\n* `Int16.ofInt 70000 = 4464`\n* `Int16.ofInt (-40000) = 25536`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.ofInt\"><span class=\"name\">Int16</span>.<span class=\"name\">ofInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L436-L437","name":"Int16.mk","line":436,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.mk","doc":"Obtains the `Int16` that is 2's complement equivalent to the `UInt16`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.mk\"><span class=\"name\">Int16</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#UInt16\">UInt16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L434-L435","name":"UInt16.toInt16","line":434,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#UInt16.toInt16","doc":"Obtains the `Int16` that is 2's complement equivalent to the `UInt16`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#UInt16.toInt16\"><span class=\"name\">UInt16</span>.<span class=\"name\">toInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#UInt16\">UInt16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L431-L432","name":"Int16.toBitVec.inj","line":431,"kind":"theorem","docLink":"./Init/Data/SInt/Basic.html#Int16.toBitVec.inj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.toBitVec.inj\"><span class=\"name\">Int16</span>.<span class=\"name\">toBitVec</span>.<span class=\"name\">inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Data/SInt/Basic.html#Int16.toBitVec\">toBitVec</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Data/SInt/Basic.html#Int16.toBitVec\">toBitVec</a></span> → <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L426-L429","name":"Int16.toBitVec","line":426,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.toBitVec","doc":"Obtain the `BitVec` that contains the 2's complement representation of the `Int16`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.toBitVec\"><span class=\"name\">Int16</span>.<span class=\"name\">toBitVec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BitVec\">BitVec</a> <span class=\"fn\">16</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L423-L424","name":"Int16.size","line":423,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.size","doc":"The number of distinct values representable by `Int16`, that is, `2^16 = 65536`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.size\"><span class=\"name\">Int16</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L421-L421","name":"instMinInt8","line":421,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMinInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMinInt8\"><span class=\"name\">instMinInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L420-L420","name":"instMaxInt8","line":420,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMaxInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMaxInt8\"><span class=\"name\">instMaxInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L419-L419","name":"instDecidableLeInt8","line":419,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableLeInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableLeInt8\"><span class=\"name\">instDecidableLeInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L418-L418","name":"instDecidableLtInt8","line":418,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableLtInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableLtInt8\"><span class=\"name\">instDecidableLtInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L402-L416","name":"Int8.decLe","line":402,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.decLe","doc":"Decides whether one 8-bit signed integer is less than or equal to another. Usually accessed via the\n`DecidableLE Int8` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `(if ((-7) : Int8) ≤ 7 then \"yes\" else \"no\") = \"yes\"`\n * `(if (15 : Int8) ≤ 15 then \"yes\" else \"no\") = \"yes\"`\n * `(if (15 : Int8) ≤ 5 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int8) ≤ 7 by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.decLe\"><span class=\"name\">Int8</span>.<span class=\"name\">decLe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L387-L400","name":"Int8.decLt","line":387,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.decLt","doc":"Decides whether one 8-bit signed integer is strictly less than another. Usually accessed via the\n`DecidableLT Int8` instance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `(if ((-7) : Int8) < 7 then \"yes\" else \"no\") = \"yes\"`\n * `(if (5 : Int8) < 5 then \"yes\" else \"no\") = \"no\"`\n * `show ¬((7 : Int8) < 7) by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.decLt\"><span class=\"name\">Int8</span>.<span class=\"name\">decLt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L381-L385","name":"Bool.toInt8","line":381,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Bool.toInt8","doc":"Converts `true` to `1` and `false` to `0`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Bool.toInt8\"><span class=\"name\">Bool</span>.<span class=\"name\">toInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L379-L379","name":"instDecidableEqInt8","line":379,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDecidableEqInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDecidableEqInt8\"><span class=\"name\">instDecidableEqInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L378-L378","name":"instShiftRightInt8","line":378,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instShiftRightInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instShiftRightInt8\"><span class=\"name\">instShiftRightInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ShiftRight\">ShiftRight</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L377-L377","name":"instShiftLeftInt8","line":377,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instShiftLeftInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instShiftLeftInt8\"><span class=\"name\">instShiftLeftInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ShiftLeft\">ShiftLeft</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L376-L376","name":"instXorInt8","line":376,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instXorInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instXorInt8\"><span class=\"name\">instXorInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Xor\">Xor</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L375-L375","name":"instOrOpInt8","line":375,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instOrOpInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instOrOpInt8\"><span class=\"name\">instOrOpInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#OrOp\">OrOp</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L374-L374","name":"instAndOpInt8","line":374,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instAndOpInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instAndOpInt8\"><span class=\"name\">instAndOpInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#AndOp\">AndOp</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L373-L373","name":"instComplementInt8","line":373,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instComplementInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instComplementInt8\"><span class=\"name\">instComplementInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Complement\">Complement</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L372-L372","name":"instLEInt8","line":372,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instLEInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instLEInt8\"><span class=\"name\">instLEInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L371-L371","name":"instLTInt8","line":371,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instLTInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instLTInt8\"><span class=\"name\">instLTInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L370-L370","name":"instDivInt8","line":370,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instDivInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instDivInt8\"><span class=\"name\">instDivInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Div\">Div</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L369-L369","name":"instModInt8","line":369,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instModInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instModInt8\"><span class=\"name\">instModInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mod\">Mod</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L368-L368","name":"instMulInt8","line":368,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instMulInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instMulInt8\"><span class=\"name\">instMulInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Mul\">Mul</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L367-L367","name":"instSubInt8","line":367,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instSubInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instSubInt8\"><span class=\"name\">instSubInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Sub\">Sub</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L366-L366","name":"instAddInt8","line":366,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instAddInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instAddInt8\"><span class=\"name\">instAddInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Add\">Add</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L363-L364","name":"instInhabitedInt8","line":363,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instInhabitedInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instInhabitedInt8\"><span class=\"name\">instInhabitedInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L357-L361","name":"Int8.le","line":357,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.le","doc":"Non-strict inequality of 8-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the `≤` operator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.le\"><span class=\"name\">Int8</span>.<span class=\"name\">le</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L352-L356","name":"Int8.lt","line":352,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.lt","doc":"Strict inequality of 8-bit signed integers, defined as inequality of the corresponding integers.\nUsually accessed via the `<` operator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.lt\"><span class=\"name\">Int8</span>.<span class=\"name\">lt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L332-L350","name":"Int8.decEq","line":332,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.decEq","doc":"Decides whether two 8-bit signed integers are equal. Usually accessed via the `DecidableEq Int8`\ninstance.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n * `Int8.decEq 123 123 = .isTrue rfl`\n * `(if ((-7) : Int8) = 7 then \"yes\" else \"no\") = \"no\"`\n * `show (7 : Int8) = 7 by decide`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.decEq\"><span class=\"name\">Int8</span>.<span class=\"name\">decEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L321-L330","name":"Int8.abs","line":321,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.abs","doc":"Computes the absolute value of an 8-bit signed integer.\n\nThis function is equivalent to `if a < 0 then -a else a`, so in particular `Int8.minValue` will be\nmapped to `Int8.minValue`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.abs\"><span class=\"name\">Int8</span>.<span class=\"name\">abs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L310-L320","name":"Int8.complement","line":310,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.complement","doc":"Bitwise complement, also known as bitwise negation, for 8-bit signed integers. Usually accessed via\nthe `~~~` prefix operator.\n\nEach bit of the resulting integer is the opposite of the corresponding bit of the input integer.\nIntegers use the two's complement representation, so `Int8.complement a = -(a + 1)`.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.complement\"><span class=\"name\">Int8</span>.<span class=\"name\">complement</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L301-L309","name":"Int8.shiftRight","line":301,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.shiftRight","doc":"Arithmetic right shift for 8-bit signed integers. Usually accessed via the `<<<` operator.\n\nThe high bits are filled with the value of the most significant bit.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.shiftRight\"><span class=\"name\">Int8</span>.<span class=\"name\">shiftRight</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L292-L300","name":"Int8.shiftLeft","line":292,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.shiftLeft","doc":"Bitwise left shift for 8-bit signed integers. Usually accessed via the `<<<` operator.\n\nSigned integers are interpreted as bitvectors according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.shiftLeft\"><span class=\"name\">Int8</span>.<span class=\"name\">shiftLeft</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L282-L291","name":"Int8.xor","line":282,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.xor","doc":"Bitwise exclusive or for 8-bit signed integers. Usually accessed via the `^^^` operator.\n\nEach bit of the resulting integer is set if exactly one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.xor\"><span class=\"name\">Int8</span>.<span class=\"name\">xor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L272-L281","name":"Int8.lor","line":272,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.lor","doc":"Bitwise or for 8-bit signed integers. Usually accessed via the `|||` operator.\n\nEach bit of the resulting integer is set if at least one of the corresponding bits of the input\nintegers is set, according to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.lor\"><span class=\"name\">Int8</span>.<span class=\"name\">lor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L262-L271","name":"Int8.land","line":262,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.land","doc":"Bitwise and for 8-bit signed integers. Usually accessed via the `&&&` operator.\n\nEach bit of the resulting integer is set if the corresponding bits of both input integers are set,\naccording to the two's complement representation.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.land\"><span class=\"name\">Int8</span>.<span class=\"name\">land</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L241-L261","name":"Int8.mod","line":241,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.mod","doc":"The modulo operator for 8-bit signed integers, which computes the remainder when dividing one\ninteger by another with the T-rounding convention used by `Int8.div`. Usually accessed via the `%`\noperator.\n\nWhen the divisor is `0`, the result is the dividend rather than an error.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int8.mod 5 2 = 1`\n* `Int8.mod 5 (-2) = 1`\n* `Int8.mod (-5) 2 = (-1)`\n* `Int8.mod (-5) (-2) = (-1)`\n* `Int8.mod 4 2 = 0`\n* `Int8.mod 4 (-2) = 0`\n* `Int8.mod 4 0 = 4`\n* `Int8.mod (-4) 0 = (-4)`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.mod\"><span class=\"name\">Int8</span>.<span class=\"name\">mod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L224-L240","name":"Int8.div","line":224,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.div","doc":"Truncating division for 8-bit signed integers, rounding towards zero. Usually accessed via the `/`\noperator.\n\nDivision by zero is defined to be zero.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int8.div 10 3 = 3`\n* `Int8.div 10 (-3) = (-3)`\n* `Int8.div (-10) (-3) = 3`\n* `Int8.div (-10) 3 = (-3)`\n* `Int8.div 10 0 = 0`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.div\"><span class=\"name\">Int8</span>.<span class=\"name\">div</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L216-L223","name":"Int8.mul","line":216,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.mul","doc":"Multiplies two 8-bit signed integers, wrapping around on over- or underflow.  Usually accessed via\nthe `*` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.mul\"><span class=\"name\">Int8</span>.<span class=\"name\">mul</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L208-L215","name":"Int8.sub","line":208,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.sub","doc":"Subtracts one 8-bit signed integer from another, wrapping around on over- or underflow. Usually\naccessed via the `-` operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.sub\"><span class=\"name\">Int8</span>.<span class=\"name\">sub</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L200-L207","name":"Int8.add","line":200,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.add","doc":"Adds two 8-bit signed integers, wrapping around on over- or underflow. Usually accessed via the `+`\noperator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.add\"><span class=\"name\">Int8</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L191-L199","name":"Int8.ofIntTruncate","line":191,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.ofIntTruncate","doc":"Constructs an `Int8` from an `Int`, clamping if the value is too small or too large. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.ofIntTruncate\"><span class=\"name\">Int8</span>.<span class=\"name\">ofIntTruncate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L187-L190","name":"Int8.ofIntLE","line":187,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.ofIntLE","doc":"Constructs an `Int8` from an `Int` that is known to be in bounds. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.ofIntLE\"><span class=\"name\">Int8</span>.<span class=\"name\">ofIntLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_hl</span> : <span class=\"fn\"><a href=\"./Init/Data/SInt/Basic.html#Int8.minValue\">minValue</a>.<a href=\"./Init/Data/SInt/Basic.html#Int8.toInt\">toInt</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">i</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_hr</span> : <span class=\"fn\">i</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Init/Data/SInt/Basic.html#Int8.maxValue\">maxValue</a>.<a href=\"./Init/Data/SInt/Basic.html#Int8.toInt\">toInt</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L185-L186","name":"Int8.minValue","line":185,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.minValue","doc":"The smallest number that `Int8` can represent: `-2^7 = -128`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.minValue\"><span class=\"name\">Int8</span>.<span class=\"name\">minValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L183-L184","name":"Int8.maxValue","line":183,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.maxValue","doc":"The largest number that `Int8` can represent: `2^7 - 1 = 127`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.maxValue\"><span class=\"name\">Int8</span>.<span class=\"name\">maxValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L180-L181","name":"Int8.instNeg","line":180,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#Int8.instNeg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.instNeg\"><span class=\"name\">Int8</span>.<span class=\"name\">instNeg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg\">Neg</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L179-L179","name":"Int8.instOfNat","line":179,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#Int8.instOfNat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.instOfNat\"><span class=\"name\">Int8</span>.<span class=\"name\">instOfNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat\">OfNat</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a> <span class=\"fn\">n</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L176-L177","name":"instHashableInt8","line":176,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instHashableInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instHashableInt8\"><span class=\"name\">instHashableInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L174-L174","name":"instReprAtomInt8","line":174,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instReprAtomInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instReprAtomInt8\"><span class=\"name\">instReprAtomInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#ReprAtom\">ReprAtom</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L172-L173","name":"instReprInt8","line":172,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instReprInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instReprInt8\"><span class=\"name\">instReprInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L170-L171","name":"instToStringInt8","line":170,"kind":"instance","docLink":"./Init/Data/SInt/Basic.html#instToStringInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#instToStringInt8\"><span class=\"name\">instToStringInt8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L162-L168","name":"Int8.neg","line":162,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.neg","doc":"Negates 8-bit signed integers. Usually accessed via the `-` prefix operator.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.neg\"><span class=\"name\">Int8</span>.<span class=\"name\">neg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L160-L161","name":"Int8.ofBitVec","line":160,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.ofBitVec","doc":"Obtains the `Int8` whose 2's complement representation is the given `BitVec 8`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.ofBitVec\"><span class=\"name\">Int8</span>.<span class=\"name\">ofBitVec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#BitVec\">BitVec</a> <span class=\"fn\">8</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L158-L159","name":"Int8.toNat","line":158,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.toNat","doc":"Converts an 8-bit signed integer to a natural number, mapping all negative numbers to `0`.\n\nUse `Int8.toBitVec` to obtain the two's complement representation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.toNat\"><span class=\"name\">Int8</span>.<span class=\"name\">toNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L152-L157","name":"Int8.toNatClampNeg","line":152,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.toNatClampNeg","doc":"Converts an 8-bit signed integer to a natural number, mapping all negative numbers to `0`.\n\nUse `Int8.toBitVec` to obtain the two's complement representation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.toNatClampNeg\"><span class=\"name\">Int8</span>.<span class=\"name\">toNatClampNeg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L145-L151","name":"Int8.toInt","line":145,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.toInt","doc":"Converts an 8-bit signed integer to an arbitrary-precision integer that denotes the same number.\n\nThis function is overridden at runtime with an efficient implementation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.toInt\"><span class=\"name\">Int8</span>.<span class=\"name\">toInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L133-L143","name":"Nat.toInt8","line":133,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Nat.toInt8","doc":"Converts a natural number to an 8-bit signed integer, wrapping around to negative numbers on\noverflow.\n\nExamples:\n * `Nat.toInt8 53 = 53`\n * `Nat.toInt8 127 = 127`\n * `Nat.toInt8 128 = -128`\n * `Nat.toInt8 255 = -1`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Nat.toInt8\"><span class=\"name\">Nat</span>.<span class=\"name\">toInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L123-L132","name":"Int.toInt8","line":123,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int.toInt8","doc":"Converts an arbitrary-precision integer to an 8-bit integer, wrapping on overflow or underflow.\n\nExamples:\n* `Int.toInt8 48 = 48`\n* `Int.toInt8 (-115) = -115`\n* `Int.toInt8 (-129) = 127`\n* `Int.toInt8 (128) = -128`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int.toInt8\"><span class=\"name\">Int</span>.<span class=\"name\">toInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L110-L122","name":"Int8.ofNat","line":110,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.ofNat","doc":"Converts a natural number to an 8-bit signed integer, wrapping around on overflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int8.ofNat 53 = 53`\n* `Int8.ofNat 127 = 127`\n* `Int8.ofNat 128 = -128`\n* `Int8.ofNat 255 = -1`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.ofNat\"><span class=\"name\">Int8</span>.<span class=\"name\">ofNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L97-L109","name":"Int8.ofInt","line":97,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.ofInt","doc":"Converts an arbitrary-precision integer to an 8-bit integer, wrapping on overflow or underflow.\n\nThis function is overridden at runtime with an efficient implementation.\n\nExamples:\n* `Int8.ofInt 48 = 48`\n* `Int8.ofInt (-115) = -115`\n* `Int8.ofInt (-129) = 127`\n* `Int8.ofInt (128) = -128`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.ofInt\"><span class=\"name\">Int8</span>.<span class=\"name\">ofInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L95-L96","name":"Int8.mk","line":95,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.mk","doc":"Obtains the `Int8` that is 2's complement equivalent to the `UInt8`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.mk\"><span class=\"name\">Int8</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#UInt8\">UInt8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L93-L94","name":"UInt8.toInt8","line":93,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#UInt8.toInt8","doc":"Obtains the `Int8` that is 2's complement equivalent to the `UInt8`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#UInt8.toInt8\"><span class=\"name\">UInt8</span>.<span class=\"name\">toInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#UInt8\">UInt8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L90-L91","name":"Int8.toBitVec.inj","line":90,"kind":"theorem","docLink":"./Init/Data/SInt/Basic.html#Int8.toBitVec.inj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.toBitVec.inj\"><span class=\"name\">Int8</span>.<span class=\"name\">toBitVec</span>.<span class=\"name\">inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Data/SInt/Basic.html#Int8.toBitVec\">toBitVec</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Data/SInt/Basic.html#Int8.toBitVec\">toBitVec</a></span> → <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L85-L88","name":"Int8.toBitVec","line":85,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.toBitVec","doc":"Obtain the `BitVec` that contains the 2's complement representation of the `Int8`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.toBitVec\"><span class=\"name\">Int8</span>.<span class=\"name\">toBitVec</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BitVec\">BitVec</a> <span class=\"fn\">8</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L82-L83","name":"Int8.size","line":82,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.size","doc":"The number of distinct values representable by `Int8`, that is, `2^8 = 256`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.size\"><span class=\"name\">Int8</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L80-L80","name":"ISize.toUSize","line":80,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#ISize.toUSize","doc":"Converts a word-sized signed integer into the word-sized unsigned integer that is its two's\ncomplement encoding.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize.toUSize\"><span class=\"name\">ISize</span>.<span class=\"name\">toUSize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Data/SInt/Basic.html#ISize\">ISize</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#USize\">USize</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L68-L80","name":"ISize","line":68,"kind":"structure","docLink":"./Init/Data/SInt/Basic.html#ISize","doc":"Signed integers that are the size of a word on the platform's architecture.\n\nOn a 32-bit architecture, `ISize` is equivalent to `Int32`. On a 64-bit machine, it is equivalent to\n`Int64`. This type has special support in the compiler so it can be represented by an unboxed value.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#ISize\"><span class=\"name\">ISize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L66-L66","name":"Int64.toUInt64","line":66,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int64.toUInt64","doc":"Converts an 64-bit signed integer into the 64-bit unsigned integer that is its two's complement\nencoding.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64.toUInt64\"><span class=\"name\">Int64</span>.<span class=\"name\">toUInt64</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Data/SInt/Basic.html#Int64\">Int64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#UInt64\">UInt64</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L55-L66","name":"Int64","line":55,"kind":"structure","docLink":"./Init/Data/SInt/Basic.html#Int64","doc":"Signed 64-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 64-bit value.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int64\"><span class=\"name\">Int64</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L53-L53","name":"Int32.toUInt32","line":53,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int32.toUInt32","doc":"Converts an 32-bit signed integer into the 32-bit unsigned integer that is its two's complement\nencoding.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32.toUInt32\"><span class=\"name\">Int32</span>.<span class=\"name\">toUInt32</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#UInt32\">UInt32</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L42-L53","name":"Int32","line":42,"kind":"structure","docLink":"./Init/Data/SInt/Basic.html#Int32","doc":"Signed 32-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 32-bit value.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int32\"><span class=\"name\">Int32</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L40-L40","name":"Int16.toUInt16","line":40,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int16.toUInt16","doc":"Converts an 16-bit signed integer into the 16-bit unsigned integer that is its two's complement\nencoding.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16.toUInt16\"><span class=\"name\">Int16</span>.<span class=\"name\">toUInt16</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Data/SInt/Basic.html#Int16\">Int16</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#UInt16\">UInt16</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L29-L40","name":"Int16","line":29,"kind":"structure","docLink":"./Init/Data/SInt/Basic.html#Int16","doc":"Signed 16-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 16-bit value.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int16\"><span class=\"name\">Int16</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L27-L27","name":"Int8.toUInt8","line":27,"kind":"def","docLink":"./Init/Data/SInt/Basic.html#Int8.toUInt8","doc":"Converts an 8-bit signed integer into the 8-bit unsigned integer that is its two's complement\nencoding.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8.toUInt8\"><span class=\"name\">Int8</span>.<span class=\"name\">toUInt8</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Data/SInt/Basic.html#Int8\">Int8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#UInt8\">UInt8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/SInt/Basic.lean#L16-L27","name":"Int8","line":16,"kind":"structure","docLink":"./Init/Data/SInt/Basic.html#Int8","doc":"Signed 8-bit integers.\n\nThis type has special support in the compiler so it can be represented by an unboxed 8-bit value.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/SInt/Basic.html#Int8\"><span class=\"name\">Int8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}