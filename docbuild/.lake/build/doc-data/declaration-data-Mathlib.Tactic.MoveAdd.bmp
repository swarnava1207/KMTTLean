{"name":"Mathlib.Tactic.MoveAdd","instances":[],"imports":["Init","Mathlib.Algebra.Group.Basic","Mathlib.Lean.Meta","Mathlib.Order.Defs.LinearOrder"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L459-L462","name":"Mathlib.MoveAdd.tacticMove_mul_","line":459,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.tacticMove_mul_","doc":"The tactic `move_add` rearranges summands of expressions.\nCalling `move_add [a, ← b, ...]` matches `a, b,...` with summands in the main goal.\nIt then moves `a` to the far right and `b` to the far left of each addition in which they appear.\nThe side to which the summands are moved is determined by the presence or absence of the arrow `←`.\n\nThe inputs `a, b,...` can be any terms, also with underscores.\nThe tactic uses the first \"new\" summand that unifies with each one of the given inputs.\n\nThere is a multiplicative variant, called `move_mul`.\n\nThere is also a general tactic for a \"binary associative commutative operation\": `move_oper`.\nIn this case the syntax requires providing first a term whose head symbol is the operation.\nE.g. `move_oper HAdd.hAdd [...]` is the same as `move_add`, while `move_oper Max.max [...]`\nrearranges `max`s.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.tacticMove_mul_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">tacticMove_mul_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L454-L457","name":"Mathlib.MoveAdd.tacticMove_add_","line":454,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.tacticMove_add_","doc":"The tactic `move_add` rearranges summands of expressions.\nCalling `move_add [a, ← b, ...]` matches `a, b,...` with summands in the main goal.\nIt then moves `a` to the far right and `b` to the far left of each addition in which they appear.\nThe side to which the summands are moved is determined by the presence or absence of the arrow `←`.\n\nThe inputs `a, b,...` can be any terms, also with underscores.\nThe tactic uses the first \"new\" summand that unifies with each one of the given inputs.\n\nThere is a multiplicative variant, called `move_mul`.\n\nThere is also a general tactic for a \"binary associative commutative operation\": `move_oper`.\nIn this case the syntax requires providing first a term whose head symbol is the operation.\nE.g. `move_oper HAdd.hAdd [...]` is the same as `move_add`, while `move_oper Max.max [...]`\nrearranges `max`s.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.tacticMove_add_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">tacticMove_add_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L426-L452","name":"Mathlib.MoveAdd.moveOperTac","line":426,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.moveOperTac","doc":"The tactic `move_add` rearranges summands of expressions.\nCalling `move_add [a, ← b, ...]` matches `a, b,...` with summands in the main goal.\nIt then moves `a` to the far right and `b` to the far left of each addition in which they appear.\nThe side to which the summands are moved is determined by the presence or absence of the arrow `←`.\n\nThe inputs `a, b,...` can be any terms, also with underscores.\nThe tactic uses the first \"new\" summand that unifies with each one of the given inputs.\n\nThere is a multiplicative variant, called `move_mul`.\n\nThere is also a general tactic for a \"binary associative commutative operation\": `move_oper`.\nIn this case the syntax requires providing first a term whose head symbol is the operation.\nE.g. `move_oper HAdd.hAdd [...]` is the same as `move_add`, while `move_oper Max.max [...]`\nrearranges `max`s.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.moveOperTac\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">moveOperTac</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L407-L422","name":"Mathlib.MoveAdd.parseArrows","line":407,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.parseArrows","doc":"`parseArrows` parses an input of the form `[a, ← b, _ * (1 : ℤ)]`, consisting of a list of\nterms, each optionally preceded by the arrow `←`.\nIt returns an array of triples consisting of\n* the `Expr`ession corresponding to the parsed term,\n* the `Bool`ean `true` if the arrow is present in front of the term,\n* the underlying `Syntax` of the given term.\n\nE.g. convert `[a, ← b, _ * (1 : ℤ)]` to\n``[(a, false, `(a)), (b, true, `(b)), (_ * 1, false, `(_ * 1))]``.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.parseArrows\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">parseArrows</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.rwRuleSeq</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>))</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L379-L402","name":"Mathlib.MoveAdd.unifyMovements","line":379,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.unifyMovements","doc":"`unifyMovements` takes as input\n* an array of `Expr × Bool × Syntax`, as in the output of `parseArrows`,\n* the `Name` `op` of a binary operation,\n* an `Expr`ession `tgt`.\nIt unifies each `Expr`ession appearing as a first factor of the array with the atoms\nfor the operation `op` in the expression `tgt`, returning\n* the lists of pairs of a matched subexpression with the corresponding `Bool`ean;\n* a pair of a list of error messages and the corresponding list of Syntax terms where the error\n  should be thrown;\n* an array of debugging messages.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.unifyMovements\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">unifyMovements</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">data</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tgt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span>) <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L355-L377","name":"Mathlib.MoveAdd.reorderAndSimp","line":355,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderAndSimp","doc":"`reorderAndSimp mv op instr` takes as input an `MVarId`  `mv`, the name `op` of a binary\noperation and a list of \"instructions\" `instr` that it passes to `permuteExpr`.\n\n* It creates a version `permuted_mv` of `mv` with subexpressions representing `op`-sums reordered\n  following `instructions`.\n* It produces 2 temporary goals by applying `Eq.mpr` and unifying the resulting meta-variable with\n  `permuted_mv`: `[⊢ mv = permuted_mv, ⊢ permuted_mv]`.\n* It tries to solve the goal `mv = permuted_mv` by a simple-minded `simp` call, using the\n  `op`-analogues of `add_comm, add_assoc, add_left_comm`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderAndSimp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">reorderAndSimp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mv</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instr</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L352-L353","name":"Mathlib.MoveAdd.move_oper_simpCtx","line":352,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.move_oper_simpCtx","doc":"**Alias** of `Mathlib.MoveAdd.moveOperSimpCtx`.\n\n---\n\n`move_oper_simpCtx` is the `Simp.Context` for the reordering internal to `move_oper`.\nTo support a new binary operation, extend the list in this definition, so that it contains\nenough lemmas to allow `simp` to close a generic permutation goal for the new binary operation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.move_oper_simpCtx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">move_oper_simpCtx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L336-L350","name":"Mathlib.MoveAdd.moveOperSimpCtx","line":336,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.moveOperSimpCtx","doc":"`move_oper_simpCtx` is the `Simp.Context` for the reordering internal to `move_oper`.\nTo support a new binary operation, extend the list in this definition, so that it contains\nenough lemmas to allow `simp` to close a generic permutation goal for the new binary operation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.moveOperSimpCtx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">moveOperSimpCtx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L304-L334","name":"Mathlib.MoveAdd.pairUp","line":304,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.pairUp","doc":"`pairUp L R` takes to lists `L R : List Expr` as inputs.\nIt scans the elements of `L`, looking for a corresponding `DefEq` `Expr`ession in `R`.\nIf it finds one such element `d`, then it sets the element `d : R` aside, removing it from `R`, and\nit continues with the matching on the remainder of `L` and on `R.erase d`.\n\nAt the end, it returns the sublist of `R` of the elements that were matched to some element of `R`,\nin the order in which they appeared in `L`,\nas well as the sublist of `L` of elements that were not matched, also in the order in which they\nappeared in `L`.\n\nExample:\n```lean\n#eval do\n  let L := [mkNatLit 0, (← mkFreshExprMVar (some (mkConst ``Nat))), mkNatLit 0] -- i.e. [0, _, 0]\n  let R := [mkNatLit 0, mkNatLit 0,                                 mkNatLit 1] -- i.e. [0, 1]\n  dbg_trace f!\"{(← pairUp L R)}\"\n/- output:\n`([0, 0], [0])`\nthe output LHS list `[0, 0]` consists of the first `0` and the `MVarId`.\nthe output RHS list `[0]` corresponds to the last `0` in `L`.\n-/\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.pairUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">pairUp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L291-L302","name":"Mathlib.MoveAdd.permuteExpr","line":291,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.permuteExpr","doc":"`permuteExpr op tgt instructions` takes the same input as `rankSums` and returns the\nexpression obtained from `tgt` by replacing all `old_sum`s by the corresponding `new_sum`.\nIf there were no required changes, then `permuteExpr` reports this in its second factor. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.permuteExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">permuteExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tgt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instructions</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L268-L289","name":"Mathlib.MoveAdd.rankSums","line":268,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.rankSums","doc":"`rankSums op tgt instructions` takes as input\n* the name `op` of a binary operation,\n* an `Expr`ession `tgt`,\n* a list `instructions` of pair `(expression, boolean)`.\n\nIt extracts the maximal subexpressions of `tgt` whose head symbol is `op`\n(i.e. the maximal subexpressions that consist only of applications of the binary operation `op`),\nit rearranges the operands of such subexpressions following the order implied by `instructions`\n(as in `reorderUsing`),\nit returns the list of pairs of expressions `(old_sum, new_sum)`, for which `old_sum ≠ new_sum`\nsorted by decreasing value of `Lean.Expr.size`.\nIn particular, a subexpression of an `old_sum` can only appear *after* its over-expression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.rankSums\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">rankSums</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tgt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instructions</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>))</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L256-L266","name":"Mathlib.MoveAdd.getOps","line":256,"kind":"opaque","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.getOps","doc":"Recursively compute the Array of `getAddends` Arrays by recursing into the expression `sum`\nlooking for instance of the operation `op`.\n\nPossibly returns duplicates!\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.getOps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">getOps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sum</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>))</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L247-L254","name":"Mathlib.MoveAdd.getAddends","line":247,"kind":"opaque","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.getAddends","doc":"If `sum` is an expression consisting of repeated applications of `op`, then `getAddends`\nreturns the Array of those recursively determined arguments whose type is DefEq to `R`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.getAddends\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">getAddends</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R </span><span class=\"fn\">sum</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L220-L238","name":"Mathlib.MoveAdd.sumList","line":220,"kind":"opaque","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.sumList","doc":"`sumList prepOp left_assoc? exs` assumes that `prepOp` is an `Expr`ession representing a\nbinary operation already fully applied up until its last two arguments and assumes that the\nlast two arguments are the operands of the operation.\nSuch an expression is the result of `prepareOp`.\n\nIf `exs` is the list `[e₁, e₂, ..., eₙ]` of `Expr`essions, then `sumList prepOp left_assoc? exs`\nreturns\n* `prepOp (prepOp( ... prepOp (prepOp e₁ e₂) e₃) ... eₙ)`, if `left_assoc?` is `false`, and\n* `prepOp e₁ (prepOp e₂ (... prepOp (prepOp eₙ₋₁  eₙ))`, if `left_assoc?` is `true`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.sumList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">sumList</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prepOp</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">left_assoc?</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L206-L218","name":"Mathlib.MoveAdd.prepareOp","line":206,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.prepareOp","doc":"`prepareOp sum` takes an `Expr`ession as input.  It assumes that `sum` is a well-formed\nterm representing a repeated application of a binary operation and that the summands are the\nlast two arguments passed to the operation.\nIt returns the expression consisting of the operation with all its arguments already applied,\nexcept for the last two.\nThis is similar to `Lean.Meta.mkAdd, Lean.Meta.mkMul`, except that the resulting operation is\nprimed to work with operands of the same type as the ones already appearing in `sum`.\n\nThis is useful to rearrange the operands.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.prepareOp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">prepareOp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sum</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L176-L202","name":"Mathlib.MoveAdd.reorderUsing","line":176,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderUsing","doc":"`reorderUsing toReorder instructions` produces a reordering of `toReorder : List α`,\nfollowing the requirements imposed by `instructions : List (α × Bool)`.\n\nThese are the requirements:\n* elements of `toReorder` that appear with `true` in `instructions` appear at the\n  *beginning* of the reordered list, in the order in which they appear in `instructions`;\n* similarly, elements of `toReorder` that appear with `false` in `instructions` appear at the\n  *end* of the reordered list, in the order in which they appear in `instructions`;\n* finally, elements of `toReorder` that do not appear in `instructions` appear \"in the middle\"\n  with the order that they had in `toReorder`.\n\nFor example,\n* `reorderUsing [0, 1, 2] [(0, false)] = [1, 2, 0]`,\n* `reorderUsing [0, 1, 2] [(1, true)] = [1, 0, 2]`,\n* `reorderUsing [0, 1, 2] [(1, true), (0, false)] = [1, 2, 0]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderUsing\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">reorderUsing</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toReorder</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instructions</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L153-L174","name":"Mathlib.MoveAdd.weight","line":153,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight","doc":"Return a sorting key so that all `(a, true)`s are in the list's order\nand sorted before all `(a, false)`s, which are also in the list's order.\nAlthough `weight` does not require this, we use `weight` in the case where the list obtained\nfrom `L` by only keeping the first component (i.e. `L.map Prod.fst`) has no duplicates.\nThe properties that we mention here assume that this is the case.\n\nThus, `weight L` is a function `α → ℤ` with the following properties:\n* if `(a, true)  ∈ L`, then `weight L a` is strictly negative;\n* if `(a, false) ∈ L`, then `weight L a` is strictly positive;\n* if neither `(a, true)` nor `(a, false)` is in `L`, then `weight L a = 0`.\n\nMoreover, the function `weight L` is strictly monotone increasing on both\n`{a : α | (a, true) ∈ L}` and `{a : α | (a, false) ∈ L}`,\nin the sense that if `a' = (a, true)` and `b' = (b, true)` are in `L`,\nthen `a'` appears before `b'` in `L` if and only if `weight L a < weight L b` and\nsimilarly for the pairs with second coordinate equal to `false`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">weight</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">L</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L140-L151","name":"Mathlib.MoveAdd.uniquify","line":140,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.uniquify","doc":"`uniquify L` takes a list `L : List α` as input and it returns a list `L' : List (α × ℕ)`.\nThe two lists `L` and `L'.map Prod.fst` coincide.\nThe second component of each entry `(a, n)` in `L'` is the number of times that `a` appears in `L`\nbefore the current location.\n\nThe resulting list of pairs has no duplicates.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.uniquify\"><span class=\"name\">Mathlib</span>.<span class=\"name\">MoveAdd</span>.<span class=\"name\">uniquify</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L116-L118","name":"Lean.Expr.size","line":116,"kind":"opaque","docLink":"./Mathlib/Tactic/MoveAdd.html#Lean.Expr.size","doc":"`size e` returns the number of subexpressions of `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Lean.Expr.size\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MoveAdd.lean#L105-L114","name":"Lean.Expr.getExprInputs","line":105,"kind":"def","docLink":"./Mathlib/Tactic/MoveAdd.html#Lean.Expr.getExprInputs","doc":"`getExprInputs e` inspects the outermost constructor of `e` and returns the array of all the\narguments to that constructor that are themselves `Expr`essions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MoveAdd.html#Lean.Expr.getExprInputs\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">getExprInputs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span></div></div>"}]}