{"name":"Mathlib.Tactic.CC","instances":[{"typeNames":["Mathlib.Tactic.CC.CCState"],"name":"Mathlib.Tactic.CC.CCState.instToMessageData","className":"Lean.ToMessageData"}],"imports":["Init","Mathlib.Tactic.CC.Addition"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L234-L256","name":"Mathlib.Tactic.cc","line":234,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.cc","doc":"The congruence closure tactic `cc` tries to solve the goal by chaining\nequalities from context and applying congruence (i.e. if `a = b`, then `f a = f b`).\nIt is a finishing tactic, i.e. it is meant to close\nthe current goal, not to make some inconclusive progress.\nA mostly trivial example would be:\n\n```lean\nexample (a b c : ℕ) (f : ℕ → ℕ) (h: a = b) (h' : b = c) : f a = f c := by\n  cc\n```\n\nAs an example requiring some thinking to do by hand, consider:\n\n```lean\nexample (f : ℕ → ℕ) (x : ℕ)\n    (H1 : f (f (f x)) = x) (H2 : f (f (f (f (f x)))) = x) :\n    f x = x := by\n  cc\n``` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.cc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">cc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L228-L231","name":"Mathlib.Tactic.CC.elabCCConfig","line":228,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.elabCCConfig","doc":"Allow elaboration of `CCConfig` arguments to tactics.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.elabCCConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">elabCCConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L184-L226","name":"Lean.MVarId.cc","line":184,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Lean.MVarId.cc","doc":"Applies congruence closure to solve the given metavariable.\nThis procedure tries to solve the goal by chaining\nequalities from context and applying congruence (i.e. if `a = b`, then `f a = f b`).\n\nThe tactic works by building an equality matching graph. It's a graph where\nthe vertices are terms and they are linked by edges if they are known to\nbe equal. Once you've added all the equalities in your context, you take\nthe transitive closure of the graph and, for each connected component\n(i.e. equivalence class) you can elect a term that will represent the\nwhole class and store proofs that the other elements are equal to it.\nYou then take the transitive closure of these equalities under the\ncongruence lemmas.\nThe `cc` implementation in Lean does a few more tricks: for example it\nderives `a = b` from `Nat.succ a = Nat.succ b`, and `Nat.succ a != Nat.zero` for any `a`.\n* The starting reference point is Nelson, Oppen, [Fast decision procedures based on congruence\nclosure](http://www.cs.colorado.edu/~bec/courses/csci5535-s09/reading/nelson-oppen-congruence.pdf),\nJournal of the ACM (1980)\n* The congruence lemmas for dependent type theory as used in Lean are described in\n[Congruence closure in intensional type theory](https://leanprover.github.io/papers/congr.pdf)\n(de Moura, Selsam IJCAR 2016).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Lean.MVarId.cc\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">cc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a> := <span class=\"fn\">{ }</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L175-L180","name":"Mathlib.Tactic.CC.CCState.foldEqcM","line":175,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.foldEqcM","doc":"Fold the monadic function of `f` over the equivalence class of `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.foldEqcM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">foldEqcM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L171-L173","name":"Mathlib.Tactic.CC.CCState.foldEqc","line":171,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.foldEqc","doc":"Fold the function of `f` over the equivalence class of `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.foldEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">foldEqc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L161-L169","name":"Mathlib.Tactic.CC.CCState.foldEqcCore","line":161,"kind":"opaque","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.foldEqcCore","doc":"Fold `f` over the equivalence class of `c`, accumulating the result in `a`.\nLoops until the element `first` is encountered.\n\nSee `foldEqc` for folding `f` over all elements of the equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.foldEqcCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">foldEqcCore</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">first </span><span class=\"fn\">c</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L157-L159","name":"Mathlib.Tactic.CC.CCState.eqcSize","line":157,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqcSize","doc":"The size of the equivalence class of `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqcSize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">eqcSize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L153-L155","name":"Mathlib.Tactic.CC.CCState.eqcOf","line":153,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqcOf","doc":"The equivalence class of `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqcOf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">eqcOf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L147-L151","name":"Mathlib.Tactic.CC.CCState.eqcOfCore","line":147,"kind":"opaque","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqcOfCore","doc":"Continue to append following expressions in the equivalence class of `e` to `r` until `f` is\nfound. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqcOfCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">eqcOfCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">f</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L144-L145","name":"Mathlib.Tactic.CC.CCState.instToMessageData","line":144,"kind":"instance","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.instToMessageData","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.instToMessageData\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">instToMessageData</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L140-L142","name":"Mathlib.Tactic.CC.CCState.roots","line":140,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.roots","doc":"The root expressions for each equivalence class in the graph. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.roots\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">roots</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L136-L138","name":"Mathlib.Tactic.CC.CCState.mkUsingHs","line":136,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkUsingHs","doc":"Create a congruence closure state object using the hypotheses in the current goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkUsingHs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mkUsingHs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L130-L134","name":"Mathlib.Tactic.CC.CCState.proofForFalse","line":130,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.proofForFalse","doc":"If the given state is inconsistent, return a proof for `False`. Otherwise fail. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.proofForFalse\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">proofForFalse</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L123-L128","name":"Mathlib.Tactic.CC.CCState.refutationFor","line":123,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.refutationFor","doc":"`refutationFor cc e` constructs a proof for `Not e` if it is equivalent to `False` in `CCState`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.refutationFor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">refutationFor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L117-L121","name":"Mathlib.Tactic.CC.CCState.proofFor","line":117,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.proofFor","doc":"`proofFor cc e` constructs a proof for e if it is equivalent to true in `CCState` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.proofFor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">proofFor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L111-L115","name":"Mathlib.Tactic.CC.CCState.eqvProof","line":111,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqvProof","doc":"Returns a proof term that the given terms are equivalent in the given `CCState` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqvProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">eqvProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L106-L109","name":"Mathlib.Tactic.CC.CCState.isNotEqv","line":106,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.isNotEqv","doc":"Check whether two expressions are not in the same equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.isNotEqv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">isNotEqv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L101-L104","name":"Mathlib.Tactic.CC.CCState.isEqv","line":101,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.isEqv","doc":"Check whether two expressions are in the same equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.isEqv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">isEqv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L92-L99","name":"Mathlib.Tactic.CC.CCState.add","line":92,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.add","doc":"Add the given proof term as a new rule.\nThe proof term `H` must be an `Eq _ _`, `HEq _ _`, `Iff _ _`, or a negation of these. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L87-L90","name":"Mathlib.Tactic.CC.CCState.internalize","line":87,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.internalize","doc":"Add the given expression to the graph. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.internalize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">internalize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L83-L85","name":"Mathlib.Tactic.CC.CCState.incGMT","line":83,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.incGMT","doc":"Increment the Global Modification time. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.incGMT\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">incGMT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L78-L81","name":"Mathlib.Tactic.CC.CCState.rootsCore","line":78,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.rootsCore","doc":"Returns the root expression for each equivalence class in the graph.\nIf the `Bool` argument is set to `true` then it only returns roots of non-singleton classes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.rootsCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">rootsCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nonsingleton</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L67-L76","name":"Mathlib.Tactic.CC.CCState.mkUsingHsCore","line":67,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkUsingHsCore","doc":"Create a congruence closure state object from the given `config` using the hypotheses in the\ncurrent goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkUsingHsCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mkUsingHsCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC.lean#L62-L65","name":"Mathlib.Tactic.CC.CCState.mkCore","line":62,"kind":"def","docLink":"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkCore","doc":"Make an new `CCState` from the given `config`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mkCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></div></div>"}]}