{"name":"Mathlib.Tactic.Abel","instances":[{"typeNames":["Mathlib.Tactic.Abel.NormalExpr"],"name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.Abel.NormalExpr","Lean.Expr"],"name":"Mathlib.Tactic.Abel.instCoeNormalExprExpr","className":"Coe"}],"imports":["Init","Mathlib.Tactic.NormNum.Basic","Mathlib.Tactic.TryThis","Mathlib.Util.AtomM"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L564-L565","name":"Mathlib.Tactic.Abel.convAbel!","line":564,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!","doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">convAbel!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L561-L562","name":"Mathlib.Tactic.Abel.abelConv","line":561,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv","doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L558-L558","name":"Mathlib.Tactic.Abel.tacticAbel!","line":558,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!","doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">tacticAbel!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L551-L551","name":"Mathlib.Tactic.Abel.convAbel_nf!_","line":551,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_","doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">convAbel_nf!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L541-L548","name":"Mathlib.Tactic.Abel.elabAbelNFConv","line":541,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv","doc":"Elaborator for the `abel_nf` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">elabAbelNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L538-L539","name":"Mathlib.Tactic.Abel.abelNFConv","line":538,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv","doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L535-L536","name":"Mathlib.Tactic.Abel.tacticAbel_nf!__","line":535,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__","doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">tacticAbel_nf!__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L525-L532","name":"Mathlib.Tactic.Abel.abelNF","line":525,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF","doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L514-L523","name":"Mathlib.Tactic.Abel.abelNFLocalDecl","line":514,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFLocalDecl","doc":"Use `abel_nf` to rewrite hypothesis `h`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFLocalDecl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFLocalDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L502-L512","name":"Mathlib.Tactic.Abel.abelNFTarget","line":502,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFTarget","doc":"Use `abel_nf` to rewrite the main goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFTarget\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFTarget</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L498-L498","name":"Mathlib.Tactic.Abel.abelNFCore.evalAtom","line":498,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.evalAtom","doc":"The `evalAtom` implementation passed to `eval` calls `go` if `cfg.recursive` is true,\nand does nothing otherwise. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFCore</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">simp</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx</span> : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L482-L495","name":"Mathlib.Tactic.Abel.abelNFCore.go","line":482,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go","doc":"The recursive case of `abelNF`.\n* `root`: true when the function is called directly from `abelNFCore`\n  and false when called by `evalAtom` in recursive mode.\n* `parent`: The input expression to simplify. In `pre` we make use of both `parent` and `e`\n  to determine if we are at the top level in order to prevent a loop\n  `go -> eval -> evalAtom -> go` which makes no progress.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFCore</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">simp</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx</span> : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">root</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parent</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L452-L499","name":"Mathlib.Tactic.Abel.abelNFCore","line":452,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore","doc":"The core of `abel_nf`, which rewrites the expression `e` into `abel` normal form.\n\n* `s`: a reference to the mutable state of `abel`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `e`: the expression to rewrite\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L449-L450","name":"Mathlib.Tactic.Abel.elabAbelNFConfig","line":449,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig","doc":"Function elaborating `AbelNF.Config`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">elabAbelNFConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">AbelNF.Config</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L447-L447","name":"Mathlib.Tactic.Abel.AbelNF.Config.mode","line":447,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mode","doc":"The normalization style. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mode</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">AbelMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L445-L445","name":"Mathlib.Tactic.Abel.AbelNF.Config.recursive","line":445,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive","doc":"if true, atoms inside ring expressions will be reduced recursively "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">recursive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L443-L443","name":"Mathlib.Tactic.Abel.AbelNF.Config.zetaDelta","line":443,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.zetaDelta","doc":"if true, local let variables can be unfolded "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.zetaDelta\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">zetaDelta</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L441-L441","name":"Mathlib.Tactic.Abel.AbelNF.Config.red","line":441,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red","doc":"the reducibility setting to use when comparing atoms for defeq "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">red</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L439-L439","name":"Mathlib.Tactic.Abel.AbelNF.Config.mk","line":439,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">red</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">zetaDelta </span><span class=\"fn\">recursive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mode</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">AbelMode</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L438-L447","name":"Mathlib.Tactic.Abel.AbelNF.Config","line":438,"kind":"structure","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config","doc":"Configuration for `abel_nf`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L435-L436","name":"Mathlib.Tactic.Abel.AbelMode.raw","line":435,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.raw","doc":"Raw form: the representation `abel` uses internally. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span>.<span class=\"name\">raw</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">AbelMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L433-L434","name":"Mathlib.Tactic.Abel.AbelMode.term","line":433,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.term","doc":"The default form "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span>.<span class=\"name\">term</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">AbelMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L431-L436","name":"Mathlib.Tactic.Abel.AbelMode","line":431,"kind":"inductive","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode","doc":"The normalization style for `abel_nf`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L426-L429","name":"Mathlib.Tactic.Abel.NormalExpr.isAtom","line":426,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom","doc":"True if this represents an atomic expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">isAtom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L423-L424","name":"Mathlib.Tactic.Abel.termg_eq","line":423,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">termg_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L422-L422","name":"Mathlib.Tactic.Abel.term_eq","line":422,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L420-L420","name":"Mathlib.Tactic.Abel.abel1!","line":420,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!","doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel1!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L402-L417","name":"Mathlib.Tactic.Abel.abel1","line":402,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1","doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L354-L398","name":"Mathlib.Tactic.Abel.eval","line":354,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval","doc":"Evaluate an expression into its `abel` normal form, by recursing into subexpressions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">eval</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L324-L352","name":"Mathlib.Tactic.Abel.evalSMul'","line":324,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'","doc":"Normalize a term `orig` of the form `smul e₁ e₂` or `smulg e₁ e₂`.\nNormalized terms use `smul` for monoids and `smulg` for groups,\nso there are actually four cases to handle:\n* Using `smul` in a monoid just simplifies the pieces using `subst_into_smul`\n* Using `smulg` in a group just simplifies the pieces using `subst_into_smulg`\n* Using `smul a b` in a group requires converting `a` from a nat to an int and\n  then simplifying `smulg ↑a b` using `subst_into_smul_upcast`\n* Using `smulg` in a monoid is impossible (or at least out of scope),\n  because you need a group argument to write a `smulg` term "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalSMul'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eval</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">is_smulg</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">orig </span><span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L320-L322","name":"Mathlib.Tactic.Abel.subst_into_negg","line":320,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_negg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">ta </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pra</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">ta</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">ta</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L316-L318","name":"Mathlib.Tactic.Abel.subst_into_addg","line":316,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_addg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l </span><span class=\"fn\">r </span><span class=\"fn\">tl </span><span class=\"fn\">tr </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prr</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <span class=\"fn\">tl</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">tr</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L312-L314","name":"Mathlib.Tactic.Abel.subst_into_add","line":312,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l </span><span class=\"fn\">r </span><span class=\"fn\">tl </span><span class=\"fn\">tr </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prr</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <span class=\"fn\">tl</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">tr</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L307-L310","name":"Mathlib.Tactic.Abel.subst_into_smul_upcast","line":307,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smul_upcast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tl</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">zl</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tr </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl₁</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl₂</span> : <span class=\"fn\">↑<span class=\"fn\">tl</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">zl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prr</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">zl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L303-L305","name":"Mathlib.Tactic.Abel.subst_into_smulg","line":303,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tl</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tr </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prr</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">tl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L299-L301","name":"Mathlib.Tactic.Abel.subst_into_smul","line":299,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tl</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tr </span><span class=\"fn\">t</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prl</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prr</span> : <span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prt</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">tl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L296-L297","name":"Mathlib.Tactic.Abel.unfold_zsmul","line":296,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_zsmul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L293-L294","name":"Mathlib.Tactic.Abel.unfold_smulg","line":293,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L290-L291","name":"Mathlib.Tactic.Abel.unfold_smul","line":290,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L287-L288","name":"Mathlib.Tactic.Abel.unfold_sub","line":287,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_sub</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#SubtractionMonoid\">SubtractionMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L278-L285","name":"Mathlib.Tactic.Abel.evalAtom","line":278,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom","doc":"Interpret an expression as an atom for `abel`'s normal form. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L275-L276","name":"Mathlib.Tactic.Abel.term_atom_pfg","line":275,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom_pfg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">x'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">1</span> <span class=\"fn\">x'</span> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L273-L274","name":"Mathlib.Tactic.Abel.term_atom_pf","line":273,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">x'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">1</span> <span class=\"fn\">x'</span> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L272-L272","name":"Mathlib.Tactic.Abel.term_atomg","line":272,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atomg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">1</span> <span class=\"fn\">x</span> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L271-L271","name":"Mathlib.Tactic.Abel.term_atom","line":271,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">1</span> <span class=\"fn\">x</span> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L260-L269","name":"Mathlib.Tactic.Abel.evalSMul","line":260,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul","doc":"Auxiliary function for `evalSMul'`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalSMul</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L255-L258","name":"Mathlib.Tactic.Abel.term_smulg","line":255,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c </span><span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L250-L253","name":"Mathlib.Tactic.Abel.term_smul","line":250,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c </span><span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">c</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">c</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L247-L248","name":"Mathlib.Tactic.Abel.zero_smulg","line":247,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L244-L245","name":"Mathlib.Tactic.Abel.zero_smul","line":244,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">smul</a> <span class=\"fn\">c</span> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L241-L242","name":"Mathlib.Tactic.Abel.smulg","line":241,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg","doc":"A synonym for `•`, used internally in `abel`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L239-L240","name":"Mathlib.Tactic.Abel.smul","line":239,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul","doc":"A synonym for `•`, used internally in `abel`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L226-L237","name":"Mathlib.Tactic.Abel.evalNeg","line":226,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg","doc":"Interpret a negated expression in `abel`'s normal form.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalNeg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L222-L224","name":"Mathlib.Tactic.Abel.term_neg","line":222,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L194-L220","name":"Mathlib.Tactic.Abel.evalAdd","line":194,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd","doc":"Interpret the sum of two expressions in `abel`'s normal form.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalAdd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> (<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L191-L192","name":"Mathlib.Tactic.Abel.zero_termg","line":191,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">0</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L188-L189","name":"Mathlib.Tactic.Abel.zero_term","line":188,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">0</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L182-L186","name":"Mathlib.Tactic.Abel.term_add_termg","line":182,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n₁</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a₁</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n₂</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\">n₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">n₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n₁</span> <span class=\"fn\">x</span> <span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n₂</span> <span class=\"fn\">x</span> <span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L178-L180","name":"Mathlib.Tactic.Abel.term_add_term","line":178,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n₁</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a₁</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\">n₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">n₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n₁</span> <span class=\"fn\">x</span> <span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n₂</span> <span class=\"fn\">x</span> <span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L174-L176","name":"Mathlib.Tactic.Abel.term_add_constg","line":174,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_constg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a </span><span class=\"fn\">k </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L170-L172","name":"Mathlib.Tactic.Abel.term_add_const","line":170,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_const</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a </span><span class=\"fn\">k </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L166-L168","name":"Mathlib.Tactic.Abel.const_add_termg","line":166,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">const_add_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L162-L164","name":"Mathlib.Tactic.Abel.const_add_term","line":162,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">const_add_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L157-L158","name":"Mathlib.Tactic.Abel.NormalExpr.zero'","line":157,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'","doc":"Construct the normal form representing zero. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">zero'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L153-L155","name":"Mathlib.Tactic.Abel.NormalExpr.term'","line":153,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'","doc":"Construct the normal form representing a single term. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">term'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L151-L151","name":"Mathlib.Tactic.Abel.instCoeNormalExprExpr","line":151,"kind":"instance","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">instCoeNormalExprExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L146-L149","name":"Mathlib.Tactic.Abel.NormalExpr.e","line":146,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e","doc":"Extract the expression from a normal form. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">e</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L144-L144","name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr","line":144,"kind":"instance","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">instInhabitedNormalExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L143-L143","name":"Mathlib.Tactic.Abel.NormalExpr.nterm","line":143,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">nterm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L142-L142","name":"Mathlib.Tactic.Abel.NormalExpr.zero","line":142,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">zero</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">NormalExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L136-L144","name":"Mathlib.Tactic.Abel.NormalExpr","line":136,"kind":"inductive","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr","doc":"A normal form for `abel`.\nExpressions are represented as a list of terms of the form `e = n • x`,\nwhere `n : ℤ` and `x` is an arbitrary element of the additive commutative monoid or group.\nWe explicitly track the `Expr` forms of `e` and `n`, even though they could be reconstructed,\nfor efficiency. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L132-L134","name":"Mathlib.Tactic.Abel.intToExpr","line":132,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr","doc":"Interpret an integer as a coefficient to a term. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">intToExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L129-L130","name":"Mathlib.Tactic.Abel.mkTerm","line":129,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm","doc":"Evaluate a term with coefficient `n`, atom `x` and successor terms `a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">mkTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">x </span><span class=\"fn\">a</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L126-L127","name":"Mathlib.Tactic.Abel.termg","line":126,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L124-L125","name":"Mathlib.Tactic.Abel.term","line":124,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative monoid. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L116-L122","name":"Mathlib.Tactic.Abel.iapp","line":116,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp","doc":"Apply the function `n : ∀ {α} [AddComm{Monoid,Group} α]` to the given list of arguments.\n\nWill use the `AddComm{Monoid,Group}` instance that has been cached in the context.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">iapp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L107-L114","name":"Mathlib.Tactic.Abel.addG","line":107,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG","doc":"Add the letter \"g\" to the end of the name, e.g. turning `term` into `termg`.\n\nThis is used to choose between declarations taking `AddCommMonoid` and those\ntaking `AddCommGroup` instances.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">addG</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L98-L105","name":"Mathlib.Tactic.Abel.Context.mkApp","line":98,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp","doc":"Apply the function `n : ∀ {α} [inst α], _` to the implicit parameters in the\ncontext, and the given list of arguments.\n\nCompared to `context.app`, this takes the name of the typeclass, rather than an\ninferred typeclass instance.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">mkApp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">inst</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L93-L96","name":"Mathlib.Tactic.Abel.Context.app","line":93,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app","doc":"Apply the function `n : ∀ {α} [inst : AddWhatever α], _` to the\nimplicit parameters in the context, and the given list of arguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L88-L91","name":"Mathlib.Tactic.Abel.M","line":88,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M","doc":"The monad for `Abel` contains, in addition to the `AtomM` state,\nsome information about the current type we are working over, so that we can consistently\nuse group lemmas or monoid lemmas as appropriate. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">M</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L76-L86","name":"Mathlib.Tactic.Abel.mkContext","line":76,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext","doc":"Populate a `context` object for evaluating `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">mkContext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L74-L74","name":"Mathlib.Tactic.Abel.Context.inst","line":74,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.inst","doc":"The `AddCommGroup α` or `AddCommMonoid α` expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.inst\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">inst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L72-L72","name":"Mathlib.Tactic.Abel.Context.isGroup","line":72,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup","doc":"Specify whether we are in an additive commutative group or an additive commutative monoid. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">isGroup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L70-L70","name":"Mathlib.Tactic.Abel.Context.α0","line":70,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α0","doc":"The expression representing `0 : α`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α0\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">α0</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L68-L68","name":"Mathlib.Tactic.Abel.Context.univ","line":68,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ","doc":"The universe level for `α`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">univ</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L66-L66","name":"Mathlib.Tactic.Abel.Context.α","line":66,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α","doc":"The type of the ambient additive commutative group or monoid. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">α</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L64-L64","name":"Mathlib.Tactic.Abel.Context.mk","line":64,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">univ</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α0</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isGroup</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Context</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L59-L74","name":"Mathlib.Tactic.Abel.Context","line":59,"kind":"structure","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context","doc":"The `Context` for a call to `abel`.\n\nStores a few options for this call, and caches some common subexpressions\nsuch as typeclass instances and `0 : α`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Abel.lean#L26-L57","name":"Mathlib.Tactic.Abel.abel","line":26,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel","doc":"Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" <|> &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}