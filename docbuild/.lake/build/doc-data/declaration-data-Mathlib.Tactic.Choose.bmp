{"name":"Mathlib.Tactic.Choose","instances":[],"imports":["Init","Mathlib.Util.Tactic","Mathlib.Logic.Function.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L219-L220","name":"Mathlib.Tactic.Choose.tacticChoose!___Using_","line":219,"kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.tacticChoose!___Using_","doc":"* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b`\n  for some `P Q : X → Y → A → B → Prop` and outputs\n  into context a function `a : X → Y → A`, `b : X → Y → B` and two assumptions:\n  `h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X → A`, `b : X → B`, and the assumptions\n  `h : ∀ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be omitted,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nExamples:\n\n```\nexample (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ℕ → ℕ → ℕ\n  guard_hyp j : ℕ → ℕ → ℕ\n  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : ∀ i : ℕ, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ℕ → ℕ\n  guard_hyp h : ∀ (i : ℕ), i < 7 → i < f i\n  guard_hyp h' : ∀ (i : ℕ), i < 7 → f i < i + i\n  trivial\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.tacticChoose!___Using_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">tacticChoose!___Using_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L174-L212","name":"Mathlib.Tactic.Choose.choose","line":174,"kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose","doc":"* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b`\n  for some `P Q : X → Y → A → B → Prop` and outputs\n  into context a function `a : X → Y → A`, `b : X → Y → B` and two assumptions:\n  `h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X → A`, `b : X → B`, and the assumptions\n  `h : ∀ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be omitted,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nExamples:\n\n```\nexample (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ℕ → ℕ → ℕ\n  guard_hyp j : ℕ → ℕ → ℕ\n  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n\n  trivial\n```\n\n```\nexample (h : ∀ i : ℕ, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ℕ → ℕ\n  guard_hyp h : ∀ (i : ℕ), i < 7 → i < f i\n  guard_hyp h' : ∀ (i : ℕ), i < 7 → f i < i + i\n  trivial\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">choose</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L153-L172","name":"Mathlib.Tactic.Choose.elabChoose","line":153,"kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.elabChoose","doc":"A loop around `choose1`. The main entry point for the `choose` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.elabChoose\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">elabChoose</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nondep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L145-L151","name":"Mathlib.Tactic.Choose.choose1WithInfo","line":145,"kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1WithInfo","doc":"A wrapper around `choose1` that parses identifiers and adds variable info to new variables. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1WithInfo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">choose1WithInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nondep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">data</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L68-L143","name":"Mathlib.Tactic.Choose.choose1","line":68,"kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1","doc":"Changes `(h : ∀xs, ∃a:α, p a) ⊢ g` to `(d : ∀xs, a) ⊢ (s : ∀xs, p (d xs)) → g` and\n`(h : ∀xs, p xs ∧ q xs) ⊢ g` to `(d : ∀xs, p xs) ⊢ (s : ∀xs, q xs) → g`.\n`choose1` returns a tuple of\n\n- the error result (see `ElimStatus`)\n- the data new free variable that was \"chosen\"\n- the new goal (which contains the spec of the data as domain of an arrow type)\n\nIf `nondep` is true and `α` is inhabited, then it will remove the dependency of `d` on\nall propositional assumptions in `xs`. For example if `ys` are propositions then\n`(h : ∀xs ys, ∃a:α, p a) ⊢ g` becomes `(d : ∀xs, a) (s : ∀xs ys, p (d xs)) ⊢ g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">choose1</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nondep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">data</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L63-L66","name":"Mathlib.Tactic.Choose.mkFreshNameFrom","line":63,"kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mkFreshNameFrom","doc":"`mkFreshNameFrom orig base` returns `mkFreshUserName base` if ``orig = `_``\nand `orig` otherwise. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mkFreshNameFrom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">mkFreshNameFrom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">orig </span><span class=\"fn\">base</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L56-L61","name":"Mathlib.Tactic.Choose.ElimStatus.merge","line":56,"kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.merge","doc":"Combine two statuses, keeping a success from either side\nor merging the failures. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.merge\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span>.<span class=\"name\">merge</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> → <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a> → <a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L54-L54","name":"Mathlib.Tactic.Choose.ElimStatus.failure","line":54,"kind":"ctor","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.failure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.failure\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span>.<span class=\"name\">failure</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L53-L53","name":"Mathlib.Tactic.Choose.ElimStatus.success","line":53,"kind":"ctor","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.success","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus.success\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span>.<span class=\"name\">success</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\">ElimStatus</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L42-L54","name":"Mathlib.Tactic.Choose.ElimStatus","line":42,"kind":"inductive","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus","doc":"Results of searching for nonempty instances,\nto eliminate dependencies on propositions (`choose!`).\n`success` means we found at least one instance;\n`failure ts` means we didn't find instances for any `t ∈ ts`.\n(`failure []` means we didn't look for instances at all.)\n\nRationale:\n`choose!` means we are expected to succeed at least once\nin eliminating dependencies on propositions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.ElimStatus\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">ElimStatus</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Choose.lean#L22-L40","name":"Mathlib.Tactic.Choose.mk_sometimes","line":22,"kind":"def","docLink":"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mk_sometimes","doc":"Given `α : Sort u`, `nonemp : Nonempty α`, `p : α → Prop`, a context of free variables\n`ctx`, and a pair of an element `val : α` and `spec : p val`,\n`mk_sometimes u α nonemp p ctx (val, spec)` produces another pair `val', spec'`\nsuch that `val'` does not have any free variables from elements of `ctx` whose types are\npropositions. This is done by applying `Function.sometimes` to abstract over all the propositional\narguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.mk_sometimes\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Choose</span>.<span class=\"name\">mk_sometimes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α </span><span class=\"fn\">nonemp </span><span class=\"fn\">p</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></span></div></div>"}]}