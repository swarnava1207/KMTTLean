{"name":"ProofWidgets.Component.OfRpcMethod","instances":[],"imports":["Init","Lean.Elab.ElabRules","ProofWidgets.Component.Basic","ProofWidgets.Data.Html","ProofWidgets.Cancellable"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/ProofWidgets4/blob/ea953247aac573c9b5adea60bacd3e085f58aca4/ProofWidgets/Component/OfRpcMethod.lean#L11-L88","name":"ProofWidgets.¬´termMk_rpc_widget%_¬ª","line":11,"kind":"def","docLink":"./ProofWidgets/Component/OfRpcMethod.html#ProofWidgets.¬´termMk_rpc_widget%_¬ª","doc":"The elaborator `mk_rpc_widget%` allows writing certain widgets in Lean instead of JavaScript.\nSpecifically, it translates an RPC method of type `MyProps ‚Üí RequestM (RequestTask Html)`\ninto a widget component of type `Component MyProps`.\n\nEven more specifically, we can write:\n```lean\nopen Lean Server\n\nstructure MyProps where\n  ...\n  deriving RpcEncodable\n\n@[server_rpc_method]\ndef MyComponent.rpc (ps : MyProps) : RequestM (RequestTask Html) :=\n  ...\n\n@[widget_module]\ndef MyComponent : Component MyProps :=\n  mk_rpc_widget% MyComponent.rpc\n```\n\nThis is convenient because we can program the logic that computes an output HTML tree\ngiven input props in Lean directly.\n\n‚ö†Ô∏è However, note that there are several limitations on what such component can do\ncompared to ones written natively in TypeScript or JavaScript:\n- It must be pure, i.e. cannot directly store any React state.\n  Child components may store state as usual.\n- It cannot pass closures as props to the child components that it returns.\n  For example, it is not currently possible to write click event handlers in Lean\n  and pass them to a `<button onClick={..}>` child.\n- Every time the input props change, the infoview has to send a message to the Lean server\n  in order to invoke the RPC method.\n  Thus there can be a noticeable visual delay between the input props changing\n  and the display updating.\n  Consequently, components whose props change at a high frequency\n  (e.g. depending on the mouse position)\n  should not be implemented using this method.\n\nüí° Note that an inverse transformation is already possible.\nGiven `MyComponent : Component MyProps`, we can write:\n```lean\nopen Lean Server\n\n@[server_rpc_method]\ndef MyComponent.rpc (ps : MyProps) : RequestM (RequestTask Html) :=\n  RequestM.asTask do\n    return Html.ofComponent MyComponent ps #[]\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./ProofWidgets/Component/OfRpcMethod.html#ProofWidgets.¬´termMk_rpc_widget%_¬ª\"><span class=\"name\">ProofWidgets</span>.<span class=\"name\">¬´termMk_rpc_widget%_¬ª</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/ProofWidgets4/blob/ea953247aac573c9b5adea60bacd3e085f58aca4/ProofWidgets/Component/OfRpcMethod.lean#L9-L9","name":"ProofWidgets.ofRpcMethodTemplate","line":9,"kind":"def","docLink":"./ProofWidgets/Component/OfRpcMethod.html#ProofWidgets.ofRpcMethodTemplate","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./ProofWidgets/Component/OfRpcMethod.html#ProofWidgets.ofRpcMethodTemplate\"><span class=\"name\">ProofWidgets</span>.<span class=\"name\">ofRpcMethodTemplate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"}]}