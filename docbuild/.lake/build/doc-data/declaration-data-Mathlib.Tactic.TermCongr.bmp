{"name":"Mathlib.Tactic.TermCongr","instances":[],"imports":["Init","Mathlib.Lean.Expr.Basic","Mathlib.Lean.Meta.CongrTheorems","Mathlib.Logic.Basic","Mathlib.Tactic.CongrExclamation"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L606-L640","name":"Mathlib.Tactic.TermCongr.elabTermCongr","line":606,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elabTermCongr","doc":"`congr(expr)` generates a congruence from an expression containing\ncongruence holes of the form `$h` or `$(h)`.\nIn these congruence holes, `h : a = b` indicates that, in the generated congruence,\non the left-hand side `a` is substituted for `$h`\nand on the right-hand side `b` is substituted for `$h`.\n\nFor example, if `h : a = b` then `congr(1 + $h) : 1 + a = 1 + b`.\n\nThis is able to make use of the expected type, for example `(congr(_ + $h) : 1 + _ = _)`\nwith `h : x = y` gives `1 + x = 1 + y`.\nThe expected type can be an `Iff`, `Eq`, or `HEq`.\nIf there is no expected type, then it generates an equality.\n\nNote: the process of generating a congruence lemma involves elaborating the pattern\nusing terms with attached metadata and a reducible wrapper.\nWe try to avoid doing so, but these terms can leak into the local context through unification.\nThis can potentially break tactics that are sensitive to metadata or reducible functions.\nPlease report anything that goes wrong with `congr(...)` lemmas on Zulip.\n\nFor debugging, you can set `set_option trace.Elab.congr true`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elabTermCongr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">elabTermCongr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElab\">Lean.Elab.Term.TermElab</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L451-L602","name":"Mathlib.Tactic.TermCongr.mkCongrOf","line":451,"kind":"opaque","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOf","doc":"Walks along both `lhs` and `rhs` simultaneously to create a congruence lemma between them.\n\nWhere they are desynchronized, we fall back to the base case (using `CongrResult.mkDefault'`)\nsince it's likely due to unification with the expected type,\nfrom `_` placeholders or implicit arguments being filled in. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">mkCongrOf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">depth </span><span class=\"fn\">mvarCounterSaved</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L423-L449","name":"Mathlib.Tactic.TermCongr.mkCongrOfCHole?","line":423,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOfCHole?","doc":"If `lhs` or `rhs` is a congruence hole, then process it.\nOnly process ones that are at least as new as `mvarCounterSaved`\nsince nothing prevents congruence holes from leaking into the local context. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOfCHole?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">mkCongrOfCHole?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarCounterSaved</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L418-L421","name":"Mathlib.Tactic.TermCongr.throwCongrEx","line":418,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.throwCongrEx","doc":"Throw an internal error. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.throwCongrEx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">throwCongrEx</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">msg</span> : <a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L410-L416","name":"Mathlib.Tactic.TermCongr.CongrResult.mkDefault'","line":410,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mkDefault'","doc":"Does `CongrResult.mkDefault` but makes sure there are no lingering congruence holes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mkDefault'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">mkDefault'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarCounterSaved</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L392-L408","name":"Mathlib.Tactic.TermCongr.CongrResult.mkDefault","line":392,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mkDefault","doc":"Tries to make a congruence between `lhs` and `rhs` automatically.\n1. If they are defeq, returns a trivial congruence.\n2. Tries using `Subsingleton.elim`.\n3. Tries `proof_irrel_heq` as another effort to avoid doing congruence on proofs.\n3. Otherwise throws an error.\n\nNote: `mkAppM` uses `withNewMCtxDepth`, which prevents typeclass inference\nfrom accidentally specializing `Sort _` to `Prop`, which could otherwise happen\nbecause there is a `Subsingleton Prop` instance. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mkDefault\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">mkDefault</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L379-L390","name":"Mathlib.Tactic.TermCongr.CongrResult.defeq","line":379,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.defeq","doc":"Force the lhs and rhs to be defeq. For when `dsimp`-like congruence is necessary.\nClears the proof. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.defeq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">defeq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">res</span> : <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L367-L377","name":"Mathlib.Tactic.TermCongr.CongrResult.mk'.ensureSidesDefeq","line":367,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk'.ensureSidesDefeq","doc":"Get the sides of the type of `pf` and unify them with the respective `lhs` and `rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk'.ensureSidesDefeq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">mk'</span>.<span class=\"name\">ensureSidesDefeq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs </span><span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L353-L365","name":"Mathlib.Tactic.TermCongr.CongrResult.mk'.toHEqPf","line":353,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk'.toHEqPf","doc":"Given a `pf` of an `Iff`, `Eq`, or `HEq`, return a proof of `HEq`.\nIf `pf` is not obviously any of these, weakly try making it be an `Eq` or an `Iff`,\nand otherwise make it be a `HEq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk'.toHEqPf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">mk'</span>.<span class=\"name\">toHEqPf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs </span><span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L335-L349","name":"Mathlib.Tactic.TermCongr.CongrResult.mk'.toEqPf","line":335,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk'.toEqPf","doc":"Given a `pf` of an `Iff`, `Eq`, or `HEq`, return a proof of `Eq`.\nIf `pf` is not obviously any of these, weakly try inserting `propext` to make an `Iff`\nand otherwise unify the type with `Eq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk'.toEqPf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">mk'</span>.<span class=\"name\">toEqPf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L320-L377","name":"Mathlib.Tactic.TermCongr.CongrResult.mk'","line":320,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk'","doc":"Make a `CongrResult` from a LHS, a RHS, and a proof of an Iff, Eq, or HEq.\nThe proof is allowed to have a metavariable for its type.\nValidates the inputs and throws errors in the `pf?` function.\n\nThe `pf?` function is responsible for finally unifying the type of `pf` with `lhs` and `rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">mk'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs </span><span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L304-L318","name":"Mathlib.Tactic.TermCongr.CongrResult.trans","line":304,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.trans","doc":"Combine two congruence proofs using transitivity.\nDoes not check that `res1.rhs` is defeq to `res2.lhs`.\nIf both `res1` and `res2` are trivial then the result is trivial. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.trans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">trans</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">res1 </span><span class=\"fn\">res2</span> : <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L298-L302","name":"Mathlib.Tactic.TermCongr.CongrResult.iff","line":298,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.iff","doc":"Returns a proof of `lhs ↔ rhs`. Uses `CongrResult.eq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.iff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">iff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">res</span> : <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L291-L296","name":"Mathlib.Tactic.TermCongr.CongrResult.heq","line":291,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.heq","doc":"Returns the proof that `HEq lhs rhs`. Fails if the `CongrResult` is inapplicable.\nIf `pf? = none`, this returns the `rfl` proof. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.heq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">heq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">res</span> : <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L280-L289","name":"Mathlib.Tactic.TermCongr.CongrResult.eq","line":280,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.eq","doc":"Returns the proof that `lhs = rhs`. Fails if the `CongrResult` is inapplicable.\nThrows an error if the `lhs` and `rhs` have non-defeq types.\nIf `pf? = none`, this returns the `rfl` proof. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">res</span> : <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L276-L278","name":"Mathlib.Tactic.TermCongr.CongrResult.isRfl","line":276,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.isRfl","doc":"Returns whether the proof is by reflexivity.\nSuch congruence proofs are trivial. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.isRfl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">isRfl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">res</span> : <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L274-L274","name":"Mathlib.Tactic.TermCongr.CongrResult.pf?","line":274,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.pf?","doc":"A generator for an `Eq lhs rhs` or `HEq lhs rhs` proof.\nIf such a proof is impossible, the generator can throw an error.\nThe inferred type of the generated proof needs only be defeq to `Eq lhs rhs` or `HEq lhs rhs`.\nThis function can assign metavariables when constructing the proof.\n\nIf `pf? = none`, then `lhs` and `rhs` are defeq, and the proof is by reflexivity. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.pf?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">pf?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType\">CongrType</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L267-L267","name":"Mathlib.Tactic.TermCongr.CongrResult.rhs","line":267,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs","doc":"The right-hand side of the congruence result. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">rhs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L265-L265","name":"Mathlib.Tactic.TermCongr.CongrResult.lhs","line":265,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs","doc":"The left-hand side of the congruence result. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">lhs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L263-L263","name":"Mathlib.Tactic.TermCongr.CongrResult.mk","line":263,"kind":"ctor","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType\">CongrType</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\">CongrResult</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L248-L274","name":"Mathlib.Tactic.TermCongr.CongrResult","line":248,"kind":"structure","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult","doc":"A congruence lemma between two expressions.\nThe proof is generated dynamically, depending on whether the resulting lemma should be\nan `Eq` or a `HEq`.\nIf generating a proof impossible, then the generator can throw an error.\nThis can be due to either an `Eq` proof being impossible\nor due to the lhs/rhs not being defeq to the lhs/rhs of the generated proof,\nwhich can happen for user-supplied congruence holes.\n\nThis complexity is to support two features:\n\n1. The user is free to supply Iff, Eq, and HEq lemmas in congurence holes,\n   and we're able to transform them into whatever is appropriate for a\n   given congruence lemma.\n2. If the congrence hole is a metavariable, then we can specialize that\n   hole to an Iff, Eq, or HEq depending on what's necessary at that site. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrResult</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L246-L246","name":"Mathlib.Tactic.TermCongr.CongrType.heq","line":246,"kind":"ctor","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType.heq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType.heq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrType</span>.<span class=\"name\">heq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType\">CongrType</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L246-L246","name":"Mathlib.Tactic.TermCongr.CongrType.eq","line":246,"kind":"ctor","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType.eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrType</span>.<span class=\"name\">eq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType\">CongrType</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L244-L246","name":"Mathlib.Tactic.TermCongr.CongrType","line":244,"kind":"inductive","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType","doc":"A request for a type of congruence lemma from a `CongrResult`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">CongrType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L239-L242","name":"Mathlib.Tactic.TermCongr.ensureIff","line":239,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.ensureIff","doc":"Make sure that the expected type of `pf` is an iff by unification. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.ensureIff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">ensureIff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L228-L237","name":"Mathlib.Tactic.TermCongr.mkIffForExpectedType","line":228,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkIffForExpectedType","doc":"Ensures the expected type is an iff. Returns the iff.\nThis expression satisfies `Lean.Expr.iff?`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkIffForExpectedType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">mkIffForExpectedType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L216-L226","name":"Mathlib.Tactic.TermCongr.mkHEqForExpectedType","line":216,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkHEqForExpectedType","doc":"Ensures the expected type is a HEq. Returns the HEq.\nThis expression satisfies `Lean.Expr.heq?`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkHEqForExpectedType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">mkHEqForExpectedType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L205-L214","name":"Mathlib.Tactic.TermCongr.mkEqForExpectedType","line":205,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkEqForExpectedType","doc":"Ensures the expected type is an equality. Returns the equality.\nThe returned expression satisfies `Lean.Expr.eq?`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkEqForExpectedType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">mkEqForExpectedType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L194-L201","name":"Mathlib.Tactic.TermCongr.elaboratePattern","line":194,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elaboratePattern","doc":"Given the pattern `t` in `congr(t)`, elaborate it for the given side\nby replacing antiquotations with `cHole%` terms, and ensure the elaborated term\nis of the expected type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elaboratePattern\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">elaboratePattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">forLhs</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L181-L192","name":"Mathlib.Tactic.TermCongr.processAntiquot","line":181,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.processAntiquot","doc":"Replace all `term` antiquotations in a term using the given `expand` function. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.processAntiquot\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">processAntiquot</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expand</span> : <span class=\"fn\"><a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L174-L179","name":"Mathlib.Tactic.TermCongr.elabCHoleExpand","line":174,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elabCHoleExpand","doc":"(Internal for `congr(...)`)\nElaborates to an expression satisfying `cHole?` that equals the LHS or RHS of `h`,\nif the LHS or RHS is available after elaborating `h`. Uses the expected type as a hint. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elabCHoleExpand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">elabCHoleExpand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElab\">Lean.Elab.Term.TermElab</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L169-L172","name":"Mathlib.Tactic.TermCongr.cHoleExpand","line":169,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHoleExpand","doc":"(Internal for `congr(...)`)\nElaborates to an expression satisfying `cHole?` that equals the LHS or RHS of `h`,\nif the LHS or RHS is available after elaborating `h`. Uses the expected type as a hint. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHoleExpand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">cHoleExpand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L150-L167","name":"Mathlib.Tactic.TermCongr.elabCHole","line":150,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elabCHole","doc":"Elaborates a congruence hole and returns either the left-hand side or the right-hand side,\nannotated with information necessary to generate a congruence lemma. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elabCHole\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">elabCHole</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">forLhs</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L146-L148","name":"Mathlib.Tactic.TermCongr.removeCHoles","line":146,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.removeCHoles","doc":"Eliminate all congruence holes from an expression by replacing them with their values. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.removeCHoles\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">removeCHoles</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L142-L144","name":"Mathlib.Tactic.TermCongr.hasCHole","line":142,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.hasCHole","doc":"Returns any subexpression that is a recent congruence hole. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.hasCHole\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">hasCHole</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarCounterSaved</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L129-L140","name":"Mathlib.Tactic.TermCongr.cHole?","line":129,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHole?","doc":"If the expression is a congruence hole, returns `(forLhs, sideVal, pf)`.\nIf `mvarCounterSaved?` is not none, then only returns the hole if it is at least as recent. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHole?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">cHole?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarCounterSaved?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L117-L127","name":"Mathlib.Tactic.TermCongr.mkCHole","line":117,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCHole","doc":"Create the congruence hole. Used by `elabCHole`.\n\nSaves the current mvarCounter as a proxy for age. We use this to avoid\nreprocessing old congruence holes that happened to leak into the local context. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCHole\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">mkCHole</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">forLhs</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">val </span><span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L111-L115","name":"Mathlib.Tactic.TermCongr.unexpandCHole","line":111,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.unexpandCHole","doc":"For error reporting purposes, make the hole pretty print as its value.\nWe can still see that it is a hole in the info view on mouseover. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.unexpandCHole\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">unexpandCHole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander\">Lean.PrettyPrinter.Unexpander</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L98-L109","name":"Mathlib.Tactic.TermCongr.cHole","line":98,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHole","doc":"For holding onto the hole's value along with the value of either the LHS or RHS of the hole.\nThese occur wrapped in metadata so that they always appear as function application\nwith exactly four arguments.\n\nNote that there is no relation between `val` and the proof.\nWe need to decouple these to support letting the proof's elaboration be deferred until\nwe know whether we want an iff, eq, or heq, while also allowing it to choose\nto elaborate as an iff, eq, or heq.\nLater, the congruence generator handles any discrepancies.\nSee `Mathlib.Tactic.TermCongr.CongrResult`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHole\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">cHole</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">val</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_pf</span> : <span class=\"fn\">p</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/TermCongr.lean#L57-L79","name":"Mathlib.Tactic.TermCongr.termCongr","line":57,"kind":"def","docLink":"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.termCongr","doc":"`congr(expr)` generates a congruence from an expression containing\ncongruence holes of the form `$h` or `$(h)`.\nIn these congruence holes, `h : a = b` indicates that, in the generated congruence,\non the left-hand side `a` is substituted for `$h`\nand on the right-hand side `b` is substituted for `$h`.\n\nFor example, if `h : a = b` then `congr(1 + $h) : 1 + a = 1 + b`.\n\nThis is able to make use of the expected type, for example `(congr(_ + $h) : 1 + _ = _)`\nwith `h : x = y` gives `1 + x = 1 + y`.\nThe expected type can be an `Iff`, `Eq`, or `HEq`.\nIf there is no expected type, then it generates an equality.\n\nNote: the process of generating a congruence lemma involves elaborating the pattern\nusing terms with attached metadata and a reducible wrapper.\nWe try to avoid doing so, but these terms can leak into the local context through unification.\nThis can potentially break tactics that are sensitive to metadata or reducible functions.\nPlease report anything that goes wrong with `congr(...)` lemmas on Zulip.\n\nFor debugging, you can set `set_option trace.Elab.congr true`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.termCongr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TermCongr</span>.<span class=\"name\">termCongr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}