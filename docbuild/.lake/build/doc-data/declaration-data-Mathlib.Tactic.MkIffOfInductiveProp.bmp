{"name":"Mathlib.Tactic.MkIffOfInductiveProp","instances":[],"imports":["Init","Lean.Elab.DeclarationRange","Lean.Meta.Tactic.Cases","Mathlib.Lean.Meta","Mathlib.Lean.Name","Mathlib.Tactic.TypeStar"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L375-L394","name":"Mathlib.Tactic.MkIff.mkIffOfInductiveProp","line":375,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductiveProp","doc":"`mk_iff_of_inductive_prop i r` makes an `iff` rule for the inductively-defined proposition `i`.\nThe new rule `r` has the shape `∀ps is, i as ↔ ⋁_j, ∃cs, is = cs`, where `ps` are the type\nparameters, `is` are the indices, `j` ranges over all possible constructors, the `cs` are the\nparameters for each of the constructors, and the equalities `is = cs` are the instantiations for\neach constructor for each of the indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, `mk_iff_of_inductive_prop` on `List.Chain` produces:\n\n```lean\n∀ { α : Type*} (R : α → α → Prop) (a : α) (l : List α),\n  Chain R a l ↔ l = [] ∨ ∃(b : α) (l' : List α), R a b ∧ Chain R b l ∧ l = b :: l'\n```\n\nSee also the `mk_iff` user attribute.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductiveProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkIffOfInductiveProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L334-L373","name":"Mathlib.Tactic.MkIff.mkIff","line":334,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIff","doc":"Applying the `mk_iff` attribute to an inductively-defined proposition `mk_iff` makes an `iff` rule\n`r` with the shape `∀ps is, i as ↔ ⋁_j, ∃cs, is = cs`, where `ps` are the type parameters, `is` are\nthe indices, `j` ranges over all possible constructors, the `cs` are the parameters for each of the\nconstructors, and the equalities `is = cs` are the instantiations for each constructor for each of\nthe indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, if we try the following:\n```lean\n@[mk_iff]\nstructure Foo (m n : Nat) : Prop where\n  equal : m = n\n  sum_eq_two : m + n = 2\n```\n\nThen `#check foo_iff` returns:\n```lean\nfoo_iff : ∀ (m n : Nat), Foo m n ↔ m = n ∧ m + n = 2\n```\n\nYou can add an optional string after `mk_iff` to change the name of the generated lemma.\nFor example, if we try the following:\n```lean\n@[mk_iff bar]\nstructure Foo (m n : Nat) : Prop where\n  equal : m = n\n  sum_eq_two : m + n = 2\n```\n\nThen `#check bar` returns:\n```lean\nbar : ∀ (m n : ℕ), Foo m n ↔ m = n ∧ m + n = 2\n```\n\nSee also the user command `mk_iff_of_inductive_prop`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkIff</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L293-L332","name":"Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl","line":293,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl","doc":"Implementation for both `mk_iff` and `mk_iff_of_inductive_prop`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkIffOfInductivePropImpl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ind </span><span class=\"fn\">rel</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">relStx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L249-L291","name":"Mathlib.Tactic.MkIff.toInductive","line":249,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toInductive","doc":"Proves the right to left direction of a generated iff theorem.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toInductive\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">toInductive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvar</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">gs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L233-L247","name":"Mathlib.Tactic.MkIff.listBoolMerge","line":233,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge","doc":"Iterate over two lists, if the first element of the first list is `false`, insert `none` into the\nresult and continue with the tail of first list. Otherwise, wrap the first element of the second\nlist with `some` and continue with the tails of both lists. Return when either list is empty.\n\nExample:\n```\nlistBoolMerge [false, true, false, true] [0, 1, 2, 3, 4] = [none, (some 0), none, (some 1)]\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">listBoolMerge</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L221-L231","name":"Mathlib.Tactic.MkIff.nCasesProd","line":221,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesProd","doc":"Calls `cases` on `h` (assumed to be a binary product) `n` times, and returns\nthe resulting subgoal and the new hypotheses.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">nCasesProd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvar</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L208-L219","name":"Mathlib.Tactic.MkIff.nCasesSum","line":208,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesSum","doc":"Calls `cases` on `h` (assumed to be a binary sum) `n` times, and returns\nthe resulting subgoals and their corresponding new hypotheses.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesSum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">nCasesSum</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvar</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>))</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L187-L206","name":"Mathlib.Tactic.MkIff.toCases","line":187,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toCases","doc":"Proves the left to right direction of a generated iff theorem.\n`shape` is the output of a call to `constrToProp`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">toCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvar</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">shape</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L168-L185","name":"Mathlib.Tactic.MkIff.splitThenConstructor","line":168,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.splitThenConstructor","doc":"Splits the goal `n` times via `refine ⟨?_,?_⟩`, and then applies `constructor` to\nclose the resulting subgoals.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.splitThenConstructor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">splitThenConstructor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvar</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L133-L166","name":"Mathlib.Tactic.MkIff.constrToProp","line":133,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.constrToProp","doc":"Converts an inductive constructor `c` into a `Shape` that will be used later in\nwhile proving the iff theorem, and a proposition representing the constructor.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.constrToProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">constrToProp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">univs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">params </span><span class=\"fn\">idxs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L131-L131","name":"Mathlib.Tactic.MkIff.Shape.neqs","line":131,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.neqs","doc":"The number of equalities, or `none` in the case when we've reduced something\nof the form `p ∧ True` to just `p`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.neqs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">Shape</span>.<span class=\"name\">neqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L126-L126","name":"Mathlib.Tactic.MkIff.Shape.variablesKept","line":126,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.variablesKept","doc":"For each forall-bound variable in the type of the constructor, minus\nthe \"params\" that apply to the entire inductive type, this list contains `true`\nif that variable has been kept after `compactRelation`.\n\nFor example, `List.Chain.nil` has type\n```lean\n  ∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []`\n```\nand the first two variables `α` and `R` are \"params\", while the `a : α` gets\neliminated in a `compactRelation`, so `variablesKept = [false]`.\n\n`List.Chain.cons` has type\n```lean\n  ∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α},\n     R a b → List.Chain R b l → List.Chain R a (b :: l)\n```\nand the `a : α` gets eliminated, so `variablesKept = [false,true,true,true,true]`.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.variablesKept\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">Shape</span>.<span class=\"name\">variablesKept</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L107-L107","name":"Mathlib.Tactic.MkIff.Shape.mk","line":107,"kind":"ctor","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">Shape</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">variablesKept</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">neqs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\">Shape</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L105-L131","name":"Mathlib.Tactic.MkIff.Shape","line":105,"kind":"structure","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape","doc":"Auxiliary data associated with a single constructor of an inductive declaration.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">Shape</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L99-L103","name":"Mathlib.Tactic.MkIff.List.init","line":99,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.List.init","doc":"Drops the final element of a list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.List.init\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">List</span>.<span class=\"name\">init</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L96-L97","name":"Mathlib.Tactic.MkIff.mkOrList","line":96,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOrList","doc":"`mkOrList [x1, x2, ...]` is defined as `x1 ∨ (x2 ∨ ...)`, or `False` if the list is empty. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOrList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkOrList</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L93-L94","name":"Mathlib.Tactic.MkIff.mkAndList","line":93,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkAndList","doc":"`mkAndList [x1, x2, ...]` is defined as `x1 ∧ (x2 ∧ ...)`, or `True` if the list is empty. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkAndList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkAndList</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L86-L91","name":"Mathlib.Tactic.MkIff.mkOpList","line":86,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList","doc":"`mkOpList op empty [x1, x2, ...]` is defined as `op x1 (op x2 ...)`.\nReturns `empty` if the list is empty. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkOpList</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op </span><span class=\"fn\">empty</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L73-L84","name":"Mathlib.Tactic.MkIff.mkExistsList","line":73,"kind":"def","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkExistsList","doc":"Generates an expression of the form `∃ (args), inner`. `args` is assumed to be a list of fvars.\nWhen possible, `p ∧ q` is used instead of `∃ (_ : p), q`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkExistsList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">mkExistsList</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inner</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/MkIffOfInductiveProp.lean#L47-L66","name":"Mathlib.Tactic.MkIff.compactRelation","line":47,"kind":"opaque","docLink":"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.compactRelation","doc":"`compactRelation bs as_ps`: Produce a relation of the form:\n```lean\nR := fun as ↦ ∃ bs, ⋀_i a_i = p_i[bs]\n```\nThis relation is user-visible, so we compact it by removing each `b_j` where a `p_i = b_j`, and\nhence `a_i = b_j`. We need to take care when there are `p_i` and `p_j` with `p_i = p_j = b_k`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.compactRelation\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MkIff</span>.<span class=\"name\">compactRelation</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></span></div></div>"}]}