{"name":"Mathlib.Tactic.ReduceModChar","instances":[{"typeNames":["Tactic.ReduceModChar.TypeToCharPResult"],"name":"Tactic.ReduceModChar.instInhabitedTypeToCharPResult","className":"Inhabited"}],"imports":["Init","Mathlib.Data.ZMod.Basic","Mathlib.RingTheory.Polynomial.Basic","Mathlib.Tactic.NormNum.DivMod","Mathlib.Tactic.NormNum.PowMod","Mathlib.Tactic.ReduceModChar.Ext"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L308-L309","name":"Tactic.ReduceModChar.reduce_mod_char!","line":308,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char!","doc":"The tactic `reduce_mod_char` looks for numeric expressions in characteristic `p`\nand reduces these to lie between `0` and `p`.\n\nFor example:\n```\nexample : (5 : ZMod 4) = 1 := by reduce_mod_char\nexample : (X ^ 2 - 3 * X + 4 : (ZMod 4)[X]) = X ^ 2 + X := by reduce_mod_char\n```\n\nIt also handles negation, turning it into multiplication by `p - 1`,\nand similarly subtraction.\n\nThis tactic uses the type of the subexpression to figure out if it is indeed of positive\ncharacteristic, for improved performance compared to trying to synthesise a `CharP` instance.\nThe variant `reduce_mod_char!` also tries to use `CharP R n` hypotheses in the context.\n(Limitations of the typeclass system mean the tactic can't search for a `CharP R n` instance if\n`n` is not yet known; use `have : CharP R n := inferInstance; reduce_mod_char!` as a workaround.)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char!\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">reduce_mod_char!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L288-L307","name":"Tactic.ReduceModChar.reduce_mod_char","line":288,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char","doc":"The tactic `reduce_mod_char` looks for numeric expressions in characteristic `p`\nand reduces these to lie between `0` and `p`.\n\nFor example:\n```\nexample : (5 : ZMod 4) = 1 := by reduce_mod_char\nexample : (X ^ 2 - 3 * X + 4 : (ZMod 4)[X]) = X ^ 2 + X := by reduce_mod_char\n```\n\nIt also handles negation, turning it into multiplication by `p - 1`,\nand similarly subtraction.\n\nThis tactic uses the type of the subexpression to figure out if it is indeed of positive\ncharacteristic, for improved performance compared to trying to synthesise a `CharP` instance.\nThe variant `reduce_mod_char!` also tries to use `CharP R n` hypotheses in the context.\n(Limitations of the typeclass system mean the tactic can't search for a `CharP R n` instance if\n`n` is not yet known; use `have : CharP R n := inferInstance; reduce_mod_char!` as a workaround.)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">reduce_mod_char</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L279-L284","name":"Tactic.ReduceModChar.reduceModCharHyp","line":279,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduceModCharHyp","doc":"Reduce all numeric subexpressions of the given hypothesis modulo their characteristic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduceModCharHyp\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">reduceModCharHyp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expensive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L266-L277","name":"Tactic.ReduceModChar.reduceModCharTarget","line":266,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduceModCharTarget","doc":"Reduce all numeric subexpressions of the goal modulo their characteristic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduceModCharTarget\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">reduceModCharTarget</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expensive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L233-L264","name":"Tactic.ReduceModChar.derive","line":233,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.derive","doc":"Reduce all numeric subexpressions of `e` modulo their characteristic.\n\nUse `derive (expensive := true)` to do more work in finding the characteristic of\nthe type of `e`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.derive\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">derive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expensive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L199-L226","name":"Tactic.ReduceModChar.matchAndNorm","line":199,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.matchAndNorm","doc":"Given an expression `e`, determine whether it is a numeric expression in characteristic `n`,\nand if so, reduce `e` modulo `n`.\n\nThis is not a `norm_num` plugin because it does not match on the syntax of `e`,\nrather it matches on the type of `e`.\n\nUse `matchAndNorm (expensive := true)` to do more work in finding the characteristic of\nthe type of `e`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.matchAndNorm\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">matchAndNorm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expensive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L170-L197","name":"Tactic.ReduceModChar.typeToCharP","line":170,"kind":"opaque","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.typeToCharP","doc":"Determine the characteristic of a ring from the type.\nThis should be fast, so this pattern-matches on the type, rather than searching for a\n`CharP` instance.\nUse `typeToCharP (expensive := true)` to do more work in finding the characteristic,\nin particular it will search for a `CharP` instance in the context. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.typeToCharP\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">typeToCharP</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expensive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">TypeToCharPResult</a> <span class=\"fn\">t</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L168-L168","name":"Tactic.ReduceModChar.instInhabitedTypeToCharPResult","line":168,"kind":"instance","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.instInhabitedTypeToCharPResult","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.instInhabitedTypeToCharPResult\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">instInhabitedTypeToCharPResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">TypeToCharPResult</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L166-L166","name":"Tactic.ReduceModChar.TypeToCharPResult.failure","line":166,"kind":"ctor","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.failure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.failure\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">TypeToCharPResult</span>.<span class=\"name\">failure</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">TypeToCharPResult</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L165-L165","name":"Tactic.ReduceModChar.TypeToCharPResult.intLike","line":165,"kind":"ctor","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.intLike","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.intLike\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">TypeToCharPResult</span>.<span class=\"name\">intLike</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instRing</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">TypeToCharPResult</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L162-L166","name":"Tactic.ReduceModChar.TypeToCharPResult","line":162,"kind":"inductive","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult","doc":"A `TypeToCharPResult α` indicates if `α` can be determined to be a ring of characteristic `p`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">TypeToCharPResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L141-L160","name":"Tactic.ReduceModChar.normNegCoeffMul","line":141,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNegCoeffMul","doc":"Given an expression `-(a * b) : t` such that `t` is a ring of characteristic `n`,\nand `a` is a numeral, simplify this to `((n - 1) * a) * b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNegCoeffMul\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normNegCoeffMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_instRing</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L135-L139","name":"Tactic.ReduceModChar.CharP.neg_mul_eq_sub_one_mul","line":135,"kind":"theorem","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_mul_eq_sub_one_mul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_mul_eq_sub_one_mul\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">neg_mul_eq_sub_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">na</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">na'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> ((<span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">1</span>) <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span>) <span class=\"fn\">na</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pa</span> : <span class=\"fn\">↑<span class=\"fn\">na</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">na'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a>(<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">na'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L112-L133","name":"Tactic.ReduceModChar.normNeg","line":112,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNeg","doc":"Given an expression `(-e) : t` such that `t` is a ring of characteristic `n`,\nsimplify this to `(n - 1) * e`.\n\nThis should be called only when `normIntNumeral` fails, because `normIntNumeral` would otherwise\nbe more useful by evaluating `-e` mod `n` to an actual numeral.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNeg\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normNeg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_instRing</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L106-L110","name":"Tactic.ReduceModChar.CharP.neg_eq_sub_one_mul","line":106,"kind":"theorem","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_eq_sub_one_mul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_eq_sub_one_mul\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">neg_eq_sub_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> (<span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">1</span>) <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pa</span> : <span class=\"fn\">↑<span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L99-L104","name":"Tactic.ReduceModChar.normIntNumeral","line":99,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normIntNumeral","doc":"Given an integral expression `e : t` such that `t` is a ring of characteristic `n`,\nreduce `e` modulo `n`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normIntNumeral\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normIntNumeral</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Mathlib.Meta.NormNum.Result</a> <span class=\"fn\">e</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L93-L97","name":"Tactic.ReduceModChar.CharP.intCast_eq_mod","line":93,"kind":"theorem","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.intCast_eq_mod","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.intCast_eq_mod\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">intCast_eq_mod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">R</span> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑(<span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HMod.hMod\">%</a> <span class=\"fn\">↑<span class=\"fn\">p</span></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L85-L89","name":"Tactic.ReduceModChar.normIntNumeral'","line":85,"kind":"opaque","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normIntNumeral'","doc":"If `e` is of the form `a ^ b`, reduce it using fast modular exponentiation, otherwise\nreduce it using `norm_num`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normIntNumeral'\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normIntNumeral'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$n'»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Mathlib.Meta.NormNum.Result</a> <span class=\"fn\">e</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L71-L83","name":"Tactic.ReduceModChar.normPow","line":71,"kind":"opaque","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normPow","doc":"Given an expression of the form `a ^ b` in a ring of characteristic `n`, reduces `a`\nmodulo `n` recursively and then calculates `a ^ b` using fast modular exponentiation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normPow\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normPow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$n'»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Mathlib.Meta.NormNum.Result</a> <span class=\"fn\">e</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L60-L67","name":"Tactic.ReduceModChar.normBareNumeral","line":60,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normBareNumeral","doc":"Evaluates `e` to an integer using `norm_num` and reduces the result modulo `n`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normBareNumeral\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normBareNumeral</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$n'»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Mathlib.Meta.NormNum.Result</a> <span class=\"fn\">e</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L52-L57","name":"Tactic.ReduceModChar.CharP.isNat_pow","line":52,"kind":"theorem","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.isNat_pow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.isNat_pow\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">isNat_pow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\">α</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c </span><span class=\"fn\">n </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span> →\n  <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#HPow.hPow\">HPow.hPow</a> →\n    <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">a'</span></span> →\n      <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">b</span> <span class=\"fn\">b'</span></span> →\n        <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">n'</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">a'</span>.<a href=\"./Init/Prelude.html#Nat.pow\">pow</a></span> <span class=\"fn\">b'</span>)</span>.<a href=\"./Init/Data/Nat/Div/Basic.html#Nat.mod\">mod</a></span> <span class=\"fn\">n'</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span> <span class=\"fn\">c</span></span></span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/ReduceModChar.lean#L48-L50","name":"Tactic.ReduceModChar.CharP.isInt_of_mod","line":48,"kind":"theorem","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.isInt_of_mod","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.isInt_of_mod\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">isInt_of_mod</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e' </span><span class=\"fn\">r</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">he</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Mathlib.Meta.NormNum.IsInt</a> <span class=\"fn\">e</span> <span class=\"fn\">e'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Mathlib.Meta.NormNum.IsInt</a> (<span class=\"fn\">e'</span> <a href=\"./Init/Prelude.html#HMod.hMod\">%</a> <span class=\"fn\">↑<span class=\"fn\">n'</span></span>) <span class=\"fn\">r</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Mathlib.Meta.NormNum.IsInt</a> <span class=\"fn\">e</span> <span class=\"fn\">r</span></span></div></div>"}]}