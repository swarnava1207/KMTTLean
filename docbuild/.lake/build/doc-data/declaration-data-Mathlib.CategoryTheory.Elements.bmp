{"name":"Mathlib.CategoryTheory.Elements","instances":[{"typeNames":["CategoryTheory.Functor.Elements"],"name":"CategoryTheory.categoryOfElements","className":"CategoryTheory.Category"},{"typeNames":["CategoryTheory.Functor.Elements"],"name":"CategoryTheory.groupoidOfElements","className":"CategoryTheory.Groupoid"},{"typeNames":["CategoryTheory.CategoryOfElements.π"],"name":"CategoryTheory.CategoryOfElements.instFaithfulElementsπ","className":"CategoryTheory.Functor.Faithful"},{"typeNames":["CategoryTheory.CategoryOfElements.π"],"name":"CategoryTheory.CategoryOfElements.instReflectsIsomorphismsElementsπ","className":"CategoryTheory.Functor.ReflectsIsomorphisms"}],"imports":["Init","Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","Mathlib.CategoryTheory.Category.Cat"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L281-L289","name":"CategoryTheory.Functor.Elements.isInitial","line":281,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements.isInitial","doc":"Show that `Elements.initial A` is initial in the category of elements for the `yoneda` functor.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements.isInitial\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">Elements</span>.<span class=\"name\">isInitial</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">A</span> : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/IsTerminal.html#CategoryTheory.Limits.IsInitial\">Limits.IsInitial</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements.initial\">initial</a> <span class=\"fn\">A</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L274-L279","name":"CategoryTheory.Functor.Elements.initial","line":274,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements.initial","doc":"The initial object in the category of elements for a representable functor. In `isInitial` it is\nshown that this is initial.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements.initial\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">Elements</span>.<span class=\"name\">initial</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">A</span> : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">A</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L265-L265","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ_inv_app","line":265,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalenceInverseπ_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow\">CostructuredArrow</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ\">costructuredArrowYonedaEquivalenceInverseπ</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv\">inv</a></span>.<a href=\"./Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app\">app</a></span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\"><span class=\"fn\">X</span>.<a href=\"./Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.left\">left</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L265-L265","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ_hom_app","line":265,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalenceInverseπ_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow\">CostructuredArrow</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ\">costructuredArrowYonedaEquivalenceInverseπ</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom\">hom</a></span>.<a href=\"./Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app\">app</a></span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\"><span class=\"fn\">X</span>.<a href=\"./Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.left\">left</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L264-L268","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ","line":264,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ","doc":"The equivalence `F.elementsᵒᵖ ≌ (yoneda, F)` is compatible with the forgetful functors. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseπ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalenceInverseπ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence\">costructuredArrowYonedaEquivalence</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse\">inverse</a></span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">comp</a></span> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π\">π</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp\">leftOp</a></span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj\">CostructuredArrow.proj</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L259-L259","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_hom_app","line":259,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalenceFunctorProj_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj\">costructuredArrowYonedaEquivalenceFunctorProj</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom\">hom</a></span>.<a href=\"./Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app\">app</a></span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.unop\">Opposite.unop</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.unop\">Opposite.unop</a> <span class=\"fn\">X</span>)</span>.1</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L259-L259","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_inv_app","line":259,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalenceFunctorProj_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj\">costructuredArrowYonedaEquivalenceFunctorProj</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv\">inv</a></span>.<a href=\"./Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app\">app</a></span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.unop\">Opposite.unop</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.unop\">Opposite.unop</a> <span class=\"fn\">X</span>)</span>.1</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L258-L262","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj","line":258,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj","doc":"The equivalence `F.elementsᵒᵖ ≌ (yoneda, F)` is compatible with the forgetful functors. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalenceFunctorProj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence\">costructuredArrowYonedaEquivalence</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor\">functor</a></span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">comp</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj\">CostructuredArrow.proj</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span>)</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π\">π</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp\">leftOp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L245-L256","name":"CategoryTheory.CategoryOfElements.costructuredArrow_yoneda_equivalence_naturality","line":245,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrow_yoneda_equivalence_naturality","doc":"The equivalence `(-.Elements)ᵒᵖ ≅ (yoneda, -)` of is actually a natural isomorphism of functors.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrow_yoneda_equivalence_naturality\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrow_yoneda_equivalence_naturality</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F₁ </span><span class=\"fn\">F₂</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">F₁</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">F₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map\">map</a> <span class=\"fn\">α</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op\">op</a></span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">comp</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow\">toCostructuredArrow</a> <span class=\"fn\">F₂</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow\">toCostructuredArrow</a> <span class=\"fn\">F₁</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">comp</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map\">CostructuredArrow.map</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L233-L233","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_inverse","line":233,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_inverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_inverse\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalence_inverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence\">costructuredArrowYonedaEquivalence</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse\">inverse</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow\">fromCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp\">rightOp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L233-L233","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_counitIso","line":233,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_counitIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_counitIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalence_counitIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence\">costructuredArrowYonedaEquivalence</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso\">counitIso</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents\">NatIso.ofComponents</a>\n    <span class=\"fn\">(fun (<span class=\"fn\">X</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow\">CostructuredArrow</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span></span>) =&gt;\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.isoMk\">CostructuredArrow.isoMk</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">Iso.refl</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow\">fromCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp\">rightOp</a></span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">comp</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow\">toCostructuredArrow</a> <span class=\"fn\">F</span>)</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.left\">left</a></span>)</span>\n        <span class=\"fn\">⋯</span></span>)</span>\n    <span class=\"fn\">⋯</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L233-L233","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_functor","line":233,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_functor","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_functor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalence_functor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence\">costructuredArrowYonedaEquivalence</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor\">functor</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow\">toCostructuredArrow</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L233-L233","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_unitIso","line":233,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_unitIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_unitIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalence_unitIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence\">costructuredArrowYonedaEquivalence</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso\">unitIso</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents\">NatIso.ofComponents</a>\n    <span class=\"fn\">(fun (<span class=\"fn\">X</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a>) =&gt;\n      <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.isoMk\">isoMk</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow\">fromCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow\">toCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span>)</span>)</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.unop\">Opposite.unop</a> <span class=\"fn\">X</span>)</span>\n          <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">Iso.refl</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow\">fromCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow\">toCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span>)</span>)</span>)</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span>)</span> <span class=\"fn\">⋯</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op\">op</a></span>)</span>\n    <span class=\"fn\">⋯</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L232-L243","name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence","line":232,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence","doc":"The equivalence `F.Elementsᵒᵖ ≅ (yoneda, F)` given by yoneda lemma. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">costructuredArrowYonedaEquivalence</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow\">CostructuredArrow</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L227-L230","name":"CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_mk","line":227,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_mk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">fromCostructuredArrow_obj_mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">F</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow\">fromCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mk\">CostructuredArrow.mk</a> <span class=\"fn\">f</span>)</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">⟨<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">X</span></span>, <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yonedaEquiv\">yonedaEquiv</a>.<a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv.toFun\">toFun</a></span> <span class=\"fn\">f</span></span>⟩</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L213-L213","name":"CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_snd","line":213,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_snd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_snd\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">fromCostructuredArrow_obj_snd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow\">CostructuredArrow</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span>)</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow\">fromCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span>)</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yonedaEquiv\">yonedaEquiv</a>.<a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv.toFun\">toFun</a></span> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.unop\">Opposite.unop</a> <span class=\"fn\">X</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.hom\">hom</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L213-L213","name":"CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_fst","line":213,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_fst","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_fst\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">fromCostructuredArrow_obj_fst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow\">CostructuredArrow</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span>)</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow\">fromCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span>)</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.unop\">Opposite.unop</a> <span class=\"fn\">X</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.left\">left</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L213-L213","name":"CategoryTheory.CategoryOfElements.fromCostructuredArrow_map_coe","line":213,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow_map_coe","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow_map_coe\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">fromCostructuredArrow_map_coe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow\">CostructuredArrow</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span>)</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow\">fromCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop\">unop</a></span>.<a href=\"./Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.CommaMorphism.left\">left</a></span>.<a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op\">op</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L210-L225","name":"CategoryTheory.CategoryOfElements.fromCostructuredArrow","line":210,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow","doc":"The reverse direction of the equivalence `F.Elementsᵒᵖ ≅ (yoneda, F)`,\ngiven by `CategoryTheory.yonedaEquiv`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromCostructuredArrow\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">fromCostructuredArrow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow\">CostructuredArrow</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span>)</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L201-L201","name":"CategoryTheory.CategoryOfElements.toCostructuredArrow_obj","line":201,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">toCostructuredArrow_obj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow\">toCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mk\">CostructuredArrow.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yonedaEquiv\">yonedaEquiv</a>.<a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv.symm\">symm</a></span> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.unop\">Opposite.unop</a> <span class=\"fn\">X</span>)</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L201-L201","name":"CategoryTheory.CategoryOfElements.toCostructuredArrow_map","line":201,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">toCostructuredArrow_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X✝ </span><span class=\"fn\">Y✝</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y✝</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow\">toCostructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk\">CostructuredArrow.homMk</a> <span class=\"fn\"><span class=\"fn\">(↑<span class=\"fn\"><span class=\"fn\">f</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop\">unop</a></span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop\">unop</a></span> <span class=\"fn\">⋯</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L198-L208","name":"CategoryTheory.CategoryOfElements.toCostructuredArrow","line":198,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow","doc":"The forward direction of the equivalence `F.Elementsᵒᵖ ≅ (yoneda, F)`,\ngiven by `CategoryTheory.yonedaEquiv`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toCostructuredArrow\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">toCostructuredArrow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <a href=\"./foundational_types.html\">(Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow\">CostructuredArrow</a> <a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.yoneda\">yoneda</a> <span class=\"fn\">F</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L189-L189","name":"CategoryTheory.CategoryOfElements.structuredArrowEquivalence_functor","line":189,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence_functor","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence_functor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">structuredArrowEquivalence_functor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence\">structuredArrowEquivalence</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor\">functor</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toStructuredArrow\">toStructuredArrow</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L189-L189","name":"CategoryTheory.CategoryOfElements.structuredArrowEquivalence_unitIso","line":189,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence_unitIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence_unitIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">structuredArrowEquivalence_unitIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence\">structuredArrowEquivalence</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso\">unitIso</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">Iso.refl</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id\">Functor.id</a> <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L189-L189","name":"CategoryTheory.CategoryOfElements.structuredArrowEquivalence_counitIso","line":189,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence_counitIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence_counitIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">structuredArrowEquivalence_counitIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence\">structuredArrowEquivalence</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso\">counitIso</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">Iso.refl</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromStructuredArrow\">fromStructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">comp</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toStructuredArrow\">toStructuredArrow</a> <span class=\"fn\">F</span>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L189-L189","name":"CategoryTheory.CategoryOfElements.structuredArrowEquivalence_inverse","line":189,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence_inverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence_inverse\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">structuredArrowEquivalence_inverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence\">structuredArrowEquivalence</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse\">inverse</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromStructuredArrow\">fromStructuredArrow</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L187-L194","name":"CategoryTheory.CategoryOfElements.structuredArrowEquivalence","line":187,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence","doc":"The equivalence between the category of elements `F.Elements`\nand the comma category `(*, F)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.structuredArrowEquivalence\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">structuredArrowEquivalence</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow\">StructuredArrow</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{w + 1}</a> <span class=\"fn\">F</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L182-L185","name":"CategoryTheory.CategoryOfElements.fromStructuredArrow_map","line":182,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromStructuredArrow_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromStructuredArrow_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">fromStructuredArrow_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow\">StructuredArrow</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{w + 1}</a> <span class=\"fn\">F</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromStructuredArrow\">fromStructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">⟨<span class=\"fn\"><span class=\"fn\">f</span>.<a href=\"./Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.CommaMorphism.right\">right</a></span>, <span class=\"fn\">⋯</span>⟩</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L178-L180","name":"CategoryTheory.CategoryOfElements.fromStructuredArrow_obj","line":178,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromStructuredArrow_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromStructuredArrow_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">fromStructuredArrow_obj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow\">StructuredArrow</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{w + 1}</a> <span class=\"fn\">F</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromStructuredArrow\">fromStructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">⟨<span class=\"fn\"><span class=\"fn\">X</span>.<a href=\"./Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.right\">right</a></span>, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span>.<a href=\"./Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.hom\">hom</a></span> <a href=\"./Init/Prelude.html#PUnit.unit\">PUnit.unit</a></span>⟩</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L173-L176","name":"CategoryTheory.CategoryOfElements.fromStructuredArrow","line":173,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromStructuredArrow","doc":"The reverse direction of the equivalence `F.Elements ≅ (*, F)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.fromStructuredArrow\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">fromStructuredArrow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow\">StructuredArrow</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{w + 1}</a> <span class=\"fn\">F</span>)</span> <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L169-L171","name":"CategoryTheory.CategoryOfElements.to_comma_map_right","line":169,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.to_comma_map_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.to_comma_map_right\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">to_comma_map_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toStructuredArrow\">toStructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.CommaMorphism.right\">right</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L161-L167","name":"CategoryTheory.CategoryOfElements.toStructuredArrow_obj","line":161,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toStructuredArrow_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toStructuredArrow_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">toStructuredArrow_obj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toStructuredArrow\">toStructuredArrow</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">{ <span class=\"fn\">left</span> := <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Init/Prelude.html#PUnit.unit\">PUnit.unit</a> }</span>, <span class=\"fn\">right</span> := <span class=\"fn\"><span class=\"fn\">X</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span>,\n    <span class=\"fn\">hom</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit\">Functor.fromPUnit</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{w + 1}</a>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <a href=\"./Init/Prelude.html#PUnit.unit\">PUnit.unit</a> }</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">X</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L156-L159","name":"CategoryTheory.CategoryOfElements.toStructuredArrow","line":156,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toStructuredArrow","doc":"The forward direction of the equivalence `F.Elements ≅ (*, F)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.toStructuredArrow\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">toStructuredArrow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow\">StructuredArrow</a> <a href=\"./Init/Prelude.html#PUnit\">PUnit.{w + 1}</a> <span class=\"fn\">F</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L152-L154","name":"CategoryTheory.CategoryOfElements.map_π","line":152,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map_π","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map_π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">map_π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F₁ </span><span class=\"fn\">F₂</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">F₁</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">F₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map\">map</a> <span class=\"fn\">α</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">comp</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π\">π</a> <span class=\"fn\">F₂</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π\">π</a> <span class=\"fn\">F₁</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L147-L147","name":"CategoryTheory.CategoryOfElements.map_obj_snd","line":147,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map_obj_snd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map_obj_snd\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">map_obj_snd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F₁ </span><span class=\"fn\">F₂</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">F₁</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">F₂</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><span class=\"fn\">F₁</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map\">map</a> <span class=\"fn\">α</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">t</span>)</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span>.<a href=\"./Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app\">app</a></span> <span class=\"fn\"><span class=\"fn\">t</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span> <span class=\"fn\"><span class=\"fn\">t</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L147-L147","name":"CategoryTheory.CategoryOfElements.map_map_coe","line":147,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map_map_coe","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map_map_coe\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">map_map_coe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F₁ </span><span class=\"fn\">F₂</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">F₁</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">F₂</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">t₁ </span><span class=\"fn\">t₂</span> : <span class=\"fn\"><span class=\"fn\">F₁</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\">t₁</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">t₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map\">map</a> <span class=\"fn\">α</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">k</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">k</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L147-L147","name":"CategoryTheory.CategoryOfElements.map_obj_fst","line":147,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map_obj_fst","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map_obj_fst\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">map_obj_fst</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F₁ </span><span class=\"fn\">F₂</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">F₁</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">F₂</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><span class=\"fn\">F₁</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map\">map</a> <span class=\"fn\">α</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">t</span>)</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">t</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L145-L150","name":"CategoryTheory.CategoryOfElements.map","line":145,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map","doc":"A natural transformation between functors induces a functor between the categories of elements.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F₁ </span><span class=\"fn\">F₂</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">F₁</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">F₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\"><span class=\"fn\">F₁</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span> <span class=\"fn\"><span class=\"fn\">F₂</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L141-L143","name":"CategoryTheory.CategoryOfElements.instReflectsIsomorphismsElementsπ","line":141,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.instReflectsIsomorphismsElementsπ","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.instReflectsIsomorphismsElementsπ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">instReflectsIsomorphismsElementsπ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π\">π</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/ReflectsIso/Basic.html#CategoryTheory.Functor.ReflectsIsomorphisms\">ReflectsIsomorphisms</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L139-L139","name":"CategoryTheory.CategoryOfElements.instFaithfulElementsπ","line":139,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.instFaithfulElementsπ","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.instFaithfulElementsπ\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">instFaithfulElementsπ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π\">π</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful\">Faithful</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L134-L134","name":"CategoryTheory.CategoryOfElements.π_map","line":134,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">π_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X✝ </span><span class=\"fn\">Y✝</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y✝</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π\">π</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L134-L134","name":"CategoryTheory.CategoryOfElements.π_obj","line":134,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">π_obj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π\">π</a> <span class=\"fn\">F</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">X</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L133-L137","name":"CategoryTheory.CategoryOfElements.π","line":133,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π","doc":"The functor out of the category of elements which forgets the element. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.π\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">π</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L111-L127","name":"CategoryTheory.groupoidOfElements","line":111,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.groupoidOfElements","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.groupoidOfElements\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">groupoidOfElements</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">G</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Groupoid.html#CategoryTheory.Groupoid\">Groupoid</a> <span class=\"fn\">G</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">G</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Groupoid.html#CategoryTheory.Groupoid\">Groupoid</a> <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L103-L103","name":"CategoryTheory.CategoryOfElements.isoMk_inv","line":103,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.isoMk_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.isoMk_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">isoMk_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">he</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\"><span class=\"fn\">e</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom\">hom</a></span> <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.isoMk\">isoMk</a> <span class=\"fn\">x</span> <span class=\"fn\">y</span> <span class=\"fn\">e</span> <span class=\"fn\">he</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv\">inv</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.homMk\">homMk</a> <span class=\"fn\">y</span> <span class=\"fn\">x</span> <span class=\"fn\"><span class=\"fn\">e</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv\">inv</a></span> <span class=\"fn\">⋯</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L103-L103","name":"CategoryTheory.CategoryOfElements.isoMk_hom","line":103,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.isoMk_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.isoMk_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">isoMk_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">he</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\"><span class=\"fn\">e</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom\">hom</a></span> <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.isoMk\">isoMk</a> <span class=\"fn\">x</span> <span class=\"fn\">y</span> <span class=\"fn\">e</span> <span class=\"fn\">he</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom\">hom</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.homMk\">homMk</a> <span class=\"fn\">x</span> <span class=\"fn\">y</span> <span class=\"fn\"><span class=\"fn\">e</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom\">hom</a></span> <span class=\"fn\">he</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L102-L107","name":"CategoryTheory.CategoryOfElements.isoMk","line":102,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.isoMk","doc":"Constructor for isomorphisms in the category of elements of a functor to types. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.isoMk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">isoMk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">he</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\"><span class=\"fn\">e</span>.<a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom\">hom</a></span> <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">y</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L98-L100","name":"CategoryTheory.CategoryOfElements.map_snd","line":98,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map_snd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.map_snd\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">map_snd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p </span><span class=\"fn\">q</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">p</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">q</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">(↑<span class=\"fn\">f</span>)</span> <span class=\"fn\"><span class=\"fn\">p</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">q</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L94-L96","name":"CategoryTheory.CategoryOfElements.id_val","line":94,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.id_val","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.id_val\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">id_val</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">p</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\"><span class=\"fn\">p</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L89-L92","name":"CategoryTheory.CategoryOfElements.comp_val","line":89,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.comp_val","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.comp_val\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">comp_val</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p </span><span class=\"fn\">q </span><span class=\"fn\">r</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f</span> : <span class=\"fn\">p</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">q</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">g</span> : <span class=\"fn\">q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">r</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">↑<span class=\"fn\">f</span></span> <span class=\"fn\">↑<span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L85-L85","name":"CategoryTheory.CategoryOfElements.ext_iff","line":85,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.ext_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.ext_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">ext_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f </span><span class=\"fn\">g</span> : <span class=\"fn\">x</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">y</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">↑<span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L85-L87","name":"CategoryTheory.CategoryOfElements.ext","line":85,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f </span><span class=\"fn\">g</span> : <span class=\"fn\">x</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">y</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">w</span> : <span class=\"fn\">↑<span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L80-L80","name":"CategoryTheory.CategoryOfElements.homMk_coe","line":80,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.homMk_coe","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.homMk_coe\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">homMk_coe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hf</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span> <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.homMk\">homMk</a> <span class=\"fn\">x</span> <span class=\"fn\">y</span> <span class=\"fn\">f</span> <span class=\"fn\">hf</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L79-L83","name":"CategoryTheory.CategoryOfElements.homMk","line":79,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.homMk","doc":"Constructor for morphisms in the category of elements of a functor to types. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.CategoryOfElements.homMk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">CategoryOfElements</span>.<span class=\"name\">homMk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hf</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">f</span> <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">y</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L72-L72","name":"CategoryTheory.Functor.elementsFunctor_obj","line":72,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.elementsFunctor_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.elementsFunctor_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">elementsFunctor_obj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.elementsFunctor\">elementsFunctor</a>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">F</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat.of\">Cat.of</a> <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L72-L72","name":"CategoryTheory.Functor.elementsFunctor_map","line":72,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.elementsFunctor_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.elementsFunctor_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">elementsFunctor_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X✝ </span><span class=\"fn\">Y✝</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y✝</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.elementsFunctor\">elementsFunctor</a>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.NatTrans.mapElements\">NatTrans.mapElements</a> <span class=\"fn\">n</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L71-L75","name":"CategoryTheory.Functor.elementsFunctor","line":71,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.elementsFunctor","doc":"The functor mapping functors `C ⥤ Type w` to their category of elements "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.elementsFunctor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">elementsFunctor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w))</span> <a href=\"./Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat\">Cat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L66-L66","name":"CategoryTheory.NatTrans.mapElements_map_coe","line":66,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.NatTrans.mapElements_map_coe","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.NatTrans.mapElements_map_coe\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">NatTrans</span>.<span class=\"name\">mapElements_map_coe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F </span><span class=\"fn\">G</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">φ</span> : <span class=\"fn\">F</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">G</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p </span><span class=\"fn\">q</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">p</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">q</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.NatTrans.mapElements\">mapElements</a> <span class=\"fn\">φ</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">x✝</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">x✝</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L66-L66","name":"CategoryTheory.NatTrans.mapElements_obj","line":66,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.NatTrans.mapElements_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.NatTrans.mapElements_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">NatTrans</span>.<span class=\"name\">mapElements_obj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F </span><span class=\"fn\">G</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">φ</span> : <span class=\"fn\">F</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">G</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.NatTrans.mapElements\">mapElements</a> <span class=\"fn\">φ</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">x✝</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">match <span class=\"fn\">x✝</span> with\n  | <span class=\"fn\">⟨<span class=\"fn\">X</span>, <span class=\"fn\">x</span>⟩</span> =&gt; <span class=\"fn\">⟨<span class=\"fn\">X</span>, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span>.<a href=\"./Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app\">app</a></span> <span class=\"fn\">X</span> <span class=\"fn\">x</span></span>⟩</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L65-L69","name":"CategoryTheory.NatTrans.mapElements","line":65,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.NatTrans.mapElements","doc":"Natural transformations are mapped to functors between category of elements "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.NatTrans.mapElements\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">NatTrans</span>.<span class=\"name\">mapElements</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F </span><span class=\"fn\">G</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">φ</span> : <span class=\"fn\">F</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">G</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span> <span class=\"fn\"><span class=\"fn\">G</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L57-L63","name":"CategoryTheory.categoryOfElements","line":57,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.categoryOfElements","doc":"The category structure on `F.Elements`, for `F : C ⥤ Type`.\nA morphism `(X, x) ⟶ (Y, y)` is a morphism `f : X ⟶ Y` in `C`, so `F.map f` takes `x` to `y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.categoryOfElements\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">categoryOfElements</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, max u w}</a> <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L49-L55","name":"CategoryTheory.Functor.Elements.ext","line":49,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">Elements</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.fst\">fst</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map\">map</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">eqToHom</a> <span class=\"fn\">h₁</span>)</span> <span class=\"fn\"><span class=\"fn\">x</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.<a href=\"./Init/Core.html#Sigma.snd\">snd</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L46-L47","name":"CategoryTheory.Functor.elementsMk","line":46,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.elementsMk","doc":"Constructor for the type `F.Elements` when `F` is a functor to types. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.elementsMk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">elementsMk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span>.<a href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\">Elements</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Elements.lean#L40-L44","name":"CategoryTheory.Functor.Elements","line":40,"kind":"def","docLink":"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements","doc":"The type of objects for the category of elements of a functor `F : C ⥤ Type`\nis a pair `(X : C, x : F.obj X)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Elements.html#CategoryTheory.Functor.Elements\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Functor</span>.<span class=\"name\">Elements</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">Functor</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(Type</a> w)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u w)</div></div>"}]}