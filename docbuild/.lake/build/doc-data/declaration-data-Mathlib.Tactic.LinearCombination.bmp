{"name":"Mathlib.Tactic.LinearCombination","instances":[],"imports":["Init","Mathlib.Tactic.LinearCombination.Lemmas","Mathlib.Tactic.Positivity.Core","Mathlib.Tactic.Ring","Mathlib.Tactic.Ring.Compare"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/LinearCombination.lean#L219-L292","name":"Mathlib.Tactic.LinearCombination.linearCombination","line":219,"kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.linearCombination","doc":"The `linear_combination` tactic attempts to prove an (in)equality goal by exhibiting it as a\nspecified linear combination of (in)equality hypotheses, or other (in)equality proof terms, modulo\n(A) moving terms between the LHS and RHS of the (in)equalities, and (B) a normalization tactic\nwhich by default is ring-normalization.\n\nExample usage:\n```\nexample {a b : ℚ} (h1 : a = 1) (h2 : b = 3) : (a + b) / 2 = 2 := by\n  linear_combination (h1 + h2) / 2\n\nexample {a b : ℚ} (h1 : a ≤ 1) (h2 : b ≤ 3) : (a + b) / 2 ≤ 2 := by\n  linear_combination (h1 + h2) / 2\n\nexample {a b : ℚ} : 2 * a * b ≤ a ^ 2 + b ^ 2 := by\n  linear_combination sq_nonneg (a - b)\n\nexample {x y z w : ℤ} (h₁ : x * z = y ^ 2) (h₂ : y * w = z ^ 2) :\n    z * (x * w - y * z) = 0 := by\n  linear_combination w * h₁ + y * h₂\n\nexample {x : ℚ} (h : x ≥ 5) : x ^ 2 > 2 * x + 11 := by\n  linear_combination (x + 3) * h\n\nexample {R : Type*} [CommRing R] {a b : R} (h : a = b) : a ^ 2 = b ^ 2 := by\n  linear_combination (a + b) * h\n\nexample {A : Type*} [AddCommGroup A]\n    {x y z : A} (h1 : x + y = 10 • z) (h2 : x - y = 6 • z) :\n    2 • x = 2 • (8 • z) := by\n  linear_combination (norm := abel) h1 + h2\n\nexample (x y : ℤ) (h1 : x * y + 2 * x = 1) (h2 : x = y) :\n    x * y = -2 * y + 1 := by\n  linear_combination (norm := ring_nf) -2 * h2\n  -- leaves goal `⊢ x * y + x * 2 - 1 = 0`\n```\n\nThe input `e` in `linear_combination e` is a linear combination of proofs of (in)equalities,\ngiven as a sum/difference of coefficients multiplied by expressions.\nThe coefficients may be arbitrary expressions (with nonnegativity constraints in the case of\ninequalities).\nThe expressions can be arbitrary proof terms proving (in)equalities;\nmost commonly they are hypothesis names `h1`, `h2`, ....\n\nThe left and right sides of all the (in)equalities should have the same type `α`, and the\ncoefficients should also have type `α`.  For full functionality `α` should be a commutative ring --\nstrictly speaking, a commutative semiring with \"cancellative\" addition (in the semiring case,\nnegation and subtraction will be handled \"formally\" as if operating in the enveloping ring). If a\nnonstandard normalization is used (for example `abel` or `skip`), the tactic will work over types\n`α` with less algebraic structure: for equalities, the minimum is instances of\n`[Add α] [IsRightCancelAdd α]` together with instances of whatever operations are used in the tactic\ncall.\n\nThe variant `linear_combination (norm := tac) e` specifies explicitly the \"normalization tactic\"\n`tac` to be run on the subgoal(s) after constructing the linear combination.\n* The default normalization tactic is `ring1` (for equalities) or `Mathlib.Tactic.Ring.prove{LE,LT}`\n  (for inequalities). These are finishing tactics: they close the goal or fail.\n* When working in algebraic categories other than commutative rings -- for example fields, abelian\n  groups, modules -- it is sometimes useful to use normalization tactics adapted to those categories\n  (`field_simp`, `abel`, `module`).\n* To skip normalization entirely, use `skip` as the normalization tactic.\n* The `linear_combination` tactic creates a linear combination by adding the provided (in)equalities\n  together from left to right, so if `tac` is not invariant under commutation of additive\n  expressions, then the order of the input hypotheses can matter.\n\nThe variant `linear_combination (exp := n) e` will take the goal to the `n`th power before\nsubtracting the combination `e`. In other words, if the goal is `t1 = t2`,\n`linear_combination (exp := n) e` will change the goal to `(t1 - t2)^n = 0` before proceeding as\nabove.  This variant is implemented only for linear combinations of equalities (i.e., not for\ninequalities).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.linearCombination\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">LinearCombination</span>.<span class=\"name\">linearCombination</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/LinearCombination.lean#L213-L217","name":"Mathlib.Tactic.LinearCombination.expStx","line":213,"kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.expStx","doc":"The `(exp := n)` syntax for `linear_combination` says to take the goal to the `n`th power before\nsubtracting the given combination of hypotheses.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.expStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">LinearCombination</span>.<span class=\"name\">expStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/LinearCombination.lean#L206-L211","name":"Mathlib.Tactic.LinearCombination.normStx","line":206,"kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.normStx","doc":"The `(norm := $tac)` syntax says to use `tac` as a normalization postprocessor for\n`linear_combination`. The default normalizer is `ring1`, but you can override it with `ring_nf`\nto get subgoals from `linear_combination` or with `skip` to disable normalization.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.normStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">LinearCombination</span>.<span class=\"name\">normStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/LinearCombination.lean#L154-L204","name":"Mathlib.Tactic.LinearCombination.elabLinearCombination","line":154,"kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.elabLinearCombination","doc":"Implementation of `linear_combination`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.elabLinearCombination\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">LinearCombination</span>.<span class=\"name\">elabLinearCombination</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tk</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">norm?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.Tactic\">Lean.Syntax.Tactic</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">exp?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.NumLit\">Lean.NumLit</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">input</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/LinearCombination.lean#L78-L152","name":"Mathlib.Tactic.LinearCombination.expandLinearCombo","line":78,"kind":"opaque","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.expandLinearCombo","doc":"Performs macro expansion of a linear combination expression,\nusing `+`/`-`/`*`/`/` on equations and values.\n* `.proof eq p` means that `p` is a syntax corresponding to a proof of an equation.\n  For example, if `h : a = b` then `expandLinearCombo (2 * h)` returns `.proof (c_add_pf 2 h)`\n  which is a proof of `2 * a = 2 * b`.\n  Similarly, `.proof le p` means that `p` is a syntax corresponding to a proof of a non-strict\n  inequality, and `.proof lt p` means that `p` is a syntax corresponding to a proof of a strict\n  inequality.\n* `.const c` means that the input expression is not an equation but a value.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.expandLinearCombo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">LinearCombination</span>.<span class=\"name\">expandLinearCombo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Expanded\">Expanded</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/LinearCombination.lean#L49-L76","name":"Mathlib.Tactic.LinearCombination.rescale","line":49,"kind":"def","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.rescale","doc":"The handling in `linear_combination` of left- and right-multiplication and scalar-multiplication\nand of division all five proceed according to the same logic, specified here: given a proof `p` of\nan (in)equality and a constant `c`,\n* if `p` is a proof of an equation, multiply/divide through by `c`;\n* if `p` is a proof of a non-strict inequality, run `positivity` to find a proof that `c` is\n  nonnegative, then multiply/divide through by `c`, invoking the nonnegativity of `c` where needed;\n* if `p` is a proof of a strict inequality, run `positivity` to find a proof that `c` is positive\n  (if possible) or nonnegative (if not), then multiply/divide through by `c`, invoking the\n  positivity or nonnegativity of `c` where needed.\n\nThis generic logic takes as a parameter the object `lems`: the four lemmas corresponding to the four\ncases. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.rescale\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">LinearCombination</span>.<span class=\"name\">rescale</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lems</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/LinearCombination/Lemmas.html#Mathlib.Ineq.WithStrictness\">Ineq.WithStrictness</a> → <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">c</span> : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ineq.html#Mathlib.Ineq\">Ineq</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Expanded\">Expanded</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/LinearCombination.lean#L46-L47","name":"Mathlib.Tactic.LinearCombination.Expanded.const","line":46,"kind":"ctor","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Expanded.const","doc":"A value, equivalently a proof of `c = c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Expanded.const\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">LinearCombination</span>.<span class=\"name\">Expanded</span>.<span class=\"name\">const</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Expanded\">Expanded</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/LinearCombination.lean#L44-L45","name":"Mathlib.Tactic.LinearCombination.Expanded.proof","line":44,"kind":"ctor","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Expanded.proof","doc":"A proof of `a = b`, `a ≤ b`, or `a < b` (according to the value of `Ineq`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Expanded.proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">LinearCombination</span>.<span class=\"name\">Expanded</span>.<span class=\"name\">proof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rel</span> : <a href=\"./Mathlib/Data/Ineq.html#Mathlib.Ineq\">Ineq</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Expanded\">Expanded</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/LinearCombination.lean#L42-L47","name":"Mathlib.Tactic.LinearCombination.Expanded","line":42,"kind":"inductive","docLink":"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Expanded","doc":"Result of `expandLinearCombo`, either an equality/inequality proof or a value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.Expanded\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">LinearCombination</span>.<span class=\"name\">Expanded</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}