{"name":"Mathlib.Logic.UnivLE","instances":[{"typeNames":[],"name":"UnivLE.self","className":"UnivLE"},{"typeNames":[],"name":"UnivLE.zero","className":"UnivLE"},{"typeNames":[],"name":"univLE_of_max","className":"UnivLE"}],"imports":["Init","Mathlib.Logic.Small.Defs"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L66-L66","name":"univLE_of_max","line":66,"kind":"instance","docLink":"./Mathlib/Logic/UnivLE.html#univLE_of_max","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#univLE_of_max\"><span class=\"name\">univLE_of_max</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{max u v, v}</a>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, v}</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L62-L63","name":"UnivLE.succ","line":62,"kind":"theorem","docLink":"./Mathlib/Logic/UnivLE.html#UnivLE.succ","doc":"This is redundant as an instance given the below. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#UnivLE.succ\"><span class=\"name\">UnivLE</span>.<span class=\"name\">succ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, v}</a>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, v + 1}</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L60-L60","name":"UnivLE.zero","line":60,"kind":"instance","docLink":"./Mathlib/Logic/UnivLE.html#UnivLE.zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#UnivLE.zero\"><span class=\"name\">UnivLE</span>.<span class=\"name\">zero</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{0, u}</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L59-L59","name":"UnivLE.self","line":59,"kind":"instance","docLink":"./Mathlib/Logic/UnivLE.html#UnivLE.self","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#UnivLE.self\"><span class=\"name\">UnivLE</span>.<span class=\"name\">self</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, u}</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L56-L57","name":"UnivLE.trans","line":56,"kind":"theorem","docLink":"./Mathlib/Logic/UnivLE.html#UnivLE.trans","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#UnivLE.trans\"><span class=\"name\">UnivLE</span>.<span class=\"name\">trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, v}</a>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{v, w}</a>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, w}</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L50-L54","name":"Small.trans_univLE","line":50,"kind":"theorem","docLink":"./Mathlib/Logic/UnivLE.html#Small.trans_univLE","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#Small.trans_univLE\"><span class=\"name\">Small</span>.<span class=\"name\">trans_univLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">hα</span> : <span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{u, w}</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">h</span> : <a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, v}</a>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{v, w}</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L48-L48","name":"univLE_max","line":48,"kind":"theorem","docLink":"./Mathlib/Logic/UnivLE.html#univLE_max","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#univLE_max\"><span class=\"name\">univLE_max</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, max u v}</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L42-L42","name":"UnivLE.small","line":42,"kind":"theorem","docLink":"./Mathlib/Logic/UnivLE.html#UnivLE.small","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#UnivLE.small\"><span class=\"name\">UnivLE</span>.<span class=\"name\">small</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, v}</a>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{v, u}</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L41-L41","name":"UnivLE.mk","line":41,"kind":"ctor","docLink":"./Mathlib/Logic/UnivLE.html#UnivLE.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#UnivLE.mk\"><span class=\"name\">UnivLE</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">small</span> : <span class=\"fn\">∀ (<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u), <span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{v, u}</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, v}</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L40-L40","name":"univLE_iff","line":40,"kind":"theorem","docLink":"./Mathlib/Logic/UnivLE.html#univLE_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#univLE_iff\"><span class=\"name\">univLE_iff</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Logic/UnivLE.html#UnivLE\">UnivLE.{u, v}</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u), <span class=\"fn\"><a href=\"./Mathlib/Logic/Small/Defs.html#Small\">Small.{v, u}</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/UnivLE.lean#L24-L42","name":"UnivLE","line":24,"kind":"class","docLink":"./Mathlib/Logic/UnivLE.html#UnivLE","doc":"A class expressing a universe inequality. `UnivLE.{u, v}` expresses that `u ≤ v`.\n\nThere used to be a stronger definition `∀ α : Type max u v, Small.{v} α` that immediately implies\n`Small.{v} ((α : Type u) → (β : Type v))` which is essential for proving that `Type v` has\n`Type u`-indexed limits when `u ≤ v`. However the current weaker condition\n`∀ α : Type u, Small.{v} α` also implies the same, so we switched to use it for\nits simplicity and transitivity.\n\nThe strong definition easily implies the weaker definition (see below),\nbut we can not prove the reverse implication.\nThis is because in Lean's type theory, while `max u v` is at least at big as `u` and `v`,\nit could be bigger than both!\nSee also `Mathlib.CategoryTheory.UnivLE` for the statement that the stronger definition is\nequivalent to `EssSurj (uliftFunctor : Type v ⥤ Type max u v)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/UnivLE.html#UnivLE\"><span class=\"name\">UnivLE</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"}]}