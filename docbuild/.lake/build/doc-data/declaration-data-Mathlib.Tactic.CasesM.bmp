{"name":"Mathlib.Tactic.CasesM","instances":[],"imports":["Init","Mathlib.Init","Lean.Elab.Tactic.Conv.Pattern"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L165-L179","name":"Mathlib.Tactic.constructorM","line":165,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorM","doc":"* `constructorm p_1, ..., p_n` applies the `constructor` tactic to the main goal\n  if `type` matches one of the given patterns.\n* `constructorm* p` is a more efficient and compact version of `· repeat constructorm p`.\n  It is more efficient because the pattern is compiled once.\n\nExample: The following tactic proves any theorem like `True ∧ (True ∨ True)` consisting of\nand/or/true:\n```\nconstructorm* _ ∨ _, _ ∧ _, True\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">constructorM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L156-L163","name":"Mathlib.Tactic.constructorMatching.go","line":156,"kind":"opaque","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorMatching.go","doc":"Auxiliary for `constructorMatching`. Accumulates generated subgoals in `acc`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorMatching.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">constructorMatching</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcher</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acc</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L135-L163","name":"Mathlib.Tactic.constructorMatching","line":135,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorMatching","doc":"Core tactic for `constructorm`. Calls `constructor` on all subgoals for which\n`matcher ldecl.type` returns true.\n* `recursive`: if true, it calls itself repeatedly on the resulting subgoals\n* `throwOnNoMatch`: if true, throws an error if no match is found\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorMatching\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">constructorMatching</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcher</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">throwOnNoMatch</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L131-L133","name":"Mathlib.Tactic.casesType!","line":131,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType!","doc":"* `cases_type I` applies the `cases` tactic to a hypothesis `h : (I ...)`\n* `cases_type I_1 ... I_n` applies the `cases` tactic to a hypothesis\n  `h : (I_1 ...)` or ... or `h : (I_n ...)`\n* `cases_type* I` is shorthand for `· repeat cases_type I`\n* `cases_type! I` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current goal.\n```\ncases_type* Or And\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesType!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L116-L129","name":"Mathlib.Tactic.casesType","line":116,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType","doc":"* `cases_type I` applies the `cases` tactic to a hypothesis `h : (I ...)`\n* `cases_type I_1 ... I_n` applies the `cases` tactic to a hypothesis\n  `h : (I_1 ...)` or ... or `h : (I_n ...)`\n* `cases_type* I` is shorthand for `· repeat cases_type I`\n* `cases_type! I` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current goal.\n```\ncases_type* Or And\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L110-L114","name":"Mathlib.Tactic.elabCasesType","line":110,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabCasesType","doc":"Common implementation of `cases_type` and `cases_type!`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabCasesType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabCasesType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heads</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Ident\">Lean.Ident</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowSplit</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L106-L108","name":"Mathlib.Tactic.casesm!","line":106,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesm!","doc":"* `casesm p` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches the pattern `p`.\n* `casesm p_1, ..., p_n` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches one of the given patterns.\n* `casesm* p` is a more efficient and compact version of `· repeat casesm p`.\n  It is more efficient because the pattern is compiled once.\n* `casesm! p` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current context.\n```\ncasesm* _ ∨ _, _ ∧ _\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesm!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesm!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L89-L104","name":"Mathlib.Tactic.casesM","line":89,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesM","doc":"* `casesm p` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches the pattern `p`.\n* `casesm p_1, ..., p_n` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches one of the given patterns.\n* `casesm* p` is a more efficient and compact version of `· repeat casesm p`.\n  It is more efficient because the pattern is compiled once.\n* `casesm! p` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current context.\n```\ncasesm* _ ∨ _, _ ∧ _\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L84-L87","name":"Mathlib.Tactic.elabCasesM","line":84,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabCasesM","doc":"Common implementation of `casesm` and `casesm!`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabCasesM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabCasesM</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pats</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive </span><span class=\"fn\">allowSplit</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L79-L82","name":"Mathlib.Tactic.matchPatterns","line":79,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.matchPatterns","doc":"Returns true if any of the patterns match the expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.matchPatterns\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">matchPatterns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pats</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Lean.Meta.AbstractMVarsResult</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L72-L77","name":"Mathlib.Tactic.elabPatterns","line":72,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabPatterns","doc":"Elaborate a list of terms with holes into a list of patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabPatterns\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabPatterns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pats</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Lean.Meta.AbstractMVarsResult</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L61-L65","name":"Lean.MVarId.casesType","line":61,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesType\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">casesType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heads</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowSplit</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L33-L59","name":"Lean.MVarId.casesMatching.go","line":33,"kind":"opaque","docLink":"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesMatching.go","doc":"Auxiliary for `casesMatching`. Accumulates generated subgoals in `acc`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesMatching.go\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">casesMatching</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcher</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowSplit</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acc</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CasesM.lean#L17-L59","name":"Lean.MVarId.casesMatching","line":17,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesMatching","doc":"Core tactic for `casesm` and `cases_type`. Calls `cases` on all fvars in `g` for which\n`matcher ldecl.type` returns true.\n* `recursive`: if true, it calls itself repeatedly on the resulting subgoals\n* `allowSplit`: if false, it will skip any hypotheses where `cases` returns more than one subgoal.\n* `throwOnNoMatch`: if true, then throws an error if no match is found\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesMatching\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">casesMatching</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matcher</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recursive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowSplit </span><span class=\"fn\">throwOnNoMatch</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>"}]}