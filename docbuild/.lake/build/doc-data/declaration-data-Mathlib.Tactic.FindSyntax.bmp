{"name":"Mathlib.Tactic.FindSyntax","instances":[],"imports":["Init","Lean.Elab.Command","Mathlib.Init"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/FindSyntax.lean#L55-L96","name":"Mathlib.FindSyntax.«command#find_syntax_Approx»","line":55,"kind":"def","docLink":"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.«command#find_syntax_Approx»","doc":"The `#find_syntax` command takes as input a string `str` and retrieves from the environment\nall the candidates for `syntax` terms that contain the string `str`.\n\nIt also makes a very crude effort at regenerating what the syntax looks like:\nthis is supposed to be just indicative of what the syntax may look like, but there is no\nguarantee or expectation of correctness.\n\nThe optional trailing `approx`, as in `#find_syntax \"∘\" approx`, is only intended to make tests\nmore stable: rather than outputting the exact count of the overall number of existing syntax\ndeclarations, it returns its round-down to the previous multiple of 100.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.«command#find_syntax_Approx»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">FindSyntax</span>.<span class=\"name\">«command#find_syntax_Approx»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/FindSyntax.lean#L45-L53","name":"Mathlib.FindSyntax.litToString","line":45,"kind":"def","docLink":"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.litToString","doc":"`litToString expr` converts the input `Expr`ession `expr` into the \"natural\" string that\nit corresponds to, in case `expr` is a `String`/`Nat`-literal, returning the empty string `\"\"`\notherwise.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.litToString\"><span class=\"name\">Mathlib</span>.<span class=\"name\">FindSyntax</span>.<span class=\"name\">litToString</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/FindSyntax.lean#L24-L43","name":"Mathlib.FindSyntax.extractSymbols","line":24,"kind":"def","docLink":"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.extractSymbols","doc":"`extractSymbols expr` takes as input an `Expr`ession `expr`, assuming that it is the `value`\nof a \"parser\".\nIt returns the array of all subterms of `expr` that are the `Expr.lit` argument to\n`Lean.ParserDescr.symbol` and `Lean.ParserDescr.nonReservedSymbol` applications.\n\nThe output array serves as a way of regenerating what the syntax tree of the input parser is.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.extractSymbols\"><span class=\"name\">Mathlib</span>.<span class=\"name\">FindSyntax</span>.<span class=\"name\">extractSymbols</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"}]}