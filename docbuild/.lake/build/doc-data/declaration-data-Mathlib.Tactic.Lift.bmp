{"name":"Mathlib.Tactic.Lift","instances":[{"typeNames":["Int","Nat"],"name":"instCanLiftIntNatCastLeOfNat","className":"CanLift"},{"typeNames":[],"name":"Pi.canLift","className":"CanLift"},{"typeNames":[],"name":"PiSubtype.canLift","className":"CanLift"},{"typeNames":[],"name":"PiSubtype.canLift'","className":"CanLift"},{"typeNames":["Subtype","Subtype.val"],"name":"Subtype.canLift","className":"CanLift"}],"imports":["Init","Mathlib.Tactic.Basic","Batteries.Lean.Expr","Batteries.Lean.Meta.UnusedNames"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L110-L161","name":"Mathlib.Tactic.Lift.main","line":110,"kind":"def","docLink":"./Mathlib/Tactic/Lift.html#Mathlib.Tactic.Lift.main","doc":"Main function for the `lift` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#Mathlib.Tactic.Lift.main\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lift</span>.<span class=\"name\">main</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">t</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`term</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hUsing</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`term</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newVarName </span><span class=\"fn\">newEqName</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`ident</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">keepUsing</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L102-L108","name":"Mathlib.Tactic.Lift.getInst","line":102,"kind":"def","docLink":"./Mathlib/Tactic/Lift.html#Mathlib.Tactic.Lift.getInst","doc":"Generate instance for the `lift` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#Mathlib.Tactic.Lift.getInst\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Lift</span>.<span class=\"name\">getInst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">old_tp </span><span class=\"fn\">new_tp</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L61-L100","name":"Mathlib.Tactic.lift","line":61,"kind":"def","docLink":"./Mathlib/Tactic/Lift.html#Mathlib.Tactic.lift","doc":"Lift an expression to another type.\n* Usage: `'lift' expr 'to' expr ('using' expr)? ('with' id (id id?)?)?`.\n* If `n : ℤ` and `hn : n ≥ 0` then the tactic `lift n to ℕ using hn` creates a new\n  constant of type `ℕ`, also named `n` and replaces all occurrences of the old variable `(n : ℤ)`\n  with `↑n` (where `n` in the new variable). It will remove `n` and `hn` from the context.\n  + So for example the tactic `lift n to ℕ using hn` transforms the goal\n    `n : ℤ, hn : n ≥ 0, h : P n ⊢ n = 3` to `n : ℕ, h : P ↑n ⊢ ↑n = 3`\n    (here `P` is some term of type `ℤ → Prop`).\n* The argument `using hn` is optional, the tactic `lift n to ℕ` does the same, but also creates a\n  new subgoal that `n ≥ 0` (where `n` is the old variable).\n  This subgoal will be placed at the top of the goal list.\n  + So for example the tactic `lift n to ℕ` transforms the goal\n    `n : ℤ, h : P n ⊢ n = 3` to two goals\n    `n : ℤ, h : P n ⊢ n ≥ 0` and `n : ℕ, h : P ↑n ⊢ ↑n = 3`.\n* You can also use `lift n to ℕ using e` where `e` is any expression of type `n ≥ 0`.\n* Use `lift n to ℕ with k` to specify the name of the new variable.\n* Use `lift n to ℕ with k hk` to also specify the name of the equality `↑k = n`. In this case, `n`\n  will remain in the context. You can use `rfl` for the name of `hk` to substitute `n` away\n  (i.e. the default behavior).\n* You can also use `lift e to ℕ with k hk` where `e` is any expression of type `ℤ`.\n  In this case, the `hk` will always stay in the context, but it will be used to rewrite `e` in\n  all hypotheses and the target.\n  + So for example the tactic `lift n + 3 to ℕ using hn with k hk` transforms the goal\n    `n : ℤ, hn : n + 3 ≥ 0, h : P (n + 3) ⊢ n + 3 = 2 * n` to the goal\n    `n : ℤ, k : ℕ, hk : ↑k = n + 3, h : P ↑k ⊢ ↑k = 2 * n`.\n* The tactic `lift n to ℕ using h` will remove `h` from the context. If you want to keep it,\n  specify it again as the third argument to `with`, like this: `lift n to ℕ using h with n rfl h`.\n* More generally, this can lift an expression from `α` to `β` assuming that there is an instance\n  of `CanLift α β`. In this case the proof obligation is specified by `CanLift.prf`.\n* Given an instance `CanLift β γ`, it can also lift `α → β` to `α → γ`; more generally, given\n  `β : Π a : α, Type*`, `γ : Π a : α, Type*`, and `[Π a : α, CanLift (β a) (γ a)]`, it\n  automatically generates an instance `CanLift (Π a, β a) (Π a, γ a)`.\n\n`lift` is in some sense dual to the `zify` tactic. `lift (z : ℤ) to ℕ` will change the type of an\ninteger `z` (in the supertype) to `ℕ` (the subtype), given a proof that `z ≥ 0`;\npropositions concerning `z` will still be over `ℤ`. `zify` changes propositions about `ℕ` (the\nsubtype) to propositions about `ℤ` (the supertype), without changing the type of any variable.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#Mathlib.Tactic.lift\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">lift</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L53-L55","name":"Subtype.canLift","line":53,"kind":"instance","docLink":"./Mathlib/Tactic/Lift.html#Subtype.canLift","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#Subtype.canLift\"><span class=\"name\">Subtype</span>.<span class=\"name\">canLift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Lift.html#CanLift\">CanLift</a> <span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Subtype\">{</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Subtype\">:</a> <span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Subtype\">//</a> <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Subtype\">}</a> <a href=\"./Init/Prelude.html#Subtype.val\">val</a> <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L49-L51","name":"PiSubtype.canLift'","line":49,"kind":"instance","docLink":"./Mathlib/Tactic/Lift.html#PiSubtype.canLift'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#PiSubtype.canLift'\"><span class=\"name\">PiSubtype</span>.<span class=\"name\">canLift'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ι</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_2)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Lift.html#CanLift\">CanLift</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">p</span></span> → <span class=\"fn\">α</span>)</span> <span class=\"fn\">(<span class=\"fn\">ι</span> → <span class=\"fn\">α</span>)</span> <span class=\"fn\">(fun (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">ι</span> → <span class=\"fn\">α</span></span>) (<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">p</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\"><span class=\"fn\">i</span>.<a href=\"./Init/Prelude.html#Subtype.val\">val</a></span></span>)</span> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">p</span></span> → <span class=\"fn\">α</span></span>) =&gt; <a href=\"./Init/Prelude.html#True\">True</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L44-L46","name":"PiSubtype.canLift","line":44,"kind":"instance","docLink":"./Mathlib/Tactic/Lift.html#PiSubtype.canLift","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#PiSubtype.canLift\"><span class=\"name\">PiSubtype</span>.<span class=\"name\">canLift</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ι</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\">α</span> <span class=\"fn\">i</span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Lift.html#CanLift\">CanLift</a> <span class=\"fn\">((<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">p</span></span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\"><span class=\"fn\">i</span>.<a href=\"./Init/Prelude.html#Subtype.val\">val</a></span></span>)</span> <span class=\"fn\">((<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span>)</span> <span class=\"fn\">(fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span></span>) (<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">p</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\"><span class=\"fn\">i</span>.<a href=\"./Init/Prelude.html#Subtype.val\">val</a></span></span>)</span>\n  <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">p</span></span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\"><span class=\"fn\">i</span>.<a href=\"./Init/Prelude.html#Subtype.val\">val</a></span></span></span>) =&gt; <a href=\"./Init/Prelude.html#True\">True</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L37-L42","name":"Subtype.exists_pi_extension","line":37,"kind":"theorem","docLink":"./Mathlib/Tactic/Lift.html#Subtype.exists_pi_extension","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#Subtype.exists_pi_extension\"><span class=\"name\">Subtype</span>.<span class=\"name\">exists_pi_extension</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">ι</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">ne</span> : <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\">α</span> <span class=\"fn\">i</span>)</span></span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">p</span></span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\"><span class=\"fn\">i</span>.<a href=\"./Init/Prelude.html#Subtype.val\">val</a></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Core.html#Exists\">∃</a> <a href=\"./Init/Core.html#Exists\">(</a><span class=\"fn\">g</span> <a href=\"./Init/Core.html#Exists\">:</a> <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span></span><a href=\"./Init/Core.html#Exists\">)</a><a href=\"./Init/Core.html#Exists\">,</a> <span class=\"fn\">(fun (<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">p</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\"><span class=\"fn\">i</span>.<a href=\"./Init/Prelude.html#Subtype.val\">val</a></span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L30-L35","name":"Pi.canLift","line":30,"kind":"instance","docLink":"./Mathlib/Tactic/Lift.html#Pi.canLift","doc":"Enable automatic handling of pi types in `CanLift`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#Pi.canLift\"><span class=\"name\">Pi</span>.<span class=\"name\">canLift</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ι</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">β</span> : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_3</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">coe</span> : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><a href=\"./Mathlib/Tactic/Lift.html#CanLift\">CanLift</a> <span class=\"fn\">(<span class=\"fn\">α</span> <span class=\"fn\">i</span>)</span> <span class=\"fn\">(<span class=\"fn\">β</span> <span class=\"fn\">i</span>)</span> <span class=\"fn\">(<span class=\"fn\">coe</span> <span class=\"fn\">i</span>)</span> <span class=\"fn\">(<span class=\"fn\">P</span> <span class=\"fn\">i</span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Lift.html#CanLift\">CanLift</a> <span class=\"fn\">((<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span>)</span> <span class=\"fn\">((<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span>)</span> <span class=\"fn\">(fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></span>) (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) =&gt; <span class=\"fn\"><span class=\"fn\">coe</span> <span class=\"fn\">i</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span>)</span> <span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span></span>) =&gt;\n  <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">i</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L27-L28","name":"instCanLiftIntNatCastLeOfNat","line":27,"kind":"instance","docLink":"./Mathlib/Tactic/Lift.html#instCanLiftIntNatCastLeOfNat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#instCanLiftIntNatCastLeOfNat\"><span class=\"name\">instCanLiftIntNatCastLeOfNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Lift.html#CanLift\">CanLift</a> <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">(fun (<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>) =&gt; <span class=\"fn\">↑<span class=\"fn\">n</span></span>)</span> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>) =&gt; <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L25-L25","name":"CanLift.prf","line":25,"kind":"theorem","docLink":"./Mathlib/Tactic/Lift.html#CanLift.prf","doc":"An element of `α` that satisfies `cond` belongs to the range of `coe`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#CanLift.prf\"><span class=\"name\">CanLift</span>.<span class=\"name\">prf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">coe</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">(<span class=\"fn\">β</span> → <span class=\"fn\">α</span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">(<span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Lift.html#CanLift\">CanLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">coe</span> <span class=\"fn\">cond</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">cond</span> <span class=\"fn\">x</span></span> → <a href=\"./Init/Core.html#Exists\">∃</a> <a href=\"./Init/Core.html#Exists\">(</a><span class=\"fn\">y</span> <a href=\"./Init/Core.html#Exists\">:</a> <span class=\"fn\">β</span><a href=\"./Init/Core.html#Exists\">)</a><a href=\"./Init/Core.html#Exists\">,</a> <span class=\"fn\"><span class=\"fn\">coe</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L23-L23","name":"CanLift.mk","line":23,"kind":"ctor","docLink":"./Mathlib/Tactic/Lift.html#CanLift.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#CanLift.mk\"><span class=\"name\">CanLift</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">coe</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">(<span class=\"fn\">β</span> → <span class=\"fn\">α</span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">(<span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prf</span> : <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">cond</span> <span class=\"fn\">x</span></span> → <a href=\"./Init/Core.html#Exists\">∃</a> <a href=\"./Init/Core.html#Exists\">(</a><span class=\"fn\">y</span> <a href=\"./Init/Core.html#Exists\">:</a> <span class=\"fn\">β</span><a href=\"./Init/Core.html#Exists\">)</a><a href=\"./Init/Core.html#Exists\">,</a> <span class=\"fn\"><span class=\"fn\">coe</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Lift.html#CanLift\">CanLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">coe</span> <span class=\"fn\">cond</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/Lift.lean#L21-L25","name":"CanLift","line":21,"kind":"class","docLink":"./Mathlib/Tactic/Lift.html#CanLift","doc":"A class specifying that you can lift elements from `α` to `β` assuming `cond` is true.\nUsed by the tactic `lift`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Lift.html#CanLift\"><span class=\"name\">CanLift</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Sort</a> u_2)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">coe</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">(<span class=\"fn\">β</span> → <span class=\"fn\">α</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">(<span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"}]}