{"name":"Mathlib.Tactic.CategoryTheory.Elementwise","instances":[],"imports":["Init","Mathlib.CategoryTheory.ConcreteCategory.Basic","Mathlib.Util.AddRelatedDecl","Batteries.Tactic.Lint"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L260-L260","name":"Tactic.Elementwise.tacticElementwise!___","line":260,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.tacticElementwise!___","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.tacticElementwise!___\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">tacticElementwise!___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L259-L259","name":"Tactic.Elementwise.tacticElementwise___","line":259,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.tacticElementwise___","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.tacticElementwise___\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">tacticElementwise___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L231-L256","name":"Tactic.Elementwise.¬´termElementwise_of%_¬ª","line":231,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.¬´termElementwise_of%_¬ª","doc":"`elementwise_of% h`, where `h` is a proof of an equation `f = g` between\nmorphisms `X ‚ü∂ Y` in a concrete category (possibly after a `‚àÄ` binder),\nproduces a proof of equation `‚àÄ (x : X), f x = g x`, but with compositions fully\nright associated and identities removed.\n\nA typical example is using `elementwise_of%` to dynamically generate rewrite lemmas:\n```lean\nexample (M N K : MonCat) (f : M ‚ü∂ N) (g : N ‚ü∂ K) (h : M ‚ü∂ K) (w : f ‚â´ g = h) (m : M) :\n    g (f m) = h m := by rw [elementwise_of% w]\n```\nIn this case, `elementwise_of% w` generates the lemma `‚àÄ (x : M), f (g x) = h x`.\n\nLike the `@[elementwise]` attribute, `elementwise_of%` inserts a `HasForget`\ninstance argument if it can't synthesize a relevant `HasForget` instance.\n(Technical note: The forgetful functor's universe variable is instantiated with a\nfresh level metavariable in this case.)\n\nOne difference between `elementwise_of%` and `@[elementwise]` is that `@[elementwise]` by\ndefault applies `simp` to both sides of the generated lemma to get something that is in simp\nnormal form. `elementwise_of%` does not do this.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.¬´termElementwise_of%_¬ª\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">¬´termElementwise_of%_¬ª</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L168-L206","name":"Tactic.Elementwise.elementwise","line":168,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwise","doc":"The `elementwise` attribute can be added to a lemma proving an equation of morphisms, and it\ncreates a new lemma for a `HasForget` giving an equation with those morphisms applied\nto some value.\n\nSyntax examples:\n- `@[elementwise]`\n- `@[elementwise nosimp]` to not use `simp` on both sides of the generated lemma\n- `@[elementwise (attr := simp)]` to apply the `simp` attribute to both the generated lemma and\n  the original lemma.\n\nExample application of `elementwise`:\n\n```lean\n@[elementwise]\nlemma some_lemma {C : Type*} [Category C]\n    {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : X ‚ü∂ Z) (w : ...) : f ‚â´ g = h := ...\n```\n\nproduces\n\n```lean\nlemma some_lemma_apply {C : Type*} [Category C]\n    {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : X ‚ü∂ Z) (w : ...)\n    [HasForget C] (x : X) : g (f x) = h x := ...\n```\n\nHere `X` is being coerced to a type via `CategoryTheory.HasForget.hasCoeToSort` and\n`f`, `g`, and `h` are being coerced to functions via `CategoryTheory.HasForget.hasCoeToFun`.\nFurther, we simplify the type using `CategoryTheory.coe_id : ((ùüô X) : X ‚Üí X) x = x` and\n`CategoryTheory.coe_comp : (f ‚â´ g) x = g (f x)`,\nreplacing morphism composition with function composition.\n\nThe `[HasForget C]` argument will be omitted if it is possible to synthesize an instance.\n\nThe name of the produced lemma can be specified with `@[elementwise other_lemma_name]`.\nIf `simp` is added first, the generated lemma will also have the `simp` attribute.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwise\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">elementwise</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L120-L153","name":"Tactic.Elementwise.elementwiseExpr.mkHomElementwise","line":120,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseExpr.mkHomElementwise","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseExpr.mkHomElementwise\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">elementwiseExpr</span>.<span class=\"name\">mkHomElementwise</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">Œ±</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">Œ±</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eqTy </span><span class=\"fn\">eqPf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> ‚Üí <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a> <a href=\"./Init/Prelude.html#Prod\">√ó</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a> <a href=\"./Init/Prelude.html#Prod\">√ó</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span> ‚Üí <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Œ±</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Œ±</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L114-L119","name":"Tactic.Elementwise.elementwiseExpr.extractCatInstance","line":114,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseExpr.extractCatInstance","doc":"Given an equality, extract a `Category` instance from it or raise an error.\nReturns the name of the category and its instance. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseExpr.extractCatInstance\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">elementwiseExpr</span>.<span class=\"name\">extractCatInstance</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eqTy</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">√ó</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L73-L153","name":"Tactic.Elementwise.elementwiseExpr","line":73,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseExpr","doc":"Given an equation `f = g` between morphisms `X ‚ü∂ Y` in a category `C`\n(possibly after a `‚àÄ` binder), produce the equation `‚àÄ (x : X), f x = g x` or\n`‚àÄ [HasForget C] (x : X), f x = g x` as needed (after the `‚àÄ` binder), but\nwith compositions fully right associated and identities removed.\n\nReturns the proof of the new theorem along with (optionally) a new level metavariable\nfor the first universe parameter to `HasForget`.\n\nThe `simpSides` option controls whether to simplify both sides of the equality, for simpNF\npurposes.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseExpr\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">elementwiseExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">src</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type </span><span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">simpSides</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">√ó</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a> <a href=\"./Init/Prelude.html#Prod\">√ó</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L57-L71","name":"Tactic.Elementwise.elementwiseThms","line":57,"kind":"def","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseThms","doc":"List of simp lemmas to apply to the elementwise theorem. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseThms\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">elementwiseThms</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L52-L53","name":"Tactic.Elementwise.hom_elementwise","line":52,"kind":"theorem","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.hom_elementwise","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.hom_elementwise\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">hom_elementwise</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.HasForget\">CategoryTheory.HasForget</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f </span><span class=\"fn\">g</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">‚ü∂</a> <span class=\"fn\">Y</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget\">CategoryTheory.forget</a> <span class=\"fn\">C</span>)</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">x</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L50-L50","name":"Tactic.Elementwise.forget_hom_Type","line":50,"kind":"theorem","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.forget_hom_Type","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.forget_hom_Type\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">forget_hom_Type</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Œ± </span><span class=\"fn\">Œ≤</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">Œ±</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">‚ü∂</a> <span class=\"fn\">Œ≤</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">‚áë<span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L45-L46","name":"Tactic.Elementwise.forall_congr_forget_Type","line":45,"kind":"theorem","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.forall_congr_forget_Type","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.forall_congr_forget_Type\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">forall_congr_forget_Type</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Œ±</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">Œ±</span> ‚Üí <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(‚àÄ (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget\">CategoryTheory.forget</a> <a href=\"./foundational_types.html\">(Type</a> u))</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj\">obj</a></span> <span class=\"fn\">Œ±</span></span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span></span>)</span> <a href=\"./Init/Core.html#Iff\">‚Üî</a> <span class=\"fn\">‚àÄ (<span class=\"fn\">x</span> : <span class=\"fn\">Œ±</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span></span></span></div></div>"}]}