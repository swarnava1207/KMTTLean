{"name":"Mathlib.Tactic.IntervalCases","instances":[],"imports":["Init","Mathlib.Tactic.NormNum","Mathlib.Tactic.FinCases","Mathlib.Control.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L322-L344","name":"Mathlib.Tactic.intervalCases","line":322,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.intervalCases","doc":"`interval_cases n` searches for upper and lower bounds on a variable `n`,\nand if bounds are found,\nsplits into separate cases for each possible value of `n`.\n\nAs an example, in\n```\nexample (n : ℕ) (w₁ : n ≥ 3) (w₂ : n < 5) : n = 3 ∨ n = 4 := by\n  interval_cases n\n  all_goals simp\n```\nafter `interval_cases n`, the goals are `3 = 3 ∨ 3 = 4` and `4 = 3 ∨ 4 = 4`.\n\nYou can also explicitly specify a lower and upper bound to use,\nas `interval_cases using hl, hu`.\nThe hypotheses should be in the form `hl : a ≤ n` and `hu : n < b`,\nin which case `interval_cases` calls `fin_cases` on the resulting fact `n ∈ Set.Ico a b`.\n\nYou can specify a name `h` for the new hypothesis,\nas `interval_cases h : n` or `interval_cases h : n using hl, hu`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.intervalCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">intervalCases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L248-L316","name":"Mathlib.Tactic.IntervalCases.intervalCases","line":248,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.intervalCases","doc":"`intervalCases` proves goal `g` by splitting into cases for each integer between the given bounds.\n\nParameters:\n* `g`: the goal, which can have any type `⊢ tgt` (it works in both proofs and programs)\n* `e`: the scrutinee, the expression we are proving is bounded between integers\n* `e'`: a version of `e` used for error messages. (This is used by the `interval_cases` frontend\n  tactic because it uses a fresh variable for `e`, so it is more helpful to show the\n  pre-generalized expression in error messages.)\n* `lbs`: A list of candidate lower bound expressions.\n  The tactic will automatically pick the best lower bound it can find from the list.\n* `ubs`: A list of candidate upper bound expressions.\n  The tactic will automatically pick the best upper bound it can find from the list.\n* `mustUseBounds`: If true, the tactic will fail if it is unable to parse any of the\n  given `ubs` or `lbs` into bounds. If false (the default), these will be silently skipped\n  and an error message is only produced if we could not find any bounds (including those supplied\n  by the type itself, e.g. if we are working over `Nat` or `Fin n`).\n\nReturns an array of `IntervalCasesSubgoal`, one per subgoal. A subgoal has the following fields:\n* `rhs`: the numeral expression for this case\n* `value`: the integral value of `rhs`\n* `goal`: the subgoal of type `⊢ e = rhs → tgt`\n\nNote that this tactic does not perform any substitution or introduction steps -\nall subgoals are in the same context as `goal` itself.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.intervalCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">intervalCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">e'</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lbs </span><span class=\"fn\">ubs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mustUseBounds</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal\">IntervalCasesSubgoal</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L234-L246","name":"Mathlib.Tactic.IntervalCases.intMethods","line":234,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.intMethods","doc":"A `Methods` implementation for `ℤ`.\nThis tells `interval_cases` how to work on integers. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.intMethods\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">intMethods</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L231-L232","name":"Int.le_sub_one_of_not_le","line":231,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Int.le_sub_one_of_not_le","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Int.le_sub_one_of_not_le\"><span class=\"name\">Int</span>.<span class=\"name\">le_sub_one_of_not_le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">1</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L229-L230","name":"Int.add_one_le_of_not_le","line":229,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Int.add_one_le_of_not_le","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Int.add_one_le_of_not_le\"><span class=\"name\">Int</span>.<span class=\"name\">add_one_le_of_not_le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L213-L227","name":"Mathlib.Tactic.IntervalCases.natMethods","line":213,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.natMethods","doc":"A `Methods` implementation for `ℕ`.\nThis tells `interval_cases` how to work on natural numbers. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.natMethods\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">natMethods</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L184-L211","name":"Mathlib.Tactic.IntervalCases.Methods.bisect","line":184,"kind":"opaque","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.bisect","doc":"Given `(z1, e1, p1)` a lower bound on `e` and `(z2, e2, p2)` an upper bound on `e`, such that the\ndistance between the bounds matches the number of `cases` in the subarray (which must be positive),\nproves the goal `g` using the metavariables in the array by recursive bisection.\nThis is the core of the tactic, producing a case tree of if statements which bottoms out\nat the `cases`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.bisect\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">bisect</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cases</span> : <span class=\"fn\"><a href=\"./Init/Data/Array/Subarray.html#Subarray\">Subarray</a> <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal\">IntervalCasesSubgoal</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">z1 </span><span class=\"fn\">z2</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\">Bound</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e1 </span><span class=\"fn\">e2 </span><span class=\"fn\">p1 </span><span class=\"fn\">p2 </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L164-L182","name":"Mathlib.Tactic.IntervalCases.Methods.inconsistentBounds","line":164,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.inconsistentBounds","doc":"Given `(z1, e1, p1)` a lower bound on `e` and `(z2, e2, p2)` an upper bound on `e`,\nsuch that the distance between the bounds is negative, returns a proof of `False`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.inconsistentBounds\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">inconsistentBounds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">z1 </span><span class=\"fn\">z2</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\">Bound</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e1 </span><span class=\"fn\">e2 </span><span class=\"fn\">p1 </span><span class=\"fn\">p2 </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L160-L162","name":"Mathlib.Tactic.IntervalCases.le_of_not_le_of_le","line":160,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.le_of_not_le_of_le","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.le_of_not_le_of_le\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">le_of_not_le_of_le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">hi </span><span class=\"fn\">n </span><span class=\"fn\">lo</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/LinearOrder.html#LinearOrder\">LinearOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">hi</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">n</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\">hi</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">lo</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">lo</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L133-L158","name":"Mathlib.Tactic.IntervalCases.Methods.getBound","line":133,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.getBound","doc":"Given a proof `pf`, attempts to parse it as an upper (`lb = false`) or lower (`lb = true`)\nbound on `n`. If successful, it returns `(bound, n, pf')` where `n` is a numeral and\n`pf'` proves `n ≤ e` or `n ≱ e` (as described by `bound`).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.getBound\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">getBound</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lb</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\">Bound</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L131-L131","name":"Mathlib.Tactic.IntervalCases.of_le_right","line":131,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_le_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_le_right\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">of_le_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">b'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b'</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L130-L130","name":"Mathlib.Tactic.IntervalCases.of_le_left","line":130,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_le_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_le_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">of_le_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L129-L129","name":"Mathlib.Tactic.IntervalCases.of_lt_right","line":129,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_lt_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_lt_right\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">of_lt_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">b'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/LinearOrder.html#LinearOrder\">LinearOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L128-L128","name":"Mathlib.Tactic.IntervalCases.of_lt_left","line":128,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_lt_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_lt_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">of_lt_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/LinearOrder.html#LinearOrder\">LinearOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a'</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L127-L127","name":"Mathlib.Tactic.IntervalCases.of_not_le_right","line":127,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_le_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_le_right\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">of_not_le_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">b'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b'</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L126-L126","name":"Mathlib.Tactic.IntervalCases.of_not_le_left","line":126,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_le_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_le_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">of_not_le_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L125-L125","name":"Mathlib.Tactic.IntervalCases.of_not_lt_right","line":125,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_lt_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_lt_right\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">of_not_lt_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">b'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/LinearOrder.html#LinearOrder\">LinearOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L124-L124","name":"Mathlib.Tactic.IntervalCases.of_not_lt_left","line":124,"kind":"theorem","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_lt_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_lt_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">of_not_lt_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/LinearOrder.html#LinearOrder\">LinearOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a'</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L120-L120","name":"Mathlib.Tactic.IntervalCases.Methods.mkNumeral","line":120,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.mkNumeral","doc":"Construct the canonical numeral for integer `z`, or fail if `z` is out of range. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.mkNumeral\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">mkNumeral</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L118-L118","name":"Mathlib.Tactic.IntervalCases.Methods.eval","line":118,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.eval","doc":"Given `e`, return `(z, n, p)` where `p : e = n` and `n` is a numeral\nappropriate for the type denoting the integer `z`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">eval</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L115-L115","name":"Mathlib.Tactic.IntervalCases.Methods.roundDown","line":115,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.roundDown","doc":"Given `a, b, b', p` where `p` proves `a ≱ b` and `b' := b-1`, prove `a ≤ b'`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.roundDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">roundDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L113-L113","name":"Mathlib.Tactic.IntervalCases.Methods.roundUp","line":113,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.roundUp","doc":"Given `a, b, a', p` where `p` proves `a ≱ b` and `a' := a+1`, prove `a' ≤ b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.roundUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">roundUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L111-L111","name":"Mathlib.Tactic.IntervalCases.Methods.proveLT","line":111,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.proveLT","doc":"Given `a, b`, prove `a ≱ b` or fail. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.proveLT\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">proveLT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L109-L109","name":"Mathlib.Tactic.IntervalCases.Methods.proveLE","line":109,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.proveLE","doc":"Given `a, b`, prove `a ≤ b` or fail. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.proveLE\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">proveLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L107-L107","name":"Mathlib.Tactic.IntervalCases.Methods.initUB","line":107,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.initUB","doc":"Given `e`, construct `(bound, n, p)` where `p` is a proof of `e ≤ n` or `e < n`\n(characterized by `bound`), or `failure` if the type is not upper-bounded. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.initUB\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">initUB</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\">Bound</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L104-L104","name":"Mathlib.Tactic.IntervalCases.Methods.initLB","line":104,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.initLB","doc":"Given `e`, construct `(bound, n, p)` where `p` is a proof of `n ≤ e` or `n < e`\n(characterized by `bound`), or `failure` if the type is not lower-bounded. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.initLB\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">initLB</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\">Bound</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L101-L101","name":"Mathlib.Tactic.IntervalCases.Methods.mk","line":101,"kind":"ctor","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">initLB </span><span class=\"fn\">initUB</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\">Bound</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proveLE </span><span class=\"fn\">proveLT</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">roundUp </span><span class=\"fn\">roundDown</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eval</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mkNumeral</span> : <span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\">Methods</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L98-L120","name":"Mathlib.Tactic.IntervalCases.Methods","line":98,"kind":"structure","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods","doc":"A \"typeclass\" (not actually a class) of methods for the type-specific handling of\n`interval_cases`. To add support for a new type, you have to implement this interface and add\na dispatch case for it in `intervalCases`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Methods</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L77-L96","name":"Mathlib.Tactic.IntervalCases.parseBound","line":77,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.parseBound","doc":"Given a type `ty` (the type of a hypothesis in the context or a provided expression),\nattempt to parse it as an inequality, and return `(a, b, strict, positive)`, where\n`positive` means it is a negated inequality and `strict` means it is a strict inequality\n(`a < b` or `a ≱ b`). `a` is always the lesser argument and `b` the greater one.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.parseBound\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">parseBound</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ty</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L65-L75","name":"Mathlib.Tactic.IntervalCases.Bound.asUpper","line":65,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asUpper","doc":"Assuming `Bound` represents an upper bound, this returns the (inclusive)\ngreatest integer value which is allowed. So `e ≤ 3` means the lower bound is 3 and\n`e < 3` means the upper bound is `2`. Note that in the case of `e < 0` on `Nat`\nthe upper bound is `-1`, which is not representable as a `Nat`;\nthis is why we have to treat the `.lt` and `.le` cases separately instead of normalizing\neverything to `.le` bounds.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asUpper\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Bound</span>.<span class=\"name\">asUpper</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\">Bound</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L56-L63","name":"Mathlib.Tactic.IntervalCases.Bound.asLower","line":56,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asLower","doc":"Assuming `Bound` represents a lower bound, this returns the (inclusive)\nleast integer value which is allowed. So `3 ≤ e` means the lower bound is 3 and\n`3 < e` means the lower bound is `4`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asLower\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Bound</span>.<span class=\"name\">asLower</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\">Bound</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L53-L54","name":"Mathlib.Tactic.IntervalCases.Bound.le","line":53,"kind":"ctor","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.le","doc":"A less-than-or-equal lower bound `n ≤ e` or upper bound `e ≤ n`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.le\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Bound</span>.<span class=\"name\">le</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\">Bound</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L49-L52","name":"Mathlib.Tactic.IntervalCases.Bound.lt","line":49,"kind":"ctor","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.lt","doc":"A strictly less-than lower bound `n ≱ e` or upper bound `e ≱ n`. (`interval_cases` uses\nless-equal exclusively, so less-than bounds are actually written as not-less-equal\nwith flipped arguments.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.lt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Bound</span>.<span class=\"name\">lt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\">Bound</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L42-L54","name":"Mathlib.Tactic.IntervalCases.Bound","line":42,"kind":"inductive","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound","doc":"A `Bound` represents the result of analyzing a lower or upper bound expression.\nIf `e` is the scrutinee expression, then a lower bound expression like `3 < e`\nis normalized to `¬e ≤ 3` and represented as `.lt 3`, and an upper bound expression\nlike `e ≤ 5` is represented as `.le 5`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">Bound</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L40-L40","name":"Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.goal","line":40,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.goal","doc":"The new subgoal, of the form `⊢ x = rhs → tgt` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.goal\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">IntervalCasesSubgoal</span>.<span class=\"name\">goal</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal\">IntervalCasesSubgoal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L38-L38","name":"Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.value","line":38,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.value","doc":"The numeric value of the target expression "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.value\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">IntervalCasesSubgoal</span>.<span class=\"name\">value</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal\">IntervalCasesSubgoal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L36-L36","name":"Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.rhs","line":36,"kind":"def","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.rhs","doc":"The target expression, a numeral in the input type "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.rhs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">IntervalCasesSubgoal</span>.<span class=\"name\">rhs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal\">IntervalCasesSubgoal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L34-L34","name":"Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.mk","line":34,"kind":"ctor","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">IntervalCasesSubgoal</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">value</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">goal</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal\">IntervalCasesSubgoal</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/IntervalCases.lean#L32-L40","name":"Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal","line":32,"kind":"structure","docLink":"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal","doc":"The result of `interval_cases` is a list of goals,\none for each integer value between the bounds. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">IntervalCases</span>.<span class=\"name\">IntervalCasesSubgoal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}