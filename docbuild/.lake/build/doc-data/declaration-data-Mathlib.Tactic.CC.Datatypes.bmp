{"name":"Mathlib.Tactic.CC.Datatypes","instances":[{"typeNames":["Mathlib.Tactic.CC.CCCongrTheoremKey"],"name":"Mathlib.Tactic.CC.instBEqCCCongrTheoremKey","className":"BEq"},{"typeNames":["Mathlib.Tactic.CC.CCCongrTheoremKey"],"name":"Mathlib.Tactic.CC.instHashableCCCongrTheoremKey","className":"Hashable"},{"typeNames":["Mathlib.Tactic.CC.CCConfig"],"name":"Mathlib.Tactic.CC.instInhabitedCCConfig","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.ACApps"],"name":"Mathlib.Tactic.CC.instInhabitedACApps","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.ACApps"],"name":"Mathlib.Tactic.CC.instBEqACApps","className":"BEq"},{"typeNames":["Lean.Expr","Mathlib.Tactic.CC.ACApps"],"name":"Mathlib.Tactic.CC.instCoeExprACApps","className":"Coe"},{"typeNames":["Mathlib.Tactic.CC.DelayedExpr"],"name":"Mathlib.Tactic.CC.instInhabitedDelayedExpr","className":"Inhabited"},{"typeNames":["Lean.Expr","Mathlib.Tactic.CC.DelayedExpr"],"name":"Mathlib.Tactic.CC.instCoeExprDelayedExpr","className":"Coe"},{"typeNames":["Mathlib.Tactic.CC.EntryExpr"],"name":"Mathlib.Tactic.CC.instInhabitedEntryExpr","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.EntryExpr"],"name":"Mathlib.Tactic.CC.instToMessageDataEntryExpr","className":"Lean.ToMessageData"},{"typeNames":["Lean.Expr","Mathlib.Tactic.CC.EntryExpr"],"name":"Mathlib.Tactic.CC.instCoeExprEntryExpr","className":"Coe"},{"typeNames":["Mathlib.Tactic.CC.Entry"],"name":"Mathlib.Tactic.CC.instInhabitedEntry","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.ACEntry"],"name":"Mathlib.Tactic.CC.instInhabitedACEntry","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.CongruencesKey"],"name":"Mathlib.Tactic.CC.instBEqCongruencesKey","className":"BEq"},{"typeNames":["Mathlib.Tactic.CC.CongruencesKey"],"name":"Mathlib.Tactic.CC.instHashableCongruencesKey","className":"Hashable"},{"typeNames":["Mathlib.Tactic.CC.SymmCongruencesKey"],"name":"Mathlib.Tactic.CC.instBEqSymmCongruencesKey","className":"BEq"},{"typeNames":["Mathlib.Tactic.CC.SymmCongruencesKey"],"name":"Mathlib.Tactic.CC.instHashableSymmCongruencesKey","className":"Hashable"},{"typeNames":["Mathlib.Tactic.CC.CCState"],"name":"Mathlib.Tactic.CC.instInhabitedCCState","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.CCStructure"],"name":"Mathlib.Tactic.CC.instInhabitedCCStructure","className":"Inhabited"}],"imports":["Init","Batteries.Data.RBMap.Basic","Mathlib.Lean.Meta.Basic","Mathlib.Lean.Meta.CongrTheorems","Mathlib.Data.Ordering.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L696-L696","name":"Mathlib.Tactic.CC.instInhabitedCCStructure","line":696,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCStructure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCStructure\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedCCStructure</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L695-L695","name":"Mathlib.Tactic.CC.CCStructure.cache","line":695,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.cache","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.cache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">cache</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\">CCCongrTheoremCache</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L694-L694","name":"Mathlib.Tactic.CC.CCStructure.phandler","line":694,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.phandler","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.phandler\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">phandler</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">CCPropagationHandler</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L693-L693","name":"Mathlib.Tactic.CC.CCStructure.normalizer","line":693,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.normalizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.normalizer\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">normalizer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">CCNormalizer</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L692-L692","name":"Mathlib.Tactic.CC.CCStructure.acTodo","line":692,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.acTodo","doc":"AC-equalities that have been discovered but not processed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.acTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">acTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">ACTodoEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L690-L690","name":"Mathlib.Tactic.CC.CCStructure.todo","line":690,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.todo","doc":"Equalities that have been discovered but not processed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.todo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">todo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">TodoEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L688-L688","name":"Mathlib.Tactic.CC.CCStructure.mk","line":688,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toCCState</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">todo</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">TodoEntry</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acTodo</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">ACTodoEntry</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">normalizer</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">CCNormalizer</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">phandler</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">CCPropagationHandler</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cache</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\">CCCongrTheoremCache</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L688-L696","name":"Mathlib.Tactic.CC.CCStructure.toCCState","line":688,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.toCCState","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.toCCState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">toCCState</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L685-L696","name":"Mathlib.Tactic.CC.CCStructure","line":685,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure","doc":"`CCStructure` extends `CCState` (which records a set of facts derived by congruence closure)\nby recording which steps still need to be taken to solve the goal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L683-L683","name":"Mathlib.Tactic.CC.CCPropagationHandler.newAuxCCTerm","line":683,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.newAuxCCTerm","doc":"Congruence closure module invokes the following method when\na new auxiliary term is created during propagation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.newAuxCCTerm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span>.<span class=\"name\">newAuxCCTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">CCPropagationHandler</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L680-L680","name":"Mathlib.Tactic.CC.CCPropagationHandler.propagated","line":680,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.propagated","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.propagated\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span>.<span class=\"name\">propagated</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">CCPropagationHandler</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L679-L679","name":"Mathlib.Tactic.CC.CCPropagationHandler.mk","line":679,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">propagated</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newAuxCCTerm</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">CCPropagationHandler</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L679-L683","name":"Mathlib.Tactic.CC.CCPropagationHandler","line":679,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L675-L675","name":"Mathlib.Tactic.CC.CCNormalizer.normalize","line":675,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.normalize","doc":"The congruence closure module (optionally) uses a normalizer.\nThe idea is to use it (if available) to normalize auxiliary expressions\nproduced by internal propagation rules (e.g., subsingleton propagator). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.normalize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCNormalizer</span>.<span class=\"name\">normalize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">CCNormalizer</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L674-L674","name":"Mathlib.Tactic.CC.CCNormalizer.mk","line":674,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCNormalizer</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">normalize</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">CCNormalizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L671-L675","name":"Mathlib.Tactic.CC.CCNormalizer","line":671,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer","doc":"The congruence closure module (optionally) uses a normalizer.\nThe idea is to use it (if available) to normalize auxiliary expressions\nproduced by internal propagation rules (e.g., subsingleton propagator). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCNormalizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L666-L667","name":"Mathlib.Tactic.CC.CCState.ppAC","line":666,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppAC","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L661-L664","name":"Mathlib.Tactic.CC.CCState.ppACR","line":661,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACR","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACR\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACR</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L655-L659","name":"Mathlib.Tactic.CC.CCState.ppACApps","line":655,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACApps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a> → <a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L649-L653","name":"Mathlib.Tactic.CC.CCState.ppACExpr","line":649,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L645-L647","name":"Mathlib.Tactic.CC.CCState.ppACDecls","line":645,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecls\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACDecls</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L640-L643","name":"Mathlib.Tactic.CC.CCState.ppACDecl","line":640,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L636-L638","name":"Mathlib.Tactic.CC.CCState.ppParentOccs","line":636,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppParentOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L628-L634","name":"Mathlib.Tactic.CC.CCState.ppParentOccsAux","line":628,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccsAux","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccsAux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppParentOccsAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L619-L626","name":"Mathlib.Tactic.CC.CCState.ppEqcs","line":619,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqcs","doc":"Pretty print the entire cc graph.\nIf the `nonSingleton` argument is set to `true` then singleton equivalence classes will be\nomitted. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqcs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppEqcs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nonSingleton</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L605-L617","name":"Mathlib.Tactic.CC.CCState.ppEqc","line":605,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqc","doc":"Pretty print the entry associated with the given expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L599-L601","name":"Mathlib.Tactic.CC.CCState.getVarWithLeastRHSOccs","line":599,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastRHSOccs","doc":"Search for the AC-variable (`Entry.acVar`) with the fewest occurrences in the RHS. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getVarWithLeastRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L595-L597","name":"Mathlib.Tactic.CC.CCState.getVarWithLeastLHSOccs","line":595,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastLHSOccs","doc":"Search for the AC-variable (`Entry.acVar`) with the fewest occurrences in the LHS. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastLHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getVarWithLeastLHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L580-L593","name":"Mathlib.Tactic.CC.CCState.getVarWithLeastOccs","line":580,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastOccs","doc":"Search for the AC-variable (`Entry.acVar`) with the least occurrences in the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getVarWithLeastOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L575-L578","name":"Mathlib.Tactic.CC.CCState.getNumROccs","line":575,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getNumROccs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getNumROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getNumROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L571-L573","name":"Mathlib.Tactic.CC.CCState.checkInvariant","line":571,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkInvariant","doc":"Check for integrity of the `CCState`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkInvariant\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">checkInvariant</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L549-L569","name":"Mathlib.Tactic.CC.CCState.checkEqc","line":549,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkEqc","doc":"Check for integrity of the `CCState`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">checkEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L538-L547","name":"Mathlib.Tactic.CC.CCState.getRoots","line":538,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getRoots","doc":"Append to `roots` all the roots of equivalence classes in `ccs`.\n\nIf `nonsingletonOnly` is true, we skip all the singleton equivalence classes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getRoots\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getRoots</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">roots</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nonsingletonOnly</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L532-L536","name":"Mathlib.Tactic.CC.CCState.inSingletonEqc","line":532,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inSingletonEqc","doc":"Is the expression in an equivalence class with only one element (namely, itself)? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inSingletonEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">inSingletonEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L521-L530","name":"Mathlib.Tactic.CC.CCState.mt","line":521,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mt","doc":"\"Modification Time\". The field `mt` is used to implement the mod-time optimization introduced by the\nSimplify theorem prover. The basic idea is to introduce a counter `gmt` that records the number of\nheuristic instantiation that have occurred in the current branch. It is incremented after each round\nof heuristic instantiation. The field `mt` records the last time any proper descendant of this\nentry was involved in a merge. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L515-L519","name":"Mathlib.Tactic.CC.CCState.isCgRoot","line":515,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.isCgRoot","doc":"Check if `e` is the root of the congruence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.isCgRoot\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">isCgRoot</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L508-L513","name":"Mathlib.Tactic.CC.CCState.next","line":508,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.next","doc":"Get the next element in the equivalence class.\nNote that if the given `Expr` `e` is not in the graph then it will just return `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.next\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">next</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L502-L506","name":"Mathlib.Tactic.CC.CCState.root","line":502,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.root","doc":"Get the root representative of the given expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.root\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">root</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L482-L498","name":"Mathlib.Tactic.CC.CCState.mkEntryCore","line":482,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mkEntryCore","doc":"Update the `CCState` by constructing and inserting a new `Entry`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mkEntryCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mkEntryCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">interpreted </span><span class=\"fn\">constructor</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L478-L478","name":"Mathlib.Tactic.CC.instInhabitedCCState","line":478,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCState","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedCCState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L477-L477","name":"Mathlib.Tactic.CC.CCState.gmt","line":477,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.gmt","doc":"\"Global Modification Time\". gmt is a number stored on the `CCState`,\nit is compared with the modification time of a cc_entry in e-matching. See `CCState.mt`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.gmt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">gmt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L474-L474","name":"Mathlib.Tactic.CC.CCState.inconsistent","line":474,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inconsistent","doc":"Returns true if the `CCState` is inconsistent. For example if it had both `a = b` and `a ≠ b`\nin it. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inconsistent\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">inconsistent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L471-L471","name":"Mathlib.Tactic.CC.CCState.acR","line":471,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acR","doc":"Records equality between `ACApps`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acR\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">acR</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsMap\">RBACAppsMap</a> (<a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L469-L469","name":"Mathlib.Tactic.CC.CCState.acEntries","line":469,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acEntries","doc":"Extra `Entry` information used by the AC part of the tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acEntries\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">acEntries</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">RBExprMap</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L467-L467","name":"Mathlib.Tactic.CC.CCState.opInfo","line":467,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.opInfo","doc":"Whether the canonical operator is supported by AC. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.opInfo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">opInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">RBExprMap</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L465-L465","name":"Mathlib.Tactic.CC.CCState.canOps","line":465,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.canOps","doc":"Mapping from operators occurring in terms and their canonical\nrepresentation in this module "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.canOps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">canOps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">RBExprMap</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L462-L462","name":"Mathlib.Tactic.CC.CCState.frozePartitions","line":462,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.frozePartitions","doc":"The congruence closure module has a mode where the root of each equivalence class is marked as\nan interpreted/abstract value. Moreover, in this mode proof production is disabled.\nThis capability is useful for heuristic instantiation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.frozePartitions\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">frozePartitions</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L458-L458","name":"Mathlib.Tactic.CC.CCState.instImplicitReprs","line":458,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.instImplicitReprs","doc":"Records which instances of the same class are defeq. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.instImplicitReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">instImplicitReprs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs\">InstImplicitReprs</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L456-L456","name":"Mathlib.Tactic.CC.CCState.subsingletonReprs","line":456,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.subsingletonReprs","doc":"Stores the root representatives of subsingletons, this uses `FastSingleton` instead of\n`Subsingleton`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.subsingletonReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">subsingletonReprs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs\">SubsingletonReprs</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L455-L455","name":"Mathlib.Tactic.CC.CCState.symmCongruences","line":455,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.symmCongruences","doc":"Maps each expression to a set of expressions it might be congruent to,\nvia the symmetrical relation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.symmCongruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">symmCongruences</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences\">SymmCongruences</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L452-L452","name":"Mathlib.Tactic.CC.CCState.congruences","line":452,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.congruences","doc":"Maps each expression to a set of expressions it might be congruent to. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.congruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">congruences</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences\">Congruences</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L450-L450","name":"Mathlib.Tactic.CC.CCState.parents","line":450,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.parents","doc":"Maps an expression `e` to the expressions `e` occurs in. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.parents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">parents</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents\">Parents</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L448-L448","name":"Mathlib.Tactic.CC.CCState.entries","line":448,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.entries","doc":"Maps known expressions to their equivalence class data. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.entries\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">entries</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries\">Entries</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L446-L446","name":"Mathlib.Tactic.CC.CCState.mk","line":446,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toCCConfig</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">entries</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries\">Entries</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parents</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents\">Parents</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">congruences</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences\">Congruences</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symmCongruences</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences\">SymmCongruences</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">subsingletonReprs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs\">SubsingletonReprs</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instImplicitReprs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs\">InstImplicitReprs</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">frozePartitions</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">canOps</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">RBExprMap</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">opInfo</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">RBExprMap</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acEntries</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">RBExprMap</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acR</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsMap\">RBACAppsMap</a> (<a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inconsistent</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">gmt</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L446-L478","name":"Mathlib.Tactic.CC.CCState.toCCConfig","line":446,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.toCCConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.toCCConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">toCCConfig</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L442-L478","name":"Mathlib.Tactic.CC.CCState","line":442,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState","doc":"Congruence closure state.\nThis may be considered to be a set of expressions and an equivalence class over this set.\nThe equivalence class is generated by the equational rules that are added to the `CCState` and\ncongruence, that is, if `a = b` then `f(a) = f(b)` and so on. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L440-L440","name":"Mathlib.Tactic.CC.ACTodoEntry","line":440,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACTodoEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L438-L438","name":"Mathlib.Tactic.CC.TodoEntry","line":438,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">TodoEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L435-L436","name":"Mathlib.Tactic.CC.InstImplicitReprs","line":435,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs","doc":"Stores the root representatives of `.instImplicit` arguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">InstImplicitReprs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L431-L433","name":"Mathlib.Tactic.CC.SubsingletonReprs","line":431,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs","doc":"Stores the root representatives of subsingletons, this uses `FastSingleton` instead of\n`Subsingleton`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SubsingletonReprs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L424-L429","name":"Mathlib.Tactic.CC.SymmCongruences","line":424,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences","doc":"The symmetric variant of `Congruences`.\n\nThe `Name` identifies which relation the congruence is considered for.\nNote that this only works for two-argument relations: `ModEq n` and `ModEq m` are considered the\nsame. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruences</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L422-L422","name":"Mathlib.Tactic.CC.instHashableSymmCongruencesKey","line":422,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableSymmCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableSymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instHashableSymmCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L422-L422","name":"Mathlib.Tactic.CC.instBEqSymmCongruencesKey","line":422,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqSymmCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqSymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqSymmCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L421-L421","name":"Mathlib.Tactic.CC.SymmCongruencesKey.h₂","line":421,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₂","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₂\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span>.<span class=\"name\">h₂</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L421-L421","name":"Mathlib.Tactic.CC.SymmCongruencesKey.h₁","line":421,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₁","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span>.<span class=\"name\">h₁</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L420-L420","name":"Mathlib.Tactic.CC.SymmCongruencesKey.mk","line":420,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁ </span><span class=\"fn\">h₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L420-L422","name":"Mathlib.Tactic.CC.SymmCongruencesKey","line":420,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L417-L418","name":"Mathlib.Tactic.CC.Congruences","line":417,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences","doc":"Maps each expression (via `mkCongruenceKey`) to expressions it might be congruent to. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Congruences</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L415-L415","name":"Mathlib.Tactic.CC.instHashableCongruencesKey","line":415,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instHashableCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">CongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L415-L415","name":"Mathlib.Tactic.CC.instBEqCongruencesKey","line":415,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">CongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L413-L414","name":"Mathlib.Tactic.CC.CongruencesKey.ho","line":413,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.ho","doc":"`fn` is Higher-Order. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.ho\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CongruencesKey</span>.<span class=\"name\">ho</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fn </span><span class=\"fn\">arg</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">CongruencesKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L411-L412","name":"Mathlib.Tactic.CC.CongruencesKey.fo","line":411,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.fo","doc":"`fn` is First-Order: we do not consider all partial applications. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.fo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CongruencesKey</span>.<span class=\"name\">fo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fn</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">CongruencesKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L410-L415","name":"Mathlib.Tactic.CC.CongruencesKey","line":410,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L405-L408","name":"Mathlib.Tactic.CC.Parents","line":405,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents","doc":"Used to map an expression `e` to another expression that contains `e`.\n\nWhen `e` is normalized, its parents should also change. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Parents</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L402-L403","name":"Mathlib.Tactic.CC.ParentOccSet","line":402,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOccSet","doc":"Red-black sets of `ParentOcc`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOccSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOccSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L400-L400","name":"Mathlib.Tactic.CC.ParentOcc.symmTable","line":400,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.symmTable","doc":"If `symmTable` is true, then we should use the `symmCongruences`, otherwise `congruences`.\nRemark: this information is redundant, it can be inferred from `expr`. We use store it for\nperformance reasons. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.symmTable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span>.<span class=\"name\">symmTable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\">ParentOcc</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L396-L396","name":"Mathlib.Tactic.CC.ParentOcc.expr","line":396,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.expr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.expr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span>.<span class=\"name\">expr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\">ParentOcc</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L395-L395","name":"Mathlib.Tactic.CC.ParentOcc.mk","line":395,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symmTable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\">ParentOcc</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L394-L400","name":"Mathlib.Tactic.CC.ParentOcc","line":394,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc","doc":"Used to record when an expression processed by `cc` occurs in another expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L389-L392","name":"Mathlib.Tactic.CC.ACEntry.ROccs","line":389,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.ROccs","doc":"Returns the occurrences of this entry in either the LHS or RHS. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.ROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">ROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ent</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet\">RBACAppsSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L387-L387","name":"Mathlib.Tactic.CC.instInhabitedACEntry","line":387,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedACEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L386-L386","name":"Mathlib.Tactic.CC.ACEntry.RRHSOccs","line":386,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RRHSOccs","doc":"AC variables that occur on the **left** hand side of an equality which `e` occurs as the right\nhand side of in `CCState.acR`. Don't confuse. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">RRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet\">RBACAppsSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L383-L383","name":"Mathlib.Tactic.CC.ACEntry.RLHSOccs","line":383,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RLHSOccs","doc":"AC variables that occur on the left hand side of an equality which `e` occurs as the left hand\nside of in `CCState.acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RLHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">RLHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet\">RBACAppsSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L380-L380","name":"Mathlib.Tactic.CC.ACEntry.idx","line":380,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.idx","doc":"Natural number associated to an expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.idx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">idx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L378-L378","name":"Mathlib.Tactic.CC.ACEntry.mk","line":378,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">idx</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">RLHSOccs </span><span class=\"fn\">RRHSOccs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet\">RBACAppsSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">ACEntry</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L376-L387","name":"Mathlib.Tactic.CC.ACEntry","line":376,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry","doc":"Equivalence class data associated with an expression `e` used by AC congruence closure\nmodules. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L373-L374","name":"Mathlib.Tactic.CC.Entries","line":373,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries","doc":"Stores equivalence class data associated with an expression `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entries</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L371-L371","name":"Mathlib.Tactic.CC.instInhabitedEntry","line":371,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L370-L370","name":"Mathlib.Tactic.CC.Entry.mt","line":370,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mt","doc":"The field `mt` is used to implement the mod-time optimization introduce by the Simplify\ntheorem prover. The basic idea is to introduce a counter gmt that records the number of\nheuristic instantiation that have occurred in the current branch. It is incremented after each\nround of heuristic instantiation. The field `mt` records the last time any proper descendant\nof this entry was involved in a merge. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">mt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L364-L364","name":"Mathlib.Tactic.CC.Entry.size","line":364,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.size","doc":"number of elements in the equivalence class, it is meaningless if `e != root` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.size\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L362-L362","name":"Mathlib.Tactic.CC.Entry.fo","line":362,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.fo","doc":"If `fo == true`, then the expression associated with this entry is an application, and we are\nusing first-order approximation to encode it. That is, we ignore its partial applications. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.fo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">fo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L359-L359","name":"Mathlib.Tactic.CC.Entry.heqProofs","line":359,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.heqProofs","doc":"`heqProofs == true` iff some proofs in the equivalence class are based on heterogeneous\nequality. We represent equality and heterogeneous equality in a single equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.heqProofs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">heqProofs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L356-L356","name":"Mathlib.Tactic.CC.Entry.hasLambdas","line":356,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.hasLambdas","doc":"`true` if equivalence class contains lambda expressions "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.hasLambdas\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">hasLambdas</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L354-L354","name":"Mathlib.Tactic.CC.Entry.constructor","line":354,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.constructor","doc":"`true` if head symbol is a constructor "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.constructor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">constructor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L352-L352","name":"Mathlib.Tactic.CC.Entry.interpreted","line":352,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.interpreted","doc":"`true` if the node should be viewed as an abstract value "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.interpreted\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">interpreted</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L350-L350","name":"Mathlib.Tactic.CC.Entry.flipped","line":350,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.flipped","doc":"proof has been flipped "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.flipped\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">flipped</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L348-L348","name":"Mathlib.Tactic.CC.Entry.acVar","line":348,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.acVar","doc":"Variable in the AC theory. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.acVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">acVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L346-L346","name":"Mathlib.Tactic.CC.Entry.proof","line":346,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.proof","doc":"When `e` was added to this equivalence class because of an equality `(H : e = tgt)`, then\nwe store `tgt` at `target`, and `H` at `proof`. Both fields are none if `e == root` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">proof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L343-L343","name":"Mathlib.Tactic.CC.Entry.target","line":343,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.target","doc":"When `e` was added to this equivalence class because of an equality `(H : e = tgt)`, then\nwe store `tgt` at `target`, and `H` at `proof`. Both fields are none if `e == root` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.target\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">target</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L340-L340","name":"Mathlib.Tactic.CC.Entry.cgRoot","line":340,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.cgRoot","doc":"root of the congruence class, it is meaningless if `e` is not an application. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.cgRoot\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">cgRoot</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L338-L338","name":"Mathlib.Tactic.CC.Entry.root","line":338,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.root","doc":"root (aka canonical) representative of the equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.root\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">root</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L336-L336","name":"Mathlib.Tactic.CC.Entry.next","line":336,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.next","doc":"next element in the equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.next\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">next</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L334-L334","name":"Mathlib.Tactic.CC.Entry.mk","line":334,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">next </span><span class=\"fn\">root </span><span class=\"fn\">cgRoot</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">target</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">acVar</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">flipped </span><span class=\"fn\">interpreted </span><span class=\"fn\">constructor </span><span class=\"fn\">hasLambdas </span><span class=\"fn\">heqProofs </span><span class=\"fn\">fo</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">size </span><span class=\"fn\">mt</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Entry</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L333-L371","name":"Mathlib.Tactic.CC.Entry","line":333,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry","doc":"Equivalence class data associated with an expression `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L330-L330","name":"Mathlib.Tactic.CC.instCoeExprEntryExpr","line":330,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprEntryExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprEntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instCoeExprEntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L322-L328","name":"Mathlib.Tactic.CC.instToMessageDataEntryExpr","line":322,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instToMessageDataEntryExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instToMessageDataEntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instToMessageDataEntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L320-L320","name":"Mathlib.Tactic.CC.instInhabitedEntryExpr","line":320,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntryExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedEntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L318-L319","name":"Mathlib.Tactic.CC.EntryExpr.ofDExpr","line":318,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofDExpr","doc":"An `EntryExpr` of a `DelayedExpr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofDExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">ofDExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L316-L317","name":"Mathlib.Tactic.CC.EntryExpr.refl","line":316,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.refl","doc":"dummy refl proof, it is just a placeholder. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.refl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">refl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L314-L315","name":"Mathlib.Tactic.CC.EntryExpr.eqTrue","line":314,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.eqTrue","doc":"dummy eq_true proof, it is just a placeholder "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.eqTrue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">eqTrue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L312-L313","name":"Mathlib.Tactic.CC.EntryExpr.congr","line":312,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.congr","doc":"dummy congruence proof, it is just a placeholder. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">congr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L310-L311","name":"Mathlib.Tactic.CC.EntryExpr.ofExpr","line":310,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofExpr","doc":"An `EntryExpr` of just an `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">ofExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L308-L320","name":"Mathlib.Tactic.CC.EntryExpr","line":308,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr","doc":"This is used as a proof term in `Entry`s instead of `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L305-L305","name":"Mathlib.Tactic.CC.instCoeExprDelayedExpr","line":305,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprDelayedExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprDelayedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instCoeExprDelayedExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L303-L303","name":"Mathlib.Tactic.CC.instInhabitedDelayedExpr","line":303,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedDelayedExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedDelayedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedDelayedExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L301-L302","name":"Mathlib.Tactic.CC.DelayedExpr.heqSymm","line":301,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqSymm","doc":"Will be applied to `HEq.symm`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqSymm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">heqSymm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L299-L300","name":"Mathlib.Tactic.CC.DelayedExpr.heqOfEq","line":299,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqOfEq","doc":"Will be applied to `heq_of_eq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqOfEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">heqOfEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L297-L298","name":"Mathlib.Tactic.CC.DelayedExpr.eqTransOpt","line":297,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTransOpt","doc":"Will be applied to `Eq.trans`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTransOpt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqTransOpt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁ </span><span class=\"fn\">a₂ </span><span class=\"fn\">a₃</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁ </span><span class=\"fn\">h₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L295-L296","name":"Mathlib.Tactic.CC.DelayedExpr.eqTrans","line":295,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTrans","doc":"Will be applied to `Eq.trans`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTrans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqTrans</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁ </span><span class=\"fn\">h₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L293-L294","name":"Mathlib.Tactic.CC.DelayedExpr.eqSymmOpt","line":293,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymmOpt","doc":"Will be applied to `Eq.symm`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymmOpt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqSymmOpt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L291-L292","name":"Mathlib.Tactic.CC.DelayedExpr.eqSymm","line":291,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymm","doc":"Will be applied to `Eq.symm`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqSymm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L289-L290","name":"Mathlib.Tactic.CC.DelayedExpr.congrFun","line":289,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrFun","doc":"Will be applied to `congr_fun`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrFun\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">congrFun</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L287-L288","name":"Mathlib.Tactic.CC.DelayedExpr.congrArg","line":287,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrArg","doc":"Will be applied to `congr_arg`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrArg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">congrArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L284-L286","name":"Mathlib.Tactic.CC.DelayedExpr.eqProof","line":284,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqProof","doc":"A placeholder as an equality proof between given two terms which will be generated by non-AC\ncongruence closure modules later. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L282-L283","name":"Mathlib.Tactic.CC.DelayedExpr.ofExpr","line":282,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.ofExpr","doc":"A `DelayedExpr` of just an `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.ofExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">ofExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L278-L303","name":"Mathlib.Tactic.CC.DelayedExpr","line":278,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr","doc":"For proof terms generated by AC congruence closure modules, we want a placeholder as an equality\nproof between given two terms which will be generated by non-AC congruence closure modules later.\n`DelayedExpr` represents it using `eqProof`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L270-L276","name":"Mathlib.Tactic.CC.RBACAppsSet","line":270,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet","doc":"Red-black sets of `ACApps`es.\n\nTODO: the choice between `RBSet` and `HashSet` is not obvious:\nthe current version follows the Lean 3 C++ implementation.\nOnce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashSet` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">RBACAppsSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L262-L268","name":"Mathlib.Tactic.CC.RBACAppsMap","line":262,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsMap","doc":"Red-black maps whose keys are `ACApps`es.\n\nTODO: the choice between `RBMap` and `HashMap` is not obvious:\nthe current version follows the Lean 3 C++ implementation.\nOnce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashMap` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">RBACAppsMap</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L256-L260","name":"Mathlib.Tactic.CC.ACApps.toExpr","line":256,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.toExpr","doc":"Converts an `ACApps` to an `Expr`. This returns `none` when the empty applications are given. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.toExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">toExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L248-L254","name":"Mathlib.Tactic.CC.ACApps.mkFlatApps","line":248,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkFlatApps","doc":"Flattens given two `ACApps`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkFlatApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">mkFlatApps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L244-L246","name":"Mathlib.Tactic.CC.ACApps.mkApps","line":244,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkApps","doc":"Sorts `args` and applies them to `ACApps.apps`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">mkApps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L225-L242","name":"Mathlib.Tactic.CC.ACApps.intersection","line":225,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.intersection","doc":"Appends elements in the intersection of `e₁` and `e₂` to `r`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.intersection\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">intersection</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L217-L223","name":"Mathlib.Tactic.CC.ACApps.append","line":217,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.append","doc":"Appends arguments of `e` to `r`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.append\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">append</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L187-L215","name":"Mathlib.Tactic.CC.ACApps.diff","line":187,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.diff","doc":"Appends elements of the set difference `e₁ \\ e₂` to `r`.\nExample: given `e₁ := a*a*a*a*b*b*c*d*d*d` and `e₂ := a*a*a*b*b*d`,\nthe result is `#[a, c, d, d]`\n\nPrecondition: `e₂.isSubset e₁` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.diff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">diff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L163-L185","name":"Mathlib.Tactic.CC.ACApps.isSubset","line":163,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.isSubset","doc":"Return true iff `e₁` is a \"subset\" of `e₂`.\n\nExample: The result is `true` for `e₁ := a*a*a*b*d` and `e₂ := a*a*a*a*b*b*c*d*d`.\nThe result is also `true` for `e₁ := a` and `e₂ := a*a*a*b*c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.isSubset\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">isSubset</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L148-L161","name":"Mathlib.Tactic.CC.instOrdACApps","line":148,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdACApps","doc":"Ordering on `ACApps` sorts `.ofExpr` before `.apps`, and sorts `.apps` by function symbol,\nthen by shortlex order. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instOrdACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L145-L145","name":"Mathlib.Tactic.CC.instCoeExprACApps","line":145,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instCoeExprACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L143-L143","name":"Mathlib.Tactic.CC.instBEqACApps","line":143,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L143-L143","name":"Mathlib.Tactic.CC.instInhabitedACApps","line":143,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L139-L142","name":"Mathlib.Tactic.CC.ACApps.apps","line":139,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.apps","doc":"An `ACApps` of applications of a binary operator. `args` are assumed to be sorted.\n\nSee also `ACApps.mkApps` if `args` are not yet sorted. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.apps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">apps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L137-L138","name":"Mathlib.Tactic.CC.ACApps.ofExpr","line":137,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.ofExpr","doc":"An `ACApps` of just an `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.ofExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">ofExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L134-L143","name":"Mathlib.Tactic.CC.ACApps","line":134,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps","doc":"An `ACApps` represents either just an `Expr` or applications of an associative and commutative\nbinary operator. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L132-L132","name":"Mathlib.Tactic.CC.instInhabitedCCConfig","line":132,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedCCConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L131-L131","name":"Mathlib.Tactic.CC.CCConfig.values","line":131,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.values","doc":"If `true`, we treat values as atomic symbols "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.values\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">values</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L129-L129","name":"Mathlib.Tactic.CC.CCConfig.em","line":129,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.em","doc":"If `true`, then use excluded middle "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.em\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">em</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L127-L127","name":"Mathlib.Tactic.CC.CCConfig.hoFns","line":127,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.hoFns","doc":"If `hoFns` is `some fns`, then full (and more expensive) support for higher-order functions is\n*only* considered for the functions in fns and local functions. The performance overhead is\ndescribed in the paper \"Congruence Closure in Intensional Type Theory\". If `hoFns` is `none`,\nthen full support is provided for *all* constants. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.hoFns\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">hoFns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L122-L122","name":"Mathlib.Tactic.CC.CCConfig.ac","line":122,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ac","doc":"If `true`, congruence closure modulo Associativity and Commutativity. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ac\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">ac</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L120-L120","name":"Mathlib.Tactic.CC.CCConfig.ignoreInstances","line":120,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ignoreInstances","doc":"If `true`, congruence closure will treat implicit instance arguments as constants.\n\nThis means that setting `ignoreInstances := false` will fail to unify two definitionally equal\ninstances of the same class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ignoreInstances\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">ignoreInstances</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L115-L115","name":"Mathlib.Tactic.CC.CCConfig.mk","line":115,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ignoreInstances </span><span class=\"fn\">ac</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hoFns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">em </span><span class=\"fn\">values</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">CCConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L114-L132","name":"Mathlib.Tactic.CC.CCConfig","line":114,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig","doc":"Configs used in congruence closure modules. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L111-L112","name":"Mathlib.Tactic.CC.CCCongrTheoremCache","line":111,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache","doc":"Caches used to find corresponding `CCCongrTheorem`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremCache</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L109-L109","name":"Mathlib.Tactic.CC.instHashableCCCongrTheoremKey","line":109,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCCCongrTheoremKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCCCongrTheoremKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instHashableCCCongrTheoremKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">CCCongrTheoremKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L109-L109","name":"Mathlib.Tactic.CC.instBEqCCCongrTheoremKey","line":109,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCCCongrTheoremKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCCCongrTheoremKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqCCCongrTheoremKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">CCCongrTheoremKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L108-L108","name":"Mathlib.Tactic.CC.CCCongrTheoremKey.nargs","line":108,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.nargs","doc":"The number of arguments of `fn`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.nargs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span>.<span class=\"name\">nargs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">CCCongrTheoremKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L106-L106","name":"Mathlib.Tactic.CC.CCCongrTheoremKey.fn","line":106,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.fn","doc":"The function of the given `CCCongrTheorem`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.fn\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span>.<span class=\"name\">fn</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">CCCongrTheoremKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L104-L104","name":"Mathlib.Tactic.CC.CCCongrTheoremKey.mk","line":104,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fn</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nargs</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">CCCongrTheoremKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L103-L109","name":"Mathlib.Tactic.CC.CCCongrTheoremKey","line":103,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey","doc":"Keys used to find corresponding `CCCongrTheorem`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L94-L101","name":"Mathlib.Tactic.CC.mkCCHCongrWithArity","line":94,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.mkCCHCongrWithArity","doc":"Automatically generated congruence lemma based on heterogeneous equality.\n\nThis returns an annotated version of the result from `Lean.Meta.mkHCongrWithArity`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.mkCCHCongrWithArity\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">mkCCHCongrWithArity</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fn</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nargs</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">CCCongrTheorem</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L92-L92","name":"Mathlib.Tactic.CC.CCCongrTheorem.hcongrTheorem","line":92,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.hcongrTheorem","doc":"If `hcongrTheorem` is true, then lemma was created using `mkHCongrWithArity`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.hcongrTheorem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">hcongrTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">CCCongrTheorem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L90-L90","name":"Mathlib.Tactic.CC.CCCongrTheorem.heqResult","line":90,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.heqResult","doc":"If `heqResult` is true, then lemma is based on heterogeneous equality\nand the conclusion is a heterogeneous equality. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.heqResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">heqResult</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">CCCongrTheorem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L87-L87","name":"Mathlib.Tactic.CC.CCCongrTheorem.mk","line":87,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toCongrTheorem</span> : <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqResult </span><span class=\"fn\">hcongrTheorem</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">CCCongrTheorem</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L87-L92","name":"Mathlib.Tactic.CC.CCCongrTheorem.toCongrTheorem","line":87,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.toCongrTheorem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.toCongrTheorem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">toCongrTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">CCCongrTheorem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L86-L92","name":"Mathlib.Tactic.CC.CCCongrTheorem","line":86,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem","doc":"`CongrTheorem`s equipped with additional infos used by congruence closure modules. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L78-L84","name":"Mathlib.Tactic.CC.RBExprSet","line":78,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprSet","doc":"Red-black sets of `Expr`s.\n\nTODO: the choice between `RBSet` and `HashSet` is not obvious:\nthe current version follows the Lean 3 C++ implementation.\nOnce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashSet` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">RBExprSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L70-L76","name":"Mathlib.Tactic.CC.RBExprMap","line":70,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap","doc":"Red-black maps whose keys are `Expr`s.\n\nTODO: the choice between `RBMap` and `HashMap` is not obvious:\nthe current version follows the Lean 3 C++ implementation.\nOnce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashMap` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">RBExprMap</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L66-L68","name":"Mathlib.Tactic.CC.instOrdExpr_mathlib","line":66,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdExpr_mathlib","doc":"Ordering on `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdExpr_mathlib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instOrdExpr_mathlib</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L45-L64","name":"Mathlib.Tactic.CC.liftFromEq","line":45,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.liftFromEq","doc":"Given a reflexive relation `R`, and a proof `H : a = b`, build a proof for `R a b` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.liftFromEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">liftFromEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L32-L43","name":"Mathlib.Tactic.CC.isInterpretedValue","line":32,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isInterpretedValue","doc":"Return true if `e` represents a value (nat/int numeral, character, or string).\n\nIn addition to the conditions in `Mathlib.Tactic.CC.isValue`, this also checks that\nkernel computation can compare the values for equality. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isInterpretedValue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">isInterpretedValue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Tactic/CC/Datatypes.lean#L28-L30","name":"Mathlib.Tactic.CC.isValue","line":28,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isValue","doc":"Return true if `e` represents a constant value (numeral, character, or string). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isValue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">isValue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"}]}