<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Data.Ordmap.Ordnode</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Data.Ordmap.Ordnode";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Data</span>.<span class="name">Ordmap</span>.<span class="name">Ordnode</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Order/Compare.html">Mathlib.Order.Compare</a></li><li><a href="../../.././Mathlib/Data/List/Defs.html">Mathlib.Data.List.Defs</a></li><li><a href="../../.././Mathlib/Data/Nat/PSub.html">Mathlib.Data.Nat.PSub</a></li><li><a href="../../.././Mathlib/Data/Option/Basic.html">Mathlib.Data.Option.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Data.Ordmap.Ordnode" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Ordnode"><span class="name">Ordnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instEmptyCollection"><span class="name">Ordnode</span>.<span class="name">instEmptyCollection</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instInhabited"><span class="name">Ordnode</span>.<span class="name">instInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.delta"><span class="name">Ordnode</span>.<span class="name">delta</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ratio"><span class="name">Ordnode</span>.<span class="name">ratio</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.singleton"><span class="name">Ordnode</span>.<span class="name">singleton</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instSingleton"><span class="name">Ordnode</span>.<span class="name">instSingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.size"><span class="name">Ordnode</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.size_nil"><span class="name">Ordnode</span>.<span class="name">size_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.size_node"><span class="name">Ordnode</span>.<span class="name">size_node</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.empty"><span class="name">Ordnode</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.dual"><span class="name">Ordnode</span>.<span class="name">dual</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.node'"><span class="name">Ordnode</span>.<span class="name">node'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.repr"><span class="name">Ordnode</span>.<span class="name">repr</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instRepr"><span class="name">Ordnode</span>.<span class="name">instRepr</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.balanceL"><span class="name">Ordnode</span>.<span class="name">balanceL</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.balanceR"><span class="name">Ordnode</span>.<span class="name">balanceR</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.balance"><span class="name">Ordnode</span>.<span class="name">balance</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.All"><span class="name">Ordnode</span>.<span class="name">All</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.All.decidable"><span class="name">Ordnode</span>.<span class="name">All</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Any"><span class="name">Ordnode</span>.<span class="name">Any</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Any.decidable"><span class="name">Ordnode</span>.<span class="name">Any</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Emem"><span class="name">Ordnode</span>.<span class="name">Emem</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Emem.decidable"><span class="name">Ordnode</span>.<span class="name">Emem</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Amem"><span class="name">Ordnode</span>.<span class="name">Amem</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Amem.decidable"><span class="name">Ordnode</span>.<span class="name">Amem</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMin'"><span class="name">Ordnode</span>.<span class="name">findMin'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMin"><span class="name">Ordnode</span>.<span class="name">findMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMax'"><span class="name">Ordnode</span>.<span class="name">findMax'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMax"><span class="name">Ordnode</span>.<span class="name">findMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.eraseMin"><span class="name">Ordnode</span>.<span class="name">eraseMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.eraseMax"><span class="name">Ordnode</span>.<span class="name">eraseMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMin'"><span class="name">Ordnode</span>.<span class="name">splitMin'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMin"><span class="name">Ordnode</span>.<span class="name">splitMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMax'"><span class="name">Ordnode</span>.<span class="name">splitMax'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMax"><span class="name">Ordnode</span>.<span class="name">splitMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.glue"><span class="name">Ordnode</span>.<span class="name">glue</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.merge"><span class="name">Ordnode</span>.<span class="name">merge</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insertMax"><span class="name">Ordnode</span>.<span class="name">insertMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insertMin"><span class="name">Ordnode</span>.<span class="name">insertMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.link"><span class="name">Ordnode</span>.<span class="name">link</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.filter"><span class="name">Ordnode</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.partition"><span class="name">Ordnode</span>.<span class="name">partition</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.map"><span class="name">Ordnode</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.fold"><span class="name">Ordnode</span>.<span class="name">fold</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.foldl"><span class="name">Ordnode</span>.<span class="name">foldl</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.foldr"><span class="name">Ordnode</span>.<span class="name">foldr</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.toList"><span class="name">Ordnode</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.toRevList"><span class="name">Ordnode</span>.<span class="name">toRevList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instToString"><span class="name">Ordnode</span>.<span class="name">instToString</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instToFormat"><span class="name">Ordnode</span>.<span class="name">instToFormat</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Equiv"><span class="name">Ordnode</span>.<span class="name">Equiv</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instDecidableRelEquivOfDecidableEq"><span class="name">Ordnode</span>.<span class="name">instDecidableRelEquivOfDecidableEq</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.powerset"><span class="name">Ordnode</span>.<span class="name">powerset</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.prod"><span class="name">Ordnode</span>.<span class="name">prod</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.copair"><span class="name">Ordnode</span>.<span class="name">copair</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.pmap"><span class="name">Ordnode</span>.<span class="name">pmap</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.attach'"><span class="name">Ordnode</span>.<span class="name">attach'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.nth"><span class="name">Ordnode</span>.<span class="name">nth</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.removeNth"><span class="name">Ordnode</span>.<span class="name">removeNth</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.takeAux"><span class="name">Ordnode</span>.<span class="name">takeAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.take"><span class="name">Ordnode</span>.<span class="name">take</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.dropAux"><span class="name">Ordnode</span>.<span class="name">dropAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.drop"><span class="name">Ordnode</span>.<span class="name">drop</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitAtAux"><span class="name">Ordnode</span>.<span class="name">splitAtAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitAt"><span class="name">Ordnode</span>.<span class="name">splitAt</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.takeWhile"><span class="name">Ordnode</span>.<span class="name">takeWhile</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.dropWhile"><span class="name">Ordnode</span>.<span class="name">dropWhile</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.span"><span class="name">Ordnode</span>.<span class="name">span</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofAscListAux₁"><span class="name">Ordnode</span>.<span class="name">ofAscListAux₁</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofAscListAux₂"><span class="name">Ordnode</span>.<span class="name">ofAscListAux₂</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofAscList"><span class="name">Ordnode</span>.<span class="name">ofAscList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.mem"><span class="name">Ordnode</span>.<span class="name">mem</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.find"><span class="name">Ordnode</span>.<span class="name">find</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instMembership"><span class="name">Ordnode</span>.<span class="name">instMembership</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.mem.decidable"><span class="name">Ordnode</span>.<span class="name">mem</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insertWith"><span class="name">Ordnode</span>.<span class="name">insertWith</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.adjustWith"><span class="name">Ordnode</span>.<span class="name">adjustWith</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.updateWith"><span class="name">Ordnode</span>.<span class="name">updateWith</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.alter"><span class="name">Ordnode</span>.<span class="name">alter</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insert"><span class="name">Ordnode</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instInsert"><span class="name">Ordnode</span>.<span class="name">instInsert</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insert'"><span class="name">Ordnode</span>.<span class="name">insert'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.split"><span class="name">Ordnode</span>.<span class="name">split</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.split3"><span class="name">Ordnode</span>.<span class="name">split3</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.erase"><span class="name">Ordnode</span>.<span class="name">erase</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLtAux"><span class="name">Ordnode</span>.<span class="name">findLtAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLt"><span class="name">Ordnode</span>.<span class="name">findLt</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGtAux"><span class="name">Ordnode</span>.<span class="name">findGtAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGt"><span class="name">Ordnode</span>.<span class="name">findGt</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLeAux"><span class="name">Ordnode</span>.<span class="name">findLeAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLe"><span class="name">Ordnode</span>.<span class="name">findLe</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGeAux"><span class="name">Ordnode</span>.<span class="name">findGeAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGe"><span class="name">Ordnode</span>.<span class="name">findGe</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findIndexAux"><span class="name">Ordnode</span>.<span class="name">findIndexAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findIndex"><span class="name">Ordnode</span>.<span class="name">findIndex</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.isSubsetAux"><span class="name">Ordnode</span>.<span class="name">isSubsetAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.isSubset"><span class="name">Ordnode</span>.<span class="name">isSubset</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.disjoint"><span class="name">Ordnode</span>.<span class="name">disjoint</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.union"><span class="name">Ordnode</span>.<span class="name">union</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.diff"><span class="name">Ordnode</span>.<span class="name">diff</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.inter"><span class="name">Ordnode</span>.<span class="name">inter</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofList"><span class="name">Ordnode</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofList'"><span class="name">Ordnode</span>.<span class="name">ofList'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.image"><span class="name">Ordnode</span>.<span class="name">image</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Ordered-sets">Ordered sets <a class="hover-link" href="#Ordered-sets">#</a></h1><p>This file defines a data structure for ordered sets, supporting a
variety of useful operations including insertion and deletion,
logarithmic time lookup, set operations, folds,
and conversion from lists.</p><p>The <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> α</code> operations all assume that <code>α</code> has the structure of
a total preorder, meaning a <code>≤</code> operation that is</p><ul>
<li>Transitive: <code>x ≤ y → y ≤ z → x ≤ z</code></li>
<li>Reflexive: <code>x ≤ x</code></li>
<li>Total: <code>x ≤ y ∨ y ≤ x</code></li>
</ul><p>For example, in order to use this data structure as a map type, one
can store pairs <code>(k, v)</code> where <code>(k, v) ≤ (k', v')</code> is defined to mean
<code>k ≤ k'</code> (assuming that the key values are linearly ordered).</p><p>Two values <code>x,y</code> are equivalent if <code>x ≤ y</code> and <code>y ≤ x</code>. An <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> α</code>
maintains the invariant that it never stores two equivalent nodes;
the insertion operation comes with two variants depending on whether
you want to keep the old value or the new value in case you insert a value
that is equivalent to one in the set.</p><p>The operations in this file are not verified, in the sense that they provide
&quot;raw operations&quot; that work for programming purposes but the invariants
are not explicitly in the structure. See <code>Ordset</code> for a verified version
of this data structure.</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> α</code>: A set of values of type <code>α</code></li>
</ul><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>Based on weight balanced trees:</p><ul>
<li>Stephen Adams, &quot;Efficient sets: a balancing act&quot;,
Journal of Functional Programming 3(4):553-562, October 1993,
<a href="http://www.swiss.ai.mit.edu/~adams/BB/">http://www.swiss.ai.mit.edu/~adams/BB/</a>.</li>
<li>J. Nievergelt and E.M. Reingold,
&quot;Binary search trees of bounded balance&quot;,
SIAM journal of computing 2(1), March 1973.</li>
</ul><p>Ported from Haskell's <code>Data.<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a></code>.</p><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>ordered map, ordered set, data structure</p></div><div class="decl" id="Ordnode"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L66-L71">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode"><span class="name">Ordnode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>An <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> α</code> is a finite set of values, represented as a tree.
The operations on this type maintain that the tree is balanced
and correctly stores subtree sizes at each level.</p><ul class="constructors"><li class="constructor" id="Ordnode.nil">nil<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></li><li class="constructor" id="Ordnode.node">node<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">size</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
 : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></li></ul><details id="instances-for-list-Ordnode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instEmptyCollection"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L78-L79">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollection"><span class="name">Ordnode</span>.<span class="name">instEmptyCollection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#EmptyCollection">EmptyCollection</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollection">Ordnode.instEmptyCollection</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">emptyCollection</span> := <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> }</span></li></ul></details></div></div><div class="decl" id="Ordnode.instInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L81-L82">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabited"><span class="name">Ordnode</span>.<span class="name">instInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabited">Ordnode.instInhabited</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> }</span></li></ul></details></div></div><div class="decl" id="Ordnode.delta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L84-L94">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta"><span class="name">Ordnode</span>.<span class="name">delta</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Nat">ℕ</a></div></div><p><strong>Internal use only</strong></p><p>The maximal relative difference between the sizes of
two trees, it corresponds with the <code>w</code> in Adams' paper.</p><p>According to the Haskell comment, only <code>(delta, ratio)</code> settings
of <code>(3, 2)</code> and <code>(4, 2)</code> will work, and the proofs in
<code>Ordset.lean</code> assume <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta">delta</a> := 3</code> and <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio">ratio</a> := 2</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta">Ordnode.delta</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">3</span></li></ul></details><details id="instances-for-list-Ordnode.delta" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ratio"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L96-L105">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio"><span class="name">Ordnode</span>.<span class="name">ratio</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Nat">ℕ</a></div></div><p><strong>Internal use only</strong></p><p>The ratio between an outer and inner sibling of the
heavier subtree in an unbalanced setting. It determines
whether a double or single rotation should be performed
to restore balance. It is corresponds with the inverse
of <code>α</code> in Adam's article.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio">Ordnode.ratio</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">2</span></li></ul></details><details id="instances-for-list-Ordnode.ratio" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.singleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L107-L112">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton"><span class="name">Ordnode</span>.<span class="name">singleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p>O(1). Construct a singleton set containing value <code>a</code>.</p><p>singleton 3 = {3}</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">1</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <span class="fn">a</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span></li></ul></details><details id="instances-for-list-Ordnode.singleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instSingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L116-L117">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingleton"><span class="name">Ordnode</span>.<span class="name">instSingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Singleton">Singleton</a> <span class="fn">α</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingleton">Ordnode.instSingleton</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">singleton</span> := <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> }</span></li></ul></details></div></div><div class="decl" id="Ordnode.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L119-L125">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size"><span class="name">Ordnode</span>.<span class="name">size</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>O(1). Get the size of the set.</p><p><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a> {2, 1, 1, 4} = 3</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">sz</span></li></ul></details><details id="instances-for-list-Ordnode.size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.size_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L127-L128">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_nil"><span class="name">Ordnode</span>.<span class="name">size_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Ordnode.size_node"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L129-L131">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_node"><span class="name">Ordnode</span>.<span class="name">size_node</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sz</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">sz</span></div></div></div></div><div class="decl" id="Ordnode.empty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L133-L140">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty"><span class="name">Ordnode</span>.<span class="name">empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>O(1). Is the set empty?</p><p>empty ∅ = tt
empty {1, 2, 3} = ff</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty">empty</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty">empty</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Ordnode.empty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.dual"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L142-L150">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual"><span class="name">Ordnode</span>.<span class="name">dual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p><strong>Internal use only</strong>, because it violates the BST property on the original order.</p><p>O(n). The dual of a tree is a tree with its left and right sides reversed throughout.
The dual of a valid BST is valid under the dual order. This is convenient for exploiting
symmetries in the algorithms.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual">dual</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual">dual</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual">dual</a></span> <span class="fn">x_1</span> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual">dual</a></span></span></li></ul></details><details id="instances-for-list-Ordnode.dual" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.node'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L152-L157">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'"><span class="name">Ordnode</span>.<span class="name">node'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Construct a node with the correct size information, without rebalancing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'">node'</a></span> <span class="fn">x</span> <span class="fn">r</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> (<span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>) <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span></span></li></ul></details><details id="instances-for-list-Ordnode.node'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.repr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L159-L169">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr"><span class="name">Ordnode</span>.<span class="name">repr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Data/Format/Basic.html#Std.Format">Std.Format</a></div></div><p>Basic pretty printing for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> α</code> that shows the structure of the tree.</p><p>repr {3, 1, 2, 4} = ((∅ 1 ∅) 2 ((∅ 3 ∅) 4 ∅))</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr">repr</a></span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn">&quot;∅&quot;</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr">repr</a></span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Format/Basic.html#Std.Format.joinSep">Std.Format.joinSep</a> <a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr">repr</a></span> <span class="fn">n</span></span><a href="../../.././Init/Prelude.html#List.cons">,</a> <span class="fn"><a href="../../.././Init/Data/Repr.html#Repr.reprPrec">reprPrec</a> <span class="fn">x_1</span> <span class="fn">n</span></span><a href="../../.././Init/Prelude.html#List.cons">,</a> <span class="fn"><span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr">repr</a></span> <span class="fn">n</span></span><a href="../../.././Init/Prelude.html#List.cons">]</a> <span class="fn">(<a href="../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn">&quot; &quot;</span>)</span>)</span>.<a href="../../.././Init/Data/Format/Basic.html#Std.Format.paren">paren</a></span></li></ul></details><details id="instances-for-list-Ordnode.repr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instRepr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L171-L172">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instRepr"><span class="name">Ordnode</span>.<span class="name">instRepr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instRepr">Ordnode.instRepr</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">reprPrec</span> := <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr">Ordnode.repr</a> }</span></li></ul></details></div></div><div class="decl" id="Ordnode.balanceL"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L175-L207">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL"><span class="name">Ordnode</span>.<span class="name">balanceL</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Rebalance a tree which was previously balanced but has had its left
side grow by 1, or its right side shrink by 1.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.balanceL" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.balanceR"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L209-L241">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR"><span class="name">Ordnode</span>.<span class="name">balanceR</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Rebalance a tree which was previously balanced but has had its right
side grow by 1, or its left side shrink by 1.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.balanceR" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.balance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L243-L297">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balance"><span class="name">Ordnode</span>.<span class="name">balance</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Rebalance a tree which was previously balanced but has had one side change
by at most 1.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.balance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.All"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L299-L305">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All"><span class="name">Ordnode</span>.<span class="name">All</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Does every element of the map satisfy property <code>P</code>?</p><p>All (fun x ↦ x &lt; 5) {1, 2, 3} = True
All (fun x ↦ x &lt; 5) {1, 2, 3, 5} = False</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#True">True</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">P</span> <span class="fn">x_1</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">r</span></span>)</li></ul></details><details id="instances-for-list-Ordnode.All" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.All.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L307-L312">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable"><span class="name">Ordnode</span>.<span class="name">All</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">All</a> <span class="fn">P</span> <span class="fn">t</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable">Ordnode.All.decidable</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.isTrue">isTrue</a> <a href="../../.././Init/Core.html#trivial">trivial</a></span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable">Ordnode.All.decidable</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">P</span> <span class="fn">x_1</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">r</span></span>))</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.Any"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L314-L320">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any"><span class="name">Ordnode</span>.<span class="name">Any</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Does any element of the map satisfy property <code>P</code>?</p><p>Any (fun x ↦ x &lt; 2) {1, 2, 3} = True
Any (fun x ↦ x &lt; 2) {2, 3, 5} = False</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#False">False</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">P</span> <span class="fn">x_1</span></span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <span class="fn">r</span></span>)</li></ul></details><details id="instances-for-list-Ordnode.Any" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.Any.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L322-L327">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable"><span class="name">Ordnode</span>.<span class="name">Any</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Any</a> <span class="fn">P</span> <span class="fn">t</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable">Ordnode.Any.decidable</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable">Ordnode.Any.decidable</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">P</span> <span class="fn">x_1</span></span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <span class="fn">r</span></span>))</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.Emem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L329-L336">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem"><span class="name">Ordnode</span>.<span class="name">Emem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Exact membership in the set. This is useful primarily for stating
correctness properties; use <code>∈</code> for a version that actually uses the BST property
of the tree.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a> 2 {1, 2, 3} = true
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a> 4 {1, 2, 3} = false 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Ordnode.Emem</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Eq">Eq</a> <span class="fn">x</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.Emem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.Emem.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L338-L339">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable"><span class="name">Ordnode</span>.<span class="name">Emem</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a> <span class="fn">x</span> <span class="fn">t</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable">Ordnode.Emem.decidable</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#id">id</a> <a href="../../.././Init/Prelude.html#inferInstance">inferInstance</a></span></li></ul></details></div></div><div class="decl" id="Ordnode.Amem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L341-L359">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem"><span class="name">Ordnode</span>.<span class="name">Amem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Approximate membership in the set, that is, whether some element in the
set is equivalent to this one in the preorder. This is useful primarily for stating
correctness properties; use <code>∈</code> for a version that actually uses the BST property
of the tree.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a> 2 {1, 2, 3} = true
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a> 4 {1, 2, 3} = false
</code></pre><p>To see the difference with <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a></code>, we need a preorder that is not a partial order.
For example, suppose we compare pairs of numbers using only their first coordinate. Then:
-- TODO: Verify below example
Emem (0, 1) {(0, 0), (1, 2)} = false
Amem (0, 1) {(0, 0), (1, 2)} = true
(0, 1) ∈ {(0, 0), (1, 2)} = true</p><p>The <code>∈</code> relation is equivalent to <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a></code> as long as the <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a></code> is well formed,
and should always be used instead of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Ordnode.Amem</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">fun (<span class="fn">y</span> : <span class="fn">α</span>) =&gt; <span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.Amem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.Amem.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L361-L362">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable"><span class="name">Ordnode</span>.<span class="name">Amem</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a> <span class="fn">x</span> <span class="fn">t</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable">Ordnode.Amem.decidable</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#id">id</a> <a href="../../.././Init/Prelude.html#inferInstance">inferInstance</a></span></li></ul></details></div></div><div class="decl" id="Ordnode.findMin'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L364-L370">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'"><span class="name">Ordnode</span>.<span class="name">findMin'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>O(log n). Return the minimum element of the tree, or the provided default value.</p><p>findMin' 37 {1, 2, 3} = 1
findMin' 37 ∅ = 37</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'">findMin'</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'">findMin'</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'">findMin'</a></span> <span class="fn">x_2</span></span></li></ul></details><details id="instances-for-list-Ordnode.findMin'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L372-L378">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin"><span class="name">Ordnode</span>.<span class="name">findMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Return the minimum element of the tree, if it exists.</p><p>findMin {1, 2, 3} = some 1
findMin ∅ = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin">findMin</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin">findMin</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'">findMin'</a></span> <span class="fn">x_1</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.findMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findMax'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L380-L386">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'"><span class="name">Ordnode</span>.<span class="name">findMax'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn">α</span></span></span></div></div><p>O(log n). Return the maximum element of the tree, or the provided default value.</p><p>findMax' 37 {1, 2, 3} = 3
findMax' 37 ∅ = 37</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'">Ordnode.findMax'</a> <span class="fn">x✝</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'">Ordnode.findMax'</a> <span class="fn">x✝</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_3</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'">Ordnode.findMax'</a> <span class="fn">x_3</span> <span class="fn">r</span></span></li></ul></details><details id="instances-for-list-Ordnode.findMax'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L388-L394">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax"><span class="name">Ordnode</span>.<span class="name">findMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Return the maximum element of the tree, if it exists.</p><p>findMax {1, 2, 3} = some 3
findMax ∅ = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax">findMax</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax">findMax</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'">Ordnode.findMax'</a> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.findMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.eraseMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L396-L403">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin"><span class="name">Ordnode</span>.<span class="name">eraseMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Remove the minimum element from the tree, or do nothing if it is already empty.</p><p>eraseMin {1, 2, 3} = {2, 3}
eraseMin ∅ = ∅</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin">eraseMin</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <span class="fn">x_1</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin">eraseMin</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l'</span> <span class="fn">y</span> <span class="fn">r'</span>)</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin">eraseMin</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l'</span> <span class="fn">y</span> <span class="fn">r'</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin">eraseMin</a></span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR">balanceR</a></span> <span class="fn">x_1</span> <span class="fn">r</span></span></li></ul></details><details id="instances-for-list-Ordnode.eraseMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.eraseMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L405-L412">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax"><span class="name">Ordnode</span>.<span class="name">eraseMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Remove the maximum element from the tree, or do nothing if it is already empty.</p><p>eraseMax {1, 2, 3} = {1, 2}
eraseMax ∅ = ∅</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax">eraseMax</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_1</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax">eraseMax</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l'</span> <span class="fn">y</span> <span class="fn">r'</span>)</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax">eraseMax</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL">balanceL</a></span> <span class="fn">x_1</span> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l'</span> <span class="fn">y</span> <span class="fn">r'</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax">eraseMax</a></span></span></li></ul></details><details id="instances-for-list-Ordnode.eraseMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMin'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L414-L421">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'"><span class="name">Ordnode</span>.<span class="name">splitMin'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></span></div></div><p><strong>Internal use only</strong>, because it requires a balancing constraint on the inputs.</p><p>O(log n). Extract and remove the minimum element from a nonempty tree.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'">splitMin'</a></span> <span class="fn">x✝¹</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">x✝¹</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x✝</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">ll</span> <span class="fn">lx</span> <span class="fn">lr</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'">splitMin'</a></span> <span class="fn">x✝¹</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn"><span class="fn">ll</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'">splitMin'</a></span> <span class="fn">lx</span> <span class="fn">lr</span></span> with
  | <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">xm</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">l'</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">xm</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn"><span class="fn">l'</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR">balanceR</a></span> <span class="fn">x✝¹</span> <span class="fn">x✝</span></span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span></li></ul></details><details id="instances-for-list-Ordnode.splitMin'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L423-L429">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin"><span class="name">Ordnode</span>.<span class="name">splitMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span></div></div><p>O(log n). Extract and remove the minimum element from the tree, if it exists.</p><p>split_min {1, 2, 3} = some (1, {2, 3})
split_min ∅ = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin">splitMin</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin">splitMin</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'">splitMin'</a></span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.splitMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMax'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L431-L438">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'"><span class="name">Ordnode</span>.<span class="name">splitMax'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span></span></span></span></div></div><p><strong>Internal use only</strong>, because it requires a balancing constraint on the inputs.</p><p>O(log n). Extract and remove the maximum element from a nonempty tree.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'">splitMax'</a></span> <span class="fn">x✝</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">x✝¹</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x✝</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'">splitMax'</a></span> <span class="fn">x✝</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">rl</span> <span class="fn">rx</span> <span class="fn">rr</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn"><span class="fn">rl</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'">splitMax'</a></span> <span class="fn">rx</span> <span class="fn">rr</span></span> with
  | <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r'</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">xm</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL">balanceL</a></span> <span class="fn">x✝</span> <span class="fn">r'</span></span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">xm</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span></li></ul></details><details id="instances-for-list-Ordnode.splitMax'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L440-L446">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax"><span class="name">Ordnode</span>.<span class="name">splitMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> (<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span></div></div><p>O(log n). Extract and remove the maximum element from the tree, if it exists.</p><p>split_max {1, 2, 3} = some ({1, 2}, 3)
split_max ∅ = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax">splitMax</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax">splitMax</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'">splitMax'</a></span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.splitMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.glue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L448-L460">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue"><span class="name">Ordnode</span>.<span class="name">glue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p><strong>Internal use only</strong></p><p>O(log(m + n)). Concatenate two trees that are balanced and ordered with respect to each other.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue">glue</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue">glue</a></span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span></li></ul></details><details id="instances-for-list-Ordnode.glue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.merge"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L462-L474">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge"><span class="name">Ordnode</span>.<span class="name">merge</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log(m + n)). Concatenate two trees that are ordered with respect to each other.</p><p>merge {1, 2} {3, 4} = {1, 2, 3, 4}
merge {3, 4} {1, 2} = precondition violation</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.merge" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.insertMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L476-L483">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax"><span class="name">Ordnode</span>.<span class="name">insertMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>O(log n). Insert an element above all the others, without any comparisons.
(Assumes that the element is in fact above all the others).</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">insertMax</a> {1, 2} 4 = {1, 2, 4}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">insertMax</a> {1, 2} 0 = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">insertMax</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x✝</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">insertMax</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR">balanceR</a></span> <span class="fn">x_2</span> <span class="fn">(<span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">insertMax</a></span> <span class="fn">x✝</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.insertMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.insertMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L485-L492">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin"><span class="name">Ordnode</span>.<span class="name">insertMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Insert an element below all the others, without any comparisons.
(Assumes that the element is in fact below all the others).</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">insertMin</a> {1, 2} 0 = {0, 1, 2}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">insertMin</a> {1, 2} 4 = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">Ordnode.insertMin</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x</span></span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">Ordnode.insertMin</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">Ordnode.insertMin</a> <span class="fn">x</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR">balanceR</a></span> <span class="fn">x_2</span> <span class="fn">r</span></span></li></ul></details><details id="instances-for-list-Ordnode.insertMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.link"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L494-L508">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link"><span class="name">Ordnode</span>.<span class="name">link</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log(m+n)). Build a tree from an element between two trees, without any
assumption on the relative sizes.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a> {1, 2} 4 {5, 6} = {1, 2, 4, 5, 6}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a> {1, 3} 2 {5} = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a></span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">Ordnode.insertMin</a> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Ordnode.link" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.filter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L510-L518">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter"><span class="name">Ordnode</span>.<span class="name">filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(n). Filter the elements of a tree satisfying a predicate.</p><p>filter (fun x ↦ x &lt; 3) {1, 2, 4} = {1, 2}
filter (fun x ↦ x &gt; 5) {1, 2, 4} = ∅</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">p</span> <span class="fn">x_1</span></span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a></span> <span class="fn">x_1</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge">merge</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">r</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.filter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.partition"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L520-L528">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition"><span class="name">Ordnode</span>.<span class="name">partition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(n). Split the elements of a tree into those satisfying, and not satisfying, a predicate.</p><p>partition (fun x ↦ x &lt; 3) {1, 2, 4} = ({1, 2}, {3})</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition">Ordnode.partition</a> <span class="fn">p</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">)</a></li></ul></details><details id="instances-for-list-Ordnode.partition" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L530-L537">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map"><span class="name">Ordnode</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">β</span></span></span></div></div><p>O(n). Map a function across a tree, without changing the structure. Only valid when
the function is strictly monotone, i.e. <code>x &lt; y → f x &lt; f y</code>.</p><pre><code> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition">partition</a> (fun x ↦ x + 2) {1, 2, 4} = {2, 3, 6}
 <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition">partition</a> (fun x : ℕ ↦ x - 2) {1, 2, 4} = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">f</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x_1</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">f</span> <span class="fn">r</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.fold"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L539-L547">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold"><span class="name">Ordnode</span>.<span class="name">fold</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">z</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn">β</span></span></div></div><p>O(n). Fold a function across the structure of a tree.</p><pre><code> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">fold</a> z f {1, 2, 4} = f (f z 1 z) 2 (f z 4 z)
</code></pre><p>The exact structure of function applications depends on the tree and so
is unspecified.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">Ordnode.fold</a> <span class="fn">z</span> <span class="fn">f</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">z</span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">Ordnode.fold</a> <span class="fn">z</span> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">Ordnode.fold</a> <span class="fn">z</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">x_1</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">Ordnode.fold</a> <span class="fn">z</span> <span class="fn">f</span> <span class="fn">r</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.fold" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.foldl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L549-L554">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl"><span class="name">Ordnode</span>.<span class="name">foldl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn">β</span></span></span></div></div><p>O(n). Fold a function from left to right (in increasing order) across the tree.</p><p>foldl f z {1, 2, 4} = f (f (f z 1) 2) 4</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl">Ordnode.foldl</a> <span class="fn">f</span> <span class="fn">x✝</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl">Ordnode.foldl</a> <span class="fn">f</span> <span class="fn">x✝</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl">Ordnode.foldl</a> <span class="fn">f</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl">Ordnode.foldl</a> <span class="fn">f</span> <span class="fn">x✝</span> <span class="fn">l</span>)</span> <span class="fn">x_2</span>)</span> <span class="fn">r</span></span></li></ul></details><details id="instances-for-list-Ordnode.foldl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.foldr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L556-L561">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr"><span class="name">Ordnode</span>.<span class="name">foldr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span></div></div><p>O(n). Fold a function from right to left (in decreasing order) across the tree.</p><p>foldr f {1, 2, 4} z = f 1 (f 2 (f 4 z))</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr">Ordnode.foldr</a> <span class="fn">f</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr">Ordnode.foldr</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr">Ordnode.foldr</a> <span class="fn">f</span> <span class="fn">l</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x_2</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr">Ordnode.foldr</a> <span class="fn">f</span> <span class="fn">r</span> <span class="fn">x✝</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.foldr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L563-L568">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList"><span class="name">Ordnode</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></div></div><p>O(n). Build a list of elements in ascending order from the tree.</p><p>toList {1, 2, 4} = [1, 2, 4]
toList {2, 1, 1, 4} = [1, 2, 4]</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">toList</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr">Ordnode.foldr</a> <a href="../../.././Init/Prelude.html#List.cons">List.cons</a> <span class="fn">t</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span></li></ul></details><details id="instances-for-list-Ordnode.toList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.toRevList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L570-L575">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList"><span class="name">Ordnode</span>.<span class="name">toRevList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></div></div><p>O(n). Build a list of elements in descending order from the tree.</p><p>toRevList {1, 2, 4} = [4, 2, 1]
toRevList {2, 1, 1, 4} = [4, 2, 1]</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList">toRevList</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl">Ordnode.foldl</a> <span class="fn">(<a href="../../.././Init/Core.html#flip">flip</a> <a href="../../.././Init/Prelude.html#List.cons">List.cons</a>)</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">t</span></span></li></ul></details><details id="instances-for-list-Ordnode.toRevList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instToString"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L577-L578">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToString"><span class="name">Ordnode</span>.<span class="name">instToString</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/ToString/Basic.html#ToString">ToString</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/ToString/Basic.html#ToString">ToString</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToString">Ordnode.instToString</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">toString</span> := <span class="fn">fun (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>) =&gt; <span class="fn">&quot;{&quot;</span> <a href="../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><span class="fn"><span class="fn">&quot;, &quot;</span>.<a href="../../.././Init/Data/String/Basic.html#String.intercalate">intercalate</a></span> <span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../.././Init/Data/ToString/Basic.html#ToString.toString">toString</a> <span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">toList</a></span>)</span></span> <a href="../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">&quot;}&quot;</span></span> }</span></li></ul></details></div></div><div class="decl" id="Ordnode.instToFormat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L580-L581">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormat"><span class="name">Ordnode</span>.<span class="name">instToFormat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.ToFormat">Std.ToFormat</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.ToFormat">Std.ToFormat</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormat">Ordnode.instToFormat</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">format</span> := <span class="fn">fun (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.Format.joinSep">Std.Format.joinSep</a> <span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../.././Init/Data/Format/Basic.html#Std.ToFormat.format">Std.format</a> <span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">toList</a></span>)</span> <span class="fn">(<a href="../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn">&quot;, &quot;</span>)</span></span></span> }</span></li></ul></details></div></div><div class="decl" id="Ordnode.Equiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L583-L588">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv"><span class="name">Ordnode</span>.<span class="name">Equiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t₁ </span><span class="fn">t₂</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>O(n). True if the trees have the same elements, ignoring structural differences.</p><p>Equiv {1, 2, 4} {2, 1, 1, 4} = true
Equiv {1, 2, 4} {1, 2, 3} = false</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">t₁</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv">Equiv</a></span> <span class="fn">t₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">t₁</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t₂</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">t₁</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">toList</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t₂</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">toList</a></span>)</li></ul></details><details id="instances-for-list-Ordnode.Equiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instDecidableRelEquivOfDecidableEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L590-L591">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelEquivOfDecidableEq"><span class="name">Ordnode</span>.<span class="name">instDecidableRelEquivOfDecidableEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv">Equiv</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelEquivOfDecidableEq">instDecidableRelEquivOfDecidableEq</a></span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">toList</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">toList</a></span>))</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.powerset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L593-L597">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.powerset"><span class="name">Ordnode</span>.<span class="name">powerset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span>)</span></span></div></div><p>O(2^n). Constructs the powerset of a given set, that is, the set of all subsets.</p><p>powerset {1, 2, 3} = {∅, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}}</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.powerset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.prod"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L599-L603">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod"><span class="name">Ordnode</span>.<span class="name">prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t₁</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t₂</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></div></div><p>O(m * n). The cartesian product of two sets: <code>(a, b) ∈ s.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod">prod</a> t</code> iff <code>a ∈ s</code> and <code>b ∈ t</code>.</p><p>prod {1, 2} {2, 3} = {(1, 2), (1, 3), (2, 2), (2, 3)}</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">t₁</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod">prod</a></span> <span class="fn">t₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">Ordnode.fold</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>
    <span class="fn">(fun (<span class="fn">s₁</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">s₂</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">s₁</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge">merge</a></span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Prod.mk">Prod.mk</a> <span class="fn">a</span>)</span> <span class="fn">t₂</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge">merge</a></span> <span class="fn">s₂</span>)</span></span>)</span> <span class="fn">t₁</span></span></li></ul></details><details id="instances-for-list-Ordnode.prod" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.copair"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L605-L610">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair"><span class="name">Ordnode</span>.<span class="name">copair</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t₁</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t₂</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> (<span class="fn">α</span> <a href="../../.././Init/Core.html#Sum">⊕</a> <span class="fn">β</span>)</span></div></div><p>O(m + n). Build a set on the disjoint union by combining sets on the factors.
<code><a href="../../.././Init/Prelude.html#Or.inl">Or.inl</a> a ∈ s.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">copair</a> t</code> iff <code>a ∈ s</code>, and <code><a href="../../.././Init/Prelude.html#Or.inr">Or.inr</a> b ∈ s.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">copair</a> t</code> iff <code>b ∈ t</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">copair</a> {1, 2} {2, 3} = {inl 1, inl 2, inr 2, inr 3} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">t₁</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">copair</a></span> <span class="fn">t₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <a href="../../.././Init/Core.html#Sum.inl">Sum.inl</a> <span class="fn">t₁</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge">merge</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <a href="../../.././Init/Core.html#Sum.inr">Sum.inr</a> <span class="fn">t₂</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.copair" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.pmap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L612-L618">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap"><span class="name">Ordnode</span>.<span class="name">pmap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">All</a> <span class="fn">P</span> <span class="fn">t</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">β</span></span></span></div></div><p>O(n). Map a partial function across a set. The result depends on a proof
that the function is defined on all members of the set.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">pmap</a> (fin.mk : ∀ n, n &lt; 4 → fin 4) {1, 2} H = {(1 : fin 4), (2 : fin 4)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">Ordnode.pmap</a> <span class="fn">f</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <span class="fn">x_2</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">Ordnode.pmap</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">s</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span> <span class="fn">⋯</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">s</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">Ordnode.pmap</a> <span class="fn">f</span> <span class="fn">l</span> <span class="fn">hl</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x_2</span> <span class="fn">hx</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">Ordnode.pmap</a> <span class="fn">f</span> <span class="fn">r</span> <span class="fn">hr</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.pmap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.attach'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L620-L625">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'"><span class="name">Ordnode</span>.<span class="name">attach'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">All</a> <span class="fn">P</span> <span class="fn">t</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <a href="../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href="../../.././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Subtype">}</a></span></span></div></div><p>O(n). &quot;Attach&quot; the information that every element of <code>t</code> satisfies property
P to these elements inside the set, producing a set in the subtype.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'">attach'</a> (fun x ↦ x &lt; 4) {1, 2} H = ({1, 2} : <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> {x // x&lt;4}) 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'">Ordnode.attach'</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">Ordnode.pmap</a> <a href="../../.././Init/Prelude.html#Subtype.mk">Subtype.mk</a></span></li></ul></details><details id="instances-for-list-Ordnode.attach'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.nth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L627-L637">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth"><span class="name">Ordnode</span>.<span class="name">nth</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></span></div></div><p>O(log n). Get the <code>i</code>th element of the set, by its index from left to right.</p><p>nth {a, b, c, d} 2 = some c
nth {a, b, c, d} 5 = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth">nth</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth">nth</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/Nat/PSub.html#Nat.psub'">psub'</a></span> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span></span> with
  | <a href="../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth">nth</a></span> <span class="fn">x✝</span></span>
  | <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">0</span></span> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x_2</span></span>
  | <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">j</span>.<a href="../../.././Init/Prelude.html#Nat.succ">succ</a></span></span> =&gt; <span class="fn"><span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth">nth</a></span> <span class="fn">j</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.nth" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.removeNth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L639-L649">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth"><span class="name">Ordnode</span>.<span class="name">removeNth</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>O(log n). Remove the <code>i</code>th element of the set, by its index from left to right.</p><p>remove_nth {a, b, c, d} 2 = {a, b, d}
remove_nth {a, b, c, d} 5 = {a, b, c, d}</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth">removeNth</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth">removeNth</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/Nat/PSub.html#Nat.psub'">psub'</a></span> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span></span> with
  | <a href="../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth">removeNth</a></span> <span class="fn">x✝</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR">balanceR</a></span> <span class="fn">x_2</span> <span class="fn">r</span></span>
  | <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">0</span></span> =&gt; <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue">glue</a></span> <span class="fn">r</span></span>
  | <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">j</span>.<a href="../../.././Init/Prelude.html#Nat.succ">succ</a></span></span> =&gt; <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL">balanceL</a></span> <span class="fn">x_2</span> <span class="fn">(<span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth">removeNth</a></span> <span class="fn">j</span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.removeNth" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.takeAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L651-L664">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux"><span class="name">Ordnode</span>.<span class="name">takeAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take">take</a></code>. (Can also be used in lieu of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take">take</a></code> if you know the
index is within the range of the data structure.)</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a> {a, b, c, d} 2 = {a, b}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a> {a, b, c, d} 5 = {a, b, c, d} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">x✝</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span> <a href="../../.././Init/Prelude.html#ite">then</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>
  <a href="../../.././Init/Prelude.html#ite">else</a>     <span class="fn">match <span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/Nat/PSub.html#Nat.psub'">psub'</a></span> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span></span> with
    | <a href="../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a></span> <span class="fn">x✝</span></span>
    | <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">0</span></span> =&gt; <span class="fn">l</span>
    | <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">j</span>.<a href="../../.././Init/Prelude.html#Nat.succ">succ</a></span></span> =&gt; <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a></span> <span class="fn">x_2</span> <span class="fn">(<span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a></span> <span class="fn">j</span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.takeAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.take"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L666-L671">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take"><span class="name">Ordnode</span>.<span class="name">take</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p>O(log n). Get the first <code>i</code> elements of the set, counted from the left.</p><p>take 2 {a, b, c, d} = {a, b}
take 5 {a, b, c, d} = {a, b, c, d}</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take">Ordnode.take</a> <span class="fn">i</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn">t</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a></span> <span class="fn">i</span></span></li></ul></details><details id="instances-for-list-Ordnode.take" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.dropAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L673-L686">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux"><span class="name">Ordnode</span>.<span class="name">dropAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop">drop</a></code>. (Can also be used in lieu of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop">drop</a></code> if you know the
index is within the range of the data structure.)</p><pre><code>drop_aux {a, b, c, d} 2 = {c, d}
drop_aux {a, b, c, d} 5 = ∅ 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux">dropAux</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li></ul></details><details id="instances-for-list-Ordnode.dropAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.drop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L688-L693">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop"><span class="name">Ordnode</span>.<span class="name">drop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p>O(log n). Remove the first <code>i</code> elements of the set, counted from the left.</p><p>drop 2 {a, b, c, d} = {c, d}
drop 5 {a, b, c, d} = ∅</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop">Ordnode.drop</a> <span class="fn">i</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span> <a href="../../.././Init/Prelude.html#ite">then</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux">dropAux</a></span> <span class="fn">i</span></span></li></ul></details><details id="instances-for-list-Ordnode.drop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitAtAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L695-L712">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux"><span class="name">Ordnode</span>.<span class="name">splitAtAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt">splitAt</a></code>. (Can also be used in lieu of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt">splitAt</a></code> if you know the
index is within the range of the data structure.)</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux">splitAtAux</a> {a, b, c, d} 2 = ({a, b}, {c, d})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux">splitAtAux</a> {a, b, c, d} 5 = ({a, b, c, d}, ∅) 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux">splitAtAux</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">)</a></li></ul></details><details id="instances-for-list-Ordnode.splitAtAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitAt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L714-L719">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt"><span class="name">Ordnode</span>.<span class="name">splitAt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p>O(log n). Split a set at the <code>i</code>th element, getting the first <code>i</code> and everything else.</p><p>splitAt 2 {a, b, c, d} = ({a, b}, {c, d})
splitAt 5 {a, b, c, d} = ({a, b, c, d}, ∅)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt">Ordnode.splitAt</a> <span class="fn">i</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span> <a href="../../.././Init/Prelude.html#ite">then</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">t</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux">splitAtAux</a></span> <span class="fn">i</span></span></li></ul></details><details id="instances-for-list-Ordnode.splitAt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.takeWhile"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L721-L728">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile"><span class="name">Ordnode</span>.<span class="name">takeWhile</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Get an initial segment of the set that satisfies the predicate <code>p</code>.
<code>p</code> is required to be antitone, that is, <code>x &lt; y → p y → p x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">takeWhile</a> (fun x ↦ x &lt; 4) {1, 2, 3, 4, 5} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">takeWhile</a> (fun x ↦ x &gt; 4) {1, 2, 3, 4, 5} = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">Ordnode.takeWhile</a> <span class="fn">p</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">Ordnode.takeWhile</a> <span class="fn">p</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">p</span> <span class="fn">x_1</span></span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a></span> <span class="fn">x_1</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">Ordnode.takeWhile</a> <span class="fn">p</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">Ordnode.takeWhile</a> <span class="fn">p</span> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Ordnode.takeWhile" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.dropWhile"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L730-L737">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile"><span class="name">Ordnode</span>.<span class="name">dropWhile</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Remove an initial segment of the set that satisfies the predicate <code>p</code>.
<code>p</code> is required to be antitone, that is, <code>x &lt; y → p y → p x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">dropWhile</a> (fun x ↦ x &lt; 4) {1, 2, 3, 4, 5} = {4, 5}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">dropWhile</a> (fun x ↦ x &gt; 4) {1, 2, 3, 4, 5} = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">Ordnode.dropWhile</a> <span class="fn">p</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">Ordnode.dropWhile</a> <span class="fn">p</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">p</span> <span class="fn">x_1</span></span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">Ordnode.dropWhile</a> <span class="fn">p</span> <span class="fn">r</span></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">Ordnode.dropWhile</a> <span class="fn">p</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a></span> <span class="fn">x_1</span> <span class="fn">r</span></span></li></ul></details><details id="instances-for-list-Ordnode.dropWhile" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.span"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L739-L752">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span"><span class="name">Ordnode</span>.<span class="name">span</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Split the set into those satisfying and not satisfying the predicate <code>p</code>.
<code>p</code> is required to be antitone, that is, <code>x &lt; y → p y → p x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span">span</a> (fun x ↦ x &lt; 4) {1, 2, 3, 4, 5} = ({1, 2, 3}, {4, 5})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span">span</a> (fun x ↦ x &gt; 4) {1, 2, 3, 4, 5} = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span">Ordnode.span</a> <span class="fn">p</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">)</a></li></ul></details><details id="instances-for-list-Ordnode.span" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofAscListAux₁"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L754-L771">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁"><span class="name">Ordnode</span>.<span class="name">ofAscListAux₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">l'</span> <a href="../../.././Init/Prelude.html#Subtype">:</a> <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">l'</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../.././Init/Prelude.html#Subtype">}</a></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">ofAscList</a></code>.</p><p><strong>Note:</strong> This function is defined by well founded recursion, so it will probably not compute
in the kernel, meaning that you probably can't prove things like
<code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">ofAscList</a> [1, 2, 3] = {1, 2, 3}</code> by <code><a href="../../.././Init/Prelude.html#rfl">rfl</a></code>.
This implementation is optimized for VM evaluation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁">Ordnode.ofAscListAux₁</a> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>) =&gt; <a href="../../.././Init/Prelude.html#Prod.mk">(</a><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">⟨<a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a>, <span class="fn">⋯</span>⟩</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span></li></ul></details><details id="instances-for-list-Ordnode.ofAscListAux₁" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofAscListAux₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L773-L781">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂"><span class="name">Ordnode</span>.<span class="name">ofAscListAux₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">ofAscList</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂">Ordnode.ofAscListAux₂</a> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>) (<span class="fn">x</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>) =&gt; <span class="fn">t</span></span></li></ul></details><details id="instances-for-list-Ordnode.ofAscListAux₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofAscList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L783-L789">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList"><span class="name">Ordnode</span>.<span class="name">ofAscList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(n). Build a set from a list which is already sorted. Performs no comparisons.</p><p>ofAscList [1, 2, 3] = {1, 2, 3}
ofAscList [3, 2, 1] = precondition violation</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">Ordnode.ofAscList</a> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">Ordnode.ofAscList</a> (<span class="fn">x_1</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">xs</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂">Ordnode.ofAscListAux₂</a> <span class="fn">xs</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x_1</span>)</span> <span class="fn">1</span></span></li></ul></details><details id="instances-for-list-Ordnode.ofAscList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.mem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L795-L811">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem"><span class="name">Ordnode</span>.<span class="name">mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>O(log n). Does the set (approximately) contain the element <code>x</code>? That is,
is there an element that is equivalent to <code>x</code> in the order?</p><pre><code>1 ∈ {1, 2, 3} = true
4 ∈ {1, 2, 3} = false
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code>(1, 1) ∈ {(0, 1), (1, 2)} = true
(3, 1) ∈ {(0, 1), (1, 2)} = false 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.false">false</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">x_2</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">l</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.eq">Ordering.eq</a> =&gt; <a href="../../.././Init/Prelude.html#Bool.true">true</a>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">r</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.mem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.find"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L813-L829">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find"><span class="name">Ordnode</span>.<span class="name">find</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Retrieve an element in the set that is equivalent to <code>x</code> in the order,
if it exists.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> 1 {1, 2, 3} = some 1
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> 4 {1, 2, 3} = none
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> (1, 1) {(0, 1), (1, 2)} = some (1, 2)
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> (3, 1) {(0, 1), (1, 2)} = none 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">Ordnode.find</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">Ordnode.find</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">x_2</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">Ordnode.find</a> <span class="fn">x</span> <span class="fn">l</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.eq">Ordering.eq</a> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x_2</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">Ordnode.find</a> <span class="fn">x</span> <span class="fn">r</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.find" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instMembership"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L831-L832">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembership"><span class="name">Ordnode</span>.<span class="name">instMembership</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembership">Ordnode.instMembership</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">mem</span> := <span class="fn">fun (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>) (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span> }</span></li></ul></details></div></div><div class="decl" id="Ordnode.mem.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L834-L835">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable"><span class="name">Ordnode</span>.<span class="name">mem</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable">Ordnode.mem.decidable</a> <span class="fn">x</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">t</span>)</span>.<a href="../../.././Init/Prelude.html#Bool.decEq">decEq</a></span> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></li></ul></details></div></div><div class="decl" id="Ordnode.insertWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L837-L854">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith"><span class="name">Ordnode</span>.<span class="name">insertWith</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Insert an element into the set, preserving balance and the BST property.
If an equivalent element is already in the set, the function <code>f</code> is used to generate
the element to insert (being passed the current value in the set).</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f 0 {1, 2, 3} = {0, 1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f 1 {1, 2, 3} = {f 1, 2, 3}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">Ordnode.insertWith</a> <span class="fn">f</span> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Ordnode.insertWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.adjustWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L856-L873">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith"><span class="name">Ordnode</span>.<span class="name">adjustWith</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Modify an element in the set with the given function,
doing nothing if the key is not found.
Note that the element returned by <code>f</code> must be equivalent to <code>x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f 0 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f 1 {1, 2, 3} = {f 1, 2, 3}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">Ordnode.adjustWith</a> <span class="fn">f</span> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li></ul></details><details id="instances-for-list-Ordnode.adjustWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.updateWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L875-L891">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith"><span class="name">Ordnode</span>.<span class="name">updateWith</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Modify an element in the set with the given function,
doing nothing if the key is not found.
Note that the element returned by <code>f</code> must be equivalent to <code>x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith">updateWith</a> f 0 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith">updateWith</a> f 1 {1, 2, 3} = {2, 3}     if f 1 = none
                          = {a, 2, 3}  if f 1 = some a 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith">Ordnode.updateWith</a> <span class="fn">f</span> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li></ul></details><details id="instances-for-list-Ordnode.updateWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.alter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L893-L910">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter"><span class="name">Ordnode</span>.<span class="name">alter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Modify an element in the set with the given function,
doing nothing if the key is not found.
Note that the element returned by <code>f</code> must be equivalent to <code>x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter">alter</a> f 0 {1, 2, 3} = {1, 2, 3}     if f none = none
                    = {a, 1, 2, 3}  if f none = some a
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter">alter</a> f 1 {1, 2, 3} = {2, 3}     if f 1 = none
                    = {a, 2, 3}  if f 1 = some a 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter">Ordnode.alter</a> <span class="fn">f</span> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Option.recOn">Option.recOn</a> <span class="fn">(<span class="fn">f</span> <a href="../../.././Init/Prelude.html#Option.none">none</a>)</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a></span></li></ul></details><details id="instances-for-list-Ordnode.alter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.insert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L912-L928">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert"><span class="name">Ordnode</span>.<span class="name">insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Insert an element into the set, preserving balance and the BST property.
If an equivalent element is already in the set, this replaces it.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> 1 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> 4 {1, 2, 3} = {1, 2, 3, 4}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 1)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">Ordnode.insert</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Ordnode.insert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instInsert"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L930-L931">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsert"><span class="name">Ordnode</span>.<span class="name">instInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Insert">Insert</a> <span class="fn">α</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsert">Ordnode.instInsert</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">insert</span> := <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">Ordnode.insert</a> }</span></li></ul></details></div></div><div class="decl" id="Ordnode.insert'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L933-L949">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'"><span class="name">Ordnode</span>.<span class="name">insert'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Insert an element into the set, preserving balance and the BST property.
If an equivalent element is already in the set, the set is returned as is.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> 1 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> 4 {1, 2, 3} = {1, 2, 3, 4}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">Ordnode.insert'</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Ordnode.insert'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.split"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L951-L972">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split"><span class="name">Ordnode</span>.<span class="name">split</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Split the tree into those smaller than <code>x</code> and those greater than it.
If an element equivalent to <code>x</code> is in the set, it is discarded.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> 2 {1, 2, 4} = ({1}, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> 3 {1, 2, 4} = ({1, 2}, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> 4 {1, 2, 4} = ({1, 2}, ∅)
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, ∅)
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, ∅) 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">Ordnode.split</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">)</a></li></ul></details><details id="instances-for-list-Ordnode.split" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.split3"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L974-L995">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3"><span class="name">Ordnode</span>.<span class="name">split3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Split the tree into those smaller than <code>x</code> and those greater than it,
plus an element equivalent to <code>x</code>, if it exists.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> 2 {1, 2, 4} = ({1}, some 2, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> 3 {1, 2, 4} = ({1, 2}, none, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> 4 {1, 2, 4} = ({1, 2}, some 4, ∅)
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, some (1, 2), ∅)
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, none, ∅) 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">Ordnode.split3</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <a href="../../.././Init/Prelude.html#Option.none">none</a><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a><a href="../../.././Init/Prelude.html#Prod.mk">)</a></li></ul></details><details id="instances-for-list-Ordnode.split3" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.erase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L997-L1013">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase"><span class="name">Ordnode</span>.<span class="name">erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Remove an element from the set equivalent to <code>x</code>. Does nothing if there
is no such element.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> 1 {1, 2, 3} = {2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> 4 {1, 2, 3} = {1, 2, 3}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> (1, 1) {(0, 1), (1, 2)} = {(0, 1)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">Ordnode.erase</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">Ordnode.erase</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">y</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">y</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> =&gt; <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">Ordnode.erase</a> <span class="fn">x</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR">balanceR</a></span> <span class="fn">y</span> <span class="fn">r</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.eq">Ordering.eq</a> =&gt; <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue">glue</a></span> <span class="fn">r</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL">balanceL</a></span> <span class="fn">y</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">Ordnode.erase</a> <span class="fn">x</span> <span class="fn">r</span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.erase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLtAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1015-L1018">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux"><span class="name">Ordnode</span>.<span class="name">findLtAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt">findLt</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux">Ordnode.findLtAux</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux">Ordnode.findLtAux</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_3</span> <span class="fn">r</span>)</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_3</span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux">Ordnode.findLtAux</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux">Ordnode.findLtAux</a> <span class="fn">x</span> <span class="fn">r</span> <span class="fn">x_3</span></span></li></ul></details><details id="instances-for-list-Ordnode.findLtAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1020-L1027">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt"><span class="name">Ordnode</span>.<span class="name">findLt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Get the largest element in the tree that is <code>&lt; x</code>.</p><p>findLt 2 {1, 2, 4} = some 1
findLt 3 {1, 2, 4} = some 2
findLt 0 {1, 2, 4} = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt">Ordnode.findLt</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt">Ordnode.findLt</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_2</span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt">Ordnode.findLt</a> <span class="fn">x</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux">Ordnode.findLtAux</a> <span class="fn">x</span> <span class="fn">r</span> <span class="fn">x_2</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.findLt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGtAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1029-L1032">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux"><span class="name">Ordnode</span>.<span class="name">findGtAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt">findGt</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux">Ordnode.findGtAux</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux">Ordnode.findGtAux</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_3</span> <span class="fn">r</span>)</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">x_3</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux">Ordnode.findGtAux</a> <span class="fn">x</span> <span class="fn">r</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux">Ordnode.findGtAux</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">x_3</span></span></li></ul></details><details id="instances-for-list-Ordnode.findGtAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1034-L1041">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt"><span class="name">Ordnode</span>.<span class="name">findGt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Get the smallest element in the tree that is <code>&gt; x</code>.</p><p>findGt 2 {1, 2, 4} = some 4
findGt 3 {1, 2, 4} = some 4
findGt 4 {1, 2, 4} = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt">Ordnode.findGt</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt">Ordnode.findGt</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">x_2</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt">Ordnode.findGt</a> <span class="fn">x</span> <span class="fn">r</span></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux">Ordnode.findGtAux</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">x_2</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.findGt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLeAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1043-L1050">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux"><span class="name">Ordnode</span>.<span class="name">findLeAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe">findLe</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux">Ordnode.findLeAux</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux">Ordnode.findLeAux</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_3</span> <span class="fn">r</span>)</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">x_3</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux">Ordnode.findLeAux</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">x✝</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.eq">Ordering.eq</a> =&gt; <span class="fn">x_3</span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux">Ordnode.findLeAux</a> <span class="fn">x</span> <span class="fn">r</span> <span class="fn">x_3</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findLeAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1052-L1063">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe"><span class="name">Ordnode</span>.<span class="name">findLe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Get the largest element in the tree that is <code>≤ x</code>.</p><p>findLe 2 {1, 2, 4} = some 2
findLe 3 {1, 2, 4} = some 2
findLe 0 {1, 2, 4} = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe">Ordnode.findLe</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe">Ordnode.findLe</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">x_2</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe">Ordnode.findLe</a> <span class="fn">x</span> <span class="fn">l</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.eq">Ordering.eq</a> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x_2</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux">Ordnode.findLeAux</a> <span class="fn">x</span> <span class="fn">r</span> <span class="fn">x_2</span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findLe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGeAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1065-L1072">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux"><span class="name">Ordnode</span>.<span class="name">findGeAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe">findGe</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux">Ordnode.findGeAux</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux">Ordnode.findGeAux</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_3</span> <span class="fn">r</span>)</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">x_3</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux">Ordnode.findGeAux</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">x_3</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.eq">Ordering.eq</a> =&gt; <span class="fn">x_3</span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux">Ordnode.findGeAux</a> <span class="fn">x</span> <span class="fn">r</span> <span class="fn">x✝</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findGeAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1074-L1085">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe"><span class="name">Ordnode</span>.<span class="name">findGe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Get the smallest element in the tree that is <code>≥ x</code>.</p><p>findGe 2 {1, 2, 4} = some 2
findGe 3 {1, 2, 4} = some 4
findGe 5 {1, 2, 4} = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe">Ordnode.findGe</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe">Ordnode.findGe</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">x_2</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux">Ordnode.findGeAux</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">x_2</span>)</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.eq">Ordering.eq</a> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x_2</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe">Ordnode.findGe</a> <span class="fn">x</span> <span class="fn">r</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findGe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findIndexAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1087-L1094">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux"><span class="name">Ordnode</span>.<span class="name">findIndexAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux">Ordnode.findIndexAux</a> <span class="fn">x</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Option.none">none</a></li></ul></details><details id="instances-for-list-Ordnode.findIndexAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findIndex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1096-L1103">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex"><span class="name">Ordnode</span>.<span class="name">findIndex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>O(log n). Get the index, counting from the left,
of an element equivalent to <code>x</code> if it exists.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a> 2 {1, 2, 4} = some 1
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a> 4 {1, 2, 4} = some 2
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a> 5 {1, 2, 4} = none 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">Ordnode.findIndex</a> <span class="fn">x</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux">Ordnode.findIndexAux</a> <span class="fn">x</span> <span class="fn">t</span> <span class="fn">0</span></span></li></ul></details><details id="instances-for-list-Ordnode.findIndex" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.isSubsetAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1105-L1111">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux"><span class="name">Ordnode</span>.<span class="name">isSubsetAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset">isSubset</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux">isSubsetAux</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux">isSubsetAux</a></span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.false">false</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux">isSubsetAux</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">Ordnode.split3</a> <span class="fn">x_2</span> <span class="fn">x✝</span></span> with
  | <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">lt</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">found</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">gt</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <span class="fn"><span class="fn">found</span>.<a href="../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux">isSubsetAux</a></span> <span class="fn">lt</span></span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux">isSubsetAux</a></span> <span class="fn">gt</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.isSubsetAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.isSubset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1113-L1118">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset"><span class="name">Ordnode</span>.<span class="name">isSubset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t₁ </span><span class="fn">t₂</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>O(m + n). Is every element of <code>t₁</code> equivalent to some element of <code>t₂</code>?</p><p>is_subset {1, 4} {1, 2, 4} = tt
is_subset {1, 3} {1, 2, 4} = ff</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">t₁</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset">isSubset</a></span> <span class="fn">t₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn">t₁</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">t₂</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span>)</span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn"><span class="fn">t₁</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux">isSubsetAux</a></span> <span class="fn">t₂</span></span>)</li></ul></details><details id="instances-for-list-Ordnode.isSubset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.disjoint"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1120-L1129">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint"><span class="name">Ordnode</span>.<span class="name">disjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>O(m + n). Is every element of <code>t₁</code> not equivalent to any element of <code>t₂</code>?</p><p>disjoint {1, 3} {2, 4} = tt
disjoint {1, 2} {2, 4} = ff</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint">disjoint</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint">disjoint</a></span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint">disjoint</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">Ordnode.split3</a> <span class="fn">x_2</span> <span class="fn">x✝</span></span> with
  | <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">lt</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">found</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">gt</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <span class="fn"><span class="fn">found</span>.<a href="../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint">disjoint</a></span> <span class="fn">lt</span></span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint">disjoint</a></span> <span class="fn">gt</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.disjoint" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.union"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1131-L1149">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union"><span class="name">Ordnode</span>.<span class="name">union</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(m * log(|m ∪ n| + 1)), m ≤ n. The union of two sets, preferring members of
<code>t₁</code> over those of <code>t₂</code> when equivalent elements are encountered.</p><p>union {1, 2} {2, 3} = {1, 2, 3}
union {1, 3} {2} = {1, 2, 3}</p><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><p>union {(1, 1)} {(0, 1), (1, 2)} = {(0, 1), (1, 1)}</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union">union</a></span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union">union</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li></ul></details><details id="instances-for-list-Ordnode.union" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.diff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1151-L1162">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff"><span class="name">Ordnode</span>.<span class="name">diff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(m * log(|m ∪ n| + 1)), m ≤ n. Difference of two sets.</p><p>diff {1, 2} {2, 3} = {1}
diff {1, 2, 3} {2} = {1, 3}</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff">diff</a></span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li></ul></details><details id="instances-for-list-Ordnode.diff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.inter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1164-L1176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter"><span class="name">Ordnode</span>.<span class="name">inter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(m * log(|m ∪ n| + 1)), m ≤ n. Intersection of two sets, preferring members of
<code>t₁</code> over those of <code>t₂</code> when equivalent elements are encountered.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter">inter</a> {1, 2} {2, 3} = {2}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter">inter</a> {1, 3} {2} = ∅ 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter">inter</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li></ul></details><details id="instances-for-list-Ordnode.inter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1178-L1188">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList"><span class="name">Ordnode</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p>O(n * log n). Build a set from a list, preferring elements that appear earlier in the list
in the case of equivalent elements.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">ofList</a> [1, 2, 3] = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">ofList</a> [2, 1, 1, 3] = {1, 2, 3}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">ofList</a> [(1, 1), (0, 1), (1, 2)] = {(0, 1), (1, 1)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">Ordnode.ofList</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <a href="../../.././Init/Core.html#Insert.insert">insert</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Ordnode.ofList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofList'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1190-L1197">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'"><span class="name">Ordnode</span>.<span class="name">ofList'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(n * log n). Adaptively chooses between the linear and log-linear algorithm depending
on whether the input list is already sorted.</p><p>ofList' [1, 2, 3] = {1, 2, 3}
ofList' [2, 1, 1, 3] = {1, 2, 3}</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'">Ordnode.ofList'</a> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">Ordnode.nil</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'">Ordnode.ofList'</a> (<span class="fn">x_1</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">xs</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.Chain">List.Chain</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span>)</span> <span class="fn">x_1</span> <span class="fn">xs</span></span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">Ordnode.ofAscList</a> (<span class="fn">x_1</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">xs</span>)</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">Ordnode.ofList</a> (<span class="fn">x_1</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">xs</span>)</span></li></ul></details><details id="instances-for-list-Ordnode.ofList'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.image"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/Ordmap/Ordnode.lean#L1199-L1206">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image"><span class="name">Ordnode</span>.<span class="name">image</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">β</span></span></div></div><p>O(n * log n). Map a function on a set. Unlike <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">map</a></code> this has no requirements on
<code>f</code>, and the resulting set may be smaller than the input if <code>f</code> is noninjective.
Equivalent elements are selected with a preference for smaller source elements.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image">image</a> (fun x ↦ x + 2) {1, 2, 4} = {3, 4, 6}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image">image</a> (fun x : ℕ ↦ x - 2) {1, 2, 4} = {0, 2} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image">Ordnode.image</a> <span class="fn">f</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">Ordnode.ofList</a> <span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn"><span class="fn">t</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">toList</a></span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.image" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>