<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Condensed.Explicit</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Condensed.Explicit";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Condensed</span>.<span class="name">Explicit</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Condensed/Equivalence.html">Mathlib.Condensed.Equivalence</a></li><li><a href="../.././Mathlib/Condensed/Module.html">Mathlib.Condensed.Module</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Condensed.Explicit" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Condensed.ofSheafStonean"><span class="name">Condensed</span>.<span class="name">ofSheafStonean</span></a></div><div class="nav_link"><a class="break_within" href="#Condensed.ofSheafForgetStonean"><span class="name">Condensed</span>.<span class="name">ofSheafForgetStonean</span></a></div><div class="nav_link"><a class="break_within" href="#Condensed.ofSheafProfinite"><span class="name">Condensed</span>.<span class="name">ofSheafProfinite</span></a></div><div class="nav_link"><a class="break_within" href="#Condensed.ofSheafForgetProfinite"><span class="name">Condensed</span>.<span class="name">ofSheafForgetProfinite</span></a></div><div class="nav_link"><a class="break_within" href="#Condensed.ofSheafCompHaus"><span class="name">Condensed</span>.<span class="name">ofSheafCompHaus</span></a></div><div class="nav_link"><a class="break_within" href="#Condensed.ofSheafForgetCompHaus"><span class="name">Condensed</span>.<span class="name">ofSheafForgetCompHaus</span></a></div><div class="nav_link"><a class="break_within" href="#Condensed.equalizerCondition"><span class="name">Condensed</span>.<span class="name">equalizerCondition</span></a></div><div class="nav_link"><a class="break_within" href="#Condensed.instPreservesFiniteProductsOppositeCompHausVal"><span class="name">Condensed</span>.<span class="name">instPreservesFiniteProductsOppositeCompHausVal</span></a></div><div class="nav_link"><a class="break_within" href="#Condensed.instPreservesFiniteProductsOppositeProfiniteVal"><span class="name">Condensed</span>.<span class="name">instPreservesFiniteProductsOppositeProfiniteVal</span></a></div><div class="nav_link"><a class="break_within" href="#Condensed.equalizerCondition_profinite"><span class="name">Condensed</span>.<span class="name">equalizerCondition_profinite</span></a></div><div class="nav_link"><a class="break_within" href="#Condensed.instPreservesFiniteProductsOppositeStoneanVal"><span class="name">Condensed</span>.<span class="name">instPreservesFiniteProductsOppositeStoneanVal</span></a></div><div class="nav_link"><a class="break_within" href="#CondensedSet.ofSheafStonean"><span class="name">CondensedSet</span>.<span class="name">ofSheafStonean</span></a></div><div class="nav_link"><a class="break_within" href="#CondensedSet.ofSheafProfinite"><span class="name">CondensedSet</span>.<span class="name">ofSheafProfinite</span></a></div><div class="nav_link"><a class="break_within" href="#CondensedSet.ofSheafCompHaus"><span class="name">CondensedSet</span>.<span class="name">ofSheafCompHaus</span></a></div><div class="nav_link"><a class="break_within" href="#CondensedMod.ofSheafStonean"><span class="name">CondensedMod</span>.<span class="name">ofSheafStonean</span></a></div><div class="nav_link"><a class="break_within" href="#CondensedMod.ofSheafProfinite"><span class="name">CondensedMod</span>.<span class="name">ofSheafProfinite</span></a></div><div class="nav_link"><a class="break_within" href="#CondensedMod.ofSheafCompHaus"><span class="name">CondensedMod</span>.<span class="name">ofSheafCompHaus</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-explicit-sheaf-condition-for-condensed-sets">The explicit sheaf condition for condensed sets <a class="hover-link" href="#The-explicit-sheaf-condition-for-condensed-sets">#</a></h1><p>We give the following three explicit descriptions of condensed objects:</p><ul>
<li><p><code><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafStonean">Condensed.ofSheafStonean</a></code>: A finite-product-preserving presheaf on <code><a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean">Stonean</a></code>.</p>
</li>
<li><p><code><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafProfinite">Condensed.ofSheafProfinite</a></code>: A finite-product-preserving presheaf on <code><a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a></code>, satisfying
<code>EqualizerCondition</code>.</p>
</li>
<li><p><code><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafStonean">Condensed.ofSheafStonean</a></code>: A finite-product-preserving presheaf on <code><a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a></code>, satisfying
<code>EqualizerCondition</code>.</p>
</li>
</ul><p>The property <code>EqualizerCondition</code> is defined in <code><a href="../.././Mathlib/CategoryTheory/Sites/RegularSheaves.html">Mathlib/CategoryTheory/Sites/RegularSheaves.lean</a></code>
and it says that for any effective epi <code>X ⟶ B</code> (in this case that is equivalent to being a
continuous surjection), the presheaf <code>F</code> exhibits <code>F(B)</code> as the equalizer of the two maps
<code>F(X) ⇉ F(X ×_B X)</code></p><p>We also give variants for condensed objects in concrete categories whose forgetful functor
reflects finite limits (resp. products), where it is enough to check the sheaf condition after
postcomposing with the forgetful functor.</p></div><div class="decl" id="Condensed.ofSheafStonean"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L40-L49">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafStonean"><span class="name">Condensed</span>.<span class="name">ofSheafStonean</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">X</span> : <a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>), <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasLimitsOfShape">CategoryTheory.Limits.HasLimitsOfShape</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn"><a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean.toCompHaus">Stonean.toCompHaus</a>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span> <span class="fn">A</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean">Stonean</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Condensed/Basic.html#Condensed">Condensed</a> <span class="fn">A</span></span></div></div><p>The condensed object associated to a finite-product-preserving presheaf on <code><a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean">Stonean</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafStonean">Condensed.ofSheafStonean</a> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Condensed/Equivalence.html#Condensed.StoneanCompHaus.equivalence">Condensed.StoneanCompHaus.equivalence</a> <span class="fn">A</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">{ <span class="fn">val</span> := <span class="fn">F</span>, <span class="fn">cond</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-Condensed.ofSheafStonean" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Condensed.ofSheafForgetStonean"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L51-L65">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafForgetStonean"><span class="name">Condensed</span>.<span class="name">ofSheafForgetStonean</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">X</span> : <a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>), <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasLimitsOfShape">CategoryTheory.Limits.HasLimitsOfShape</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn"><a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean.toCompHaus">Stonean.toCompHaus</a>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span> <span class="fn">A</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.HasForget">CategoryTheory.HasForget</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.ReflectsFiniteProducts">CategoryTheory.Limits.ReflectsFiniteProducts</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget">CategoryTheory.forget</a> <span class="fn">A</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean">Stonean</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget">CategoryTheory.forget</a> <span class="fn">A</span>)</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Condensed/Basic.html#Condensed">Condensed</a> <span class="fn">A</span></span></div></div><p>The condensed object associated to a presheaf on <code><a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean">Stonean</a></code> whose postcomposition with the
forgetful functor preserves finite products.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafForgetStonean">Condensed.ofSheafForgetStonean</a> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Condensed/Equivalence.html#Condensed.StoneanCompHaus.equivalence">Condensed.StoneanCompHaus.equivalence</a> <span class="fn">A</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">{ <span class="fn">val</span> := <span class="fn">F</span>, <span class="fn">cond</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-Condensed.ofSheafForgetStonean" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Condensed.ofSheafProfinite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L67-L79">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafProfinite"><span class="name">Condensed</span>.<span class="name">ofSheafProfinite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">X</span> : <a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>), <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasLimitsOfShape">CategoryTheory.Limits.HasLimitsOfShape</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn"><a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#profiniteToCompHaus">profiniteToCompHaus</a>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span> <span class="fn">A</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.html#CategoryTheory.regularTopology.EqualizerCondition">CategoryTheory.regularTopology.EqualizerCondition</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Condensed/Basic.html#Condensed">Condensed</a> <span class="fn">A</span></span></div></div><p>The condensed object associated to a presheaf on <code><a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a></code> which preserves finite products and
satisfies the equalizer condition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafProfinite">Condensed.ofSheafProfinite</a> <span class="fn">F</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Condensed/Equivalence.html#Condensed.ProfiniteCompHaus.equivalence">Condensed.ProfiniteCompHaus.equivalence</a> <span class="fn">A</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">{ <span class="fn">val</span> := <span class="fn">F</span>, <span class="fn">cond</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-Condensed.ofSheafProfinite" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Condensed.ofSheafForgetProfinite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L81-L96">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafForgetProfinite"><span class="name">Condensed</span>.<span class="name">ofSheafForgetProfinite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">X</span> : <a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>), <span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasLimitsOfShape">CategoryTheory.Limits.HasLimitsOfShape</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn"><a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#profiniteToCompHaus">profiniteToCompHaus</a>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span> <span class="fn">A</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.HasForget">CategoryTheory.HasForget</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.ReflectsFiniteLimits">CategoryTheory.Limits.ReflectsFiniteLimits</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget">CategoryTheory.forget</a> <span class="fn">A</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget">CategoryTheory.forget</a> <span class="fn">A</span>)</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.html#CategoryTheory.regularTopology.EqualizerCondition">CategoryTheory.regularTopology.EqualizerCondition</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget">CategoryTheory.forget</a> <span class="fn">A</span>)</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Condensed/Basic.html#Condensed">Condensed</a> <span class="fn">A</span></span></div></div><p>The condensed object associated to a presheaf on <code><a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a></code> whose postcomposition with the
forgetful functor preserves finite products and satisfies the equalizer condition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafForgetProfinite">Condensed.ofSheafForgetProfinite</a> <span class="fn">F</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Condensed/Equivalence.html#Condensed.ProfiniteCompHaus.equivalence">Condensed.ProfiniteCompHaus.equivalence</a> <span class="fn">A</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">{ <span class="fn">val</span> := <span class="fn">F</span>, <span class="fn">cond</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-Condensed.ofSheafForgetProfinite" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Condensed.ofSheafCompHaus"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L98-L108">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafCompHaus"><span class="name">Condensed</span>.<span class="name">ofSheafCompHaus</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.html#CategoryTheory.regularTopology.EqualizerCondition">CategoryTheory.regularTopology.EqualizerCondition</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Condensed/Basic.html#Condensed">Condensed</a> <span class="fn">A</span></span></div></div><p>The condensed object associated to a presheaf on <code><a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a></code> which preserves finite products and
satisfies the equalizer condition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafCompHaus">Condensed.ofSheafCompHaus</a> <span class="fn">F</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">F</span>, <span class="fn">cond</span> := <span class="fn">⋯</span> }</span></li></ul></details><details id="instances-for-list-Condensed.ofSheafCompHaus" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Condensed.ofSheafForgetCompHaus"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L110-L122">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafForgetCompHaus"><span class="name">Condensed</span>.<span class="name">ofSheafForgetCompHaus</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.HasForget">CategoryTheory.HasForget</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.ReflectsFiniteLimits">CategoryTheory.Limits.ReflectsFiniteLimits</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget">CategoryTheory.forget</a> <span class="fn">A</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget">CategoryTheory.forget</a> <span class="fn">A</span>)</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.html#CategoryTheory.regularTopology.EqualizerCondition">CategoryTheory.regularTopology.EqualizerCondition</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget">CategoryTheory.forget</a> <span class="fn">A</span>)</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Condensed/Basic.html#Condensed">Condensed</a> <span class="fn">A</span></span></div></div><p>The condensed object associated to a presheaf on <code><a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a></code> whose postcomposition with the
forgetful functor preserves finite products and satisfies the equalizer condition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafForgetCompHaus">Condensed.ofSheafForgetCompHaus</a> <span class="fn">F</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">F</span>, <span class="fn">cond</span> := <span class="fn">⋯</span> }</span></li></ul></details><details id="instances-for-list-Condensed.ofSheafForgetCompHaus" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Condensed.equalizerCondition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L124-L126">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.equalizerCondition"><span class="name">Condensed</span>.<span class="name">equalizerCondition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_3, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/Condensed/Basic.html#Condensed">Condensed</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.html#CategoryTheory.regularTopology.EqualizerCondition">CategoryTheory.regularTopology.EqualizerCondition</a> <span class="fn"><span class="fn">X</span>.<a href="../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span></span></div></div><p>A condensed object satisfies the equalizer condition.</p></div></div><div class="decl" id="Condensed.instPreservesFiniteProductsOppositeCompHausVal"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L128-L131">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.instPreservesFiniteProductsOppositeCompHausVal"><span class="name">Condensed</span>.<span class="name">instPreservesFiniteProductsOppositeCompHausVal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_3, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/Condensed/Basic.html#Condensed">Condensed</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn"><span class="fn">X</span>.<a href="../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span></span></div></div><p>A condensed object preserves finite products.</p></div></div><div class="decl" id="Condensed.instPreservesFiniteProductsOppositeProfiniteVal"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L133-L137">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.instPreservesFiniteProductsOppositeProfiniteVal"><span class="name">Condensed</span>.<span class="name">instPreservesFiniteProductsOppositeProfiniteVal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">CategoryTheory.Sheaf</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Sites/Coherent/Basic.html#CategoryTheory.coherentTopology">CategoryTheory.coherentTopology</a> <a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a>)</span> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn"><span class="fn">X</span>.<a href="../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span></span></div></div><p>A condensed object regarded as a sheaf on <code><a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a></code> preserves finite products.</p></div></div><div class="decl" id="Condensed.equalizerCondition_profinite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L139-L142">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.equalizerCondition_profinite"><span class="name">Condensed</span>.<span class="name">equalizerCondition_profinite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">CategoryTheory.Sheaf</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Sites/Coherent/Basic.html#CategoryTheory.coherentTopology">CategoryTheory.coherentTopology</a> <a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a>)</span> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.html#CategoryTheory.regularTopology.EqualizerCondition">CategoryTheory.regularTopology.EqualizerCondition</a> <span class="fn"><span class="fn">X</span>.<a href="../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span></span></div></div><p>A condensed object regarded as a sheaf on <code><a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a></code> satisfies the equalizer condition.</p></div></div><div class="decl" id="Condensed.instPreservesFiniteProductsOppositeStoneanVal"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L144-L147">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#Condensed.instPreservesFiniteProductsOppositeStoneanVal"><span class="name">Condensed</span>.<span class="name">instPreservesFiniteProductsOppositeStoneanVal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">CategoryTheory.Sheaf</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Sites/Coherent/Basic.html#CategoryTheory.coherentTopology">CategoryTheory.coherentTopology</a> <a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean">Stonean</a>)</span> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn"><span class="fn">X</span>.<a href="../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span></span></div></div><p>A condensed object regarded as a sheaf on <code><a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean">Stonean</a></code> preserves finite products.</p></div></div><div class="decl" id="CondensedSet.ofSheafStonean"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L153-L156">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#CondensedSet.ofSheafStonean"><span class="name">CondensedSet</span>.<span class="name">ofSheafStonean</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean">Stonean</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <a href="../.././foundational_types.html">(Type</a> (u + 1))</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Condensed/Basic.html#CondensedSet">CondensedSet</a></div></div><p>A <code><a href="../.././Mathlib/Condensed/Basic.html#CondensedSet">CondensedSet</a></code> version of <code><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafStonean">Condensed.ofSheafStonean</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#CondensedSet.ofSheafStonean">CondensedSet.ofSheafStonean</a> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafStonean">Condensed.ofSheafStonean</a> <span class="fn">F</span></span></li></ul></details><details id="instances-for-list-CondensedSet.ofSheafStonean" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CondensedSet.ofSheafProfinite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L158-L161">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#CondensedSet.ofSheafProfinite"><span class="name">CondensedSet</span>.<span class="name">ofSheafProfinite</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <a href="../.././foundational_types.html">(Type</a> (u + 1))</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.html#CategoryTheory.regularTopology.EqualizerCondition">CategoryTheory.regularTopology.EqualizerCondition</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Condensed/Basic.html#CondensedSet">CondensedSet</a></div></div><p>A <code><a href="../.././Mathlib/Condensed/Basic.html#CondensedSet">CondensedSet</a></code> version of <code><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafProfinite">Condensed.ofSheafProfinite</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#CondensedSet.ofSheafProfinite">CondensedSet.ofSheafProfinite</a> <span class="fn">F</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafProfinite">Condensed.ofSheafProfinite</a> <span class="fn">F</span> <span class="fn">hF</span></span></li></ul></details><details id="instances-for-list-CondensedSet.ofSheafProfinite" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CondensedSet.ofSheafCompHaus"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L163-L166">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#CondensedSet.ofSheafCompHaus"><span class="name">CondensedSet</span>.<span class="name">ofSheafCompHaus</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <a href="../.././foundational_types.html">(Type</a> (u + 1))</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.html#CategoryTheory.regularTopology.EqualizerCondition">CategoryTheory.regularTopology.EqualizerCondition</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Condensed/Basic.html#CondensedSet">CondensedSet</a></div></div><p>A <code><a href="../.././Mathlib/Condensed/Basic.html#CondensedSet">CondensedSet</a></code> version of <code><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafCompHaus">Condensed.ofSheafCompHaus</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#CondensedSet.ofSheafCompHaus">CondensedSet.ofSheafCompHaus</a> <span class="fn">F</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafCompHaus">Condensed.ofSheafCompHaus</a> <span class="fn">F</span> <span class="fn">hF</span></span></li></ul></details><details id="instances-for-list-CondensedSet.ofSheafCompHaus" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CondensedMod.ofSheafStonean"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L174-L179">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#CondensedMod.ofSheafStonean"><span class="name">CondensedMod</span>.<span class="name">ofSheafStonean</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> (u + 1))</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/Stonean/Basic.html#Stonean">Stonean</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">(<a href="../.././Mathlib/Algebra/Category/ModuleCat/Basic.html#ModuleCat">ModuleCat</a> <span class="fn">R</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Condensed/Module.html#CondensedMod">CondensedMod</a> <span class="fn">R</span></span></div></div><p>A <code><a href="../.././Mathlib/Condensed/Module.html#CondensedMod">CondensedMod</a></code> version of <code><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafStonean">Condensed.ofSheafStonean</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#CondensedMod.ofSheafStonean">CondensedMod.ofSheafStonean</a> <span class="fn">R</span> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafStonean">Condensed.ofSheafStonean</a> <span class="fn">F</span></span></li></ul></details><details id="instances-for-list-CondensedMod.ofSheafStonean" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CondensedMod.ofSheafProfinite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L181-L186">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#CondensedMod.ofSheafProfinite"><span class="name">CondensedMod</span>.<span class="name">ofSheafProfinite</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> (u + 1))</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">(<a href="../.././Mathlib/Algebra/Category/ModuleCat/Basic.html#ModuleCat">ModuleCat</a> <span class="fn">R</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.html#CategoryTheory.regularTopology.EqualizerCondition">CategoryTheory.regularTopology.EqualizerCondition</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Condensed/Module.html#CondensedMod">CondensedMod</a> <span class="fn">R</span></span></div></div><p>A <code><a href="../.././Mathlib/Condensed/Module.html#CondensedMod">CondensedMod</a></code> version of <code><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafProfinite">Condensed.ofSheafProfinite</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#CondensedMod.ofSheafProfinite">CondensedMod.ofSheafProfinite</a> <span class="fn">R</span> <span class="fn">F</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafProfinite">Condensed.ofSheafProfinite</a> <span class="fn">F</span> <span class="fn">hF</span></span></li></ul></details><details id="instances-for-list-CondensedMod.ofSheafProfinite" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CondensedMod.ofSheafCompHaus"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Condensed/Explicit.lean#L188-L191">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Condensed/Explicit.html#CondensedMod.ofSheafCompHaus"><span class="name">CondensedMod</span>.<span class="name">ofSheafCompHaus</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> (u + 1))</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <a href="../.././Mathlib/Topology/Category/CompHaus/Basic.html#CompHaus">CompHaus</a><a href="../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">(<a href="../.././Mathlib/Algebra/Category/ModuleCat/Basic.html#ModuleCat">ModuleCat</a> <span class="fn">R</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.html#CategoryTheory.regularTopology.EqualizerCondition">CategoryTheory.regularTopology.EqualizerCondition</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Condensed/Module.html#CondensedMod">CondensedMod</a> <span class="fn">R</span></span></div></div><p>A <code><a href="../.././Mathlib/Condensed/Module.html#CondensedMod">CondensedMod</a></code> version of <code><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafCompHaus">Condensed.ofSheafCompHaus</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#CondensedMod.ofSheafCompHaus">CondensedMod.ofSheafCompHaus</a> <span class="fn">R</span> <span class="fn">F</span> <span class="fn">hF</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Condensed/Explicit.html#Condensed.ofSheafCompHaus">Condensed.ofSheafCompHaus</a> <span class="fn">F</span> <span class="fn">hF</span></span></li></ul></details><details id="instances-for-list-CondensedMod.ofSheafCompHaus" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>