<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.AlgebraicTopology.DoldKan.Equivalence</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.AlgebraicTopology.DoldKan.Equivalence";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">AlgebraicTopology</span>.<span class="name">DoldKan</span>.<span class="name">Equivalence</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.html">Mathlib.AlgebraicTopology.DoldKan.EquivalencePseudoabelian</a></li><li><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Normalized.html">Mathlib.AlgebraicTopology.DoldKan.Normalized</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.AlgebraicTopology.DoldKan.Equivalence" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Abelian.DoldKan.N"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">N</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Abelian.DoldKan.Œì"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">Œì</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Abelian.DoldKan.comparisonN"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">comparisonN</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Abelian.DoldKan.comparisonN_inv_app_f"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">comparisonN_inv_app_f</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Abelian.DoldKan.comparisonN_hom_app_f"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">comparisonN_hom_app_f</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Abelian.DoldKan.equivalence"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Abelian.DoldKan.equivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">equivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Abelian.DoldKan.equivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">equivalence_inverse</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-Dold-Kan-correspondence">The Dold-Kan correspondence <a class="hover-link" href="#The-Dold-Kan-correspondence">#</a></h1><p>The Dold-Kan correspondence states that for any abelian category <code>A</code>, there is
an equivalence between the category of simplicial objects in <code>A</code> and the
category of chain complexes in <code>A</code> (with degrees indexed by <code>‚Ñï</code> and the
homological convention that the degree is decreased by the differentials).</p><p>In this file, we finish the construction of this equivalence by providing
<code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.equivalence">CategoryTheory.Abelian.DoldKan.equivalence</a></code> which is of type
<code>SimplicialObject A ‚âå <a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> A ‚Ñï</code> for any abelian category <code>A</code>.
The functor <code>SimplicialObject A ‚•§ <a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> A ‚Ñï</code> of this equivalence is
definitionally equal to <code>normalizedMooreComplex A</code>.</p><h2 class="markdown-heading" id="Overall-strategy-of-the-proof-of-the-correspondence">Overall strategy of the proof of the correspondence <a class="hover-link" href="#Overall-strategy-of-the-proof-of-the-correspondence">#</a></h2><p>Before starting the implementation of the proof in Lean, the author noticed
that the Dold-Kan equivalence not only applies to abelian categories, but
should also hold generally for any pseudoabelian category <code>C</code>
(i.e. a category with instances <code>[Preadditive C]</code>
<code>[HasFiniteCoproducts C]</code> and <code>[IsIdempotentComplete C]</code>): this is
<code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.html#CategoryTheory.Idempotents.DoldKan.equivalence">CategoryTheory.Idempotents.DoldKan.equivalence</a></code>.</p><p>When the alternating face map complex <code>K[X]</code> of a simplicial object <code>X</code> in an
abelian is studied, it is shown that it decomposes as a direct sum of the
normalized subcomplex and of the degenerate subcomplex. The crucial observation
is that in this decomposition, the projection on the normalized subcomplex can
be defined in each degree using simplicial operators. Then, the definition
of this projection <code>PInfty : K[X] ‚ü∂ K[X]</code> can be carried out for any
<code>X : SimplicialObject C</code> when <code>C</code> is a preadditive category.</p><p>The construction of the endomorphism <code>PInfty</code> is done in the files
<code>Homotopies.lean</code>, <code>Faces.lean</code>, <code>Projections.lean</code> and <code>PInfty.lean</code>.
Eventually, as we would also like to show that the inclusion of the normalized
Moore complex is a homotopy equivalence (cf. file <code>HomotopyEquivalence.lean</code>),
this projection <code>PInfty</code> needs to be homotopic to the identity. In our
construction, we get this for free because <code>PInfty</code> is obtained by altering
the identity endomorphism by null homotopic maps. More details about this
aspect of the proof are in the file <code>Homotopies.lean</code>.</p><p>When the alternating face map complex <code>K[X]</code> is equipped with the idempotent
endomorphism <code>PInfty</code>, it becomes an object in <code>Karoubi (ChainComplex C ‚Ñï)</code>
which is the idempotent completion of the category <code><a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> C ‚Ñï</code>. In <code>FunctorN.lean</code>,
we obtain this functor <code>N‚ÇÅ : SimplicialObject C ‚•§ Karoubi (ChainComplex C ‚Ñï)</code>,
which is formally extended as
<code>N‚ÇÇ : Karoubi (SimplicialObject C) ‚•§ Karoubi (ChainComplex C ‚Ñï)</code>. (Here, some functors
have an index which is the number of occurrences of <code>Karoubi</code> at the source or the
target.)</p><p>In <code>FunctorGamma.lean</code>, assuming that the category <code>C</code> is additive,
we define the functor in the other direction
<code>Œì‚ÇÇ : Karoubi (ChainComplex C ‚Ñï) ‚•§ Karoubi (SimplicialObject C)</code> as the formal
extension of a functor <code>Œì‚ÇÄ : <a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> C ‚Ñï ‚•§ SimplicialObject C</code> which is
defined similarly as in [<em>Simplicial Homotopy Theory</em> by Goerss-Jardine][goerss-jardine-2009].
In <code>Degeneracies.lean</code>, we show that <code>PInfty</code> vanishes on the image of degeneracy
operators, which is one of the key properties that makes it possible to construct
the isomorphism <code>N‚ÇÇŒì‚ÇÇ : Œì‚ÇÇ ‚ãô N‚ÇÇ ‚âÖ ùü≠ (Karoubi (ChainComplex C ‚Ñï))</code>.</p><p>The rest of the proof follows the strategy in the [original paper by Dold][dold1958]. We show
that the functor <code>N‚ÇÇ</code> reflects isomorphisms in <code>NReflectsIso.lean</code>: this relies on a
decomposition of the identity of <code>X _‚¶ãn‚¶å</code> using <code>PInfty.f n</code> and degeneracies obtained in
<code>Decomposition.lean</code>. Then, in <code>NCompGamma.lean</code>, we construct a natural transformation
<code>Œì‚ÇÇN‚ÇÇ.<a href="../../.././Mathlib/Order/Defs/Unbundled.html#trans">trans</a> : N‚ÇÇ ‚ãô Œì‚ÇÇ ‚ü∂ ùü≠ (Karoubi (SimplicialObject C))</code>. It is shown that it is an
isomorphism using the fact that <code>N‚ÇÇ</code> reflects isomorphisms, and because we can show
that the composition <code>N‚ÇÇ ‚ü∂ N‚ÇÇ ‚ãô Œì‚ÇÇ ‚ãô N‚ÇÇ ‚ü∂ N‚ÇÇ</code> is the identity (see <code>identity_N‚ÇÇ</code>). The fact
that <code>N‚ÇÇ</code> is defined as a formal direct factor makes the proof easier because we only
have to compare endomorphisms of an alternating face map complex <code>K[X]</code> and we do not
have to worry with inclusions of kernel subobjects.</p><p>In <code>EquivalenceAdditive.lean</code>, we obtain
the equivalence <code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.equivalence">equivalence</a> : Karoubi (SimplicialObject C) ‚âå Karoubi (ChainComplex C ‚Ñï)</code>.
It is in the namespace <code>CategoryTheory.Preadditive.DoldKan</code>. The functors in this
equivalence are named <code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.N">N</a></code> and <code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.Œì">Œì</a></code>: by definition, they are <code>N‚ÇÇ</code> and <code>Œì‚ÇÇ</code>.</p><p>In <code>EquivalencePseudoabelian.lean</code>, assuming <code>C</code> is idempotent complete,
we obtain <code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.equivalence">equivalence</a> : SimplicialObject C ‚âå <a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> C ‚Ñï</code>
in the namespace <code>CategoryTheory.Idempotents.DoldKan</code>. This could be roughly
obtained by composing the previous equivalence with the equivalences
<code>SimplicialObject C ‚âå Karoubi (SimplicialObject C)</code> and
<code>Karoubi (ChainComplex C ‚Ñï) ‚âå <a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> C ‚Ñï</code>. Instead, we polish this construction
in <code>Compatibility.lean</code> by ensuring good definitional properties of the equivalence (e.g.
the inverse functor is definitionally equal to
<code>Œì‚ÇÄ' : <a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> C ‚Ñï ‚•§ SimplicialObject C</code>) and
showing compatibilities for the unit and counit isomorphisms.</p><p>In this file <code>Equivalence.lean</code>, assuming the category <code>A</code> is abelian, we obtain
<code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.equivalence">equivalence</a> : SimplicialObject A ‚âå <a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> A ‚Ñï</code> in the namespace
<code>CategoryTheory.Abelian.DoldKan</code>. This is obtained by replacing the functor
<code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.html#CategoryTheory.Idempotents.DoldKan.N">CategoryTheory.Idempotents.DoldKan.N</a></code> of the equivalence in the pseudoabelian case
with the isomorphic functor <code>normalizedMooreComplex A</code> thanks to the isomorphism
obtained in <code>Normalized.lean</code>.</p><p>TODO: Show functoriality properties of the three equivalences above. More precisely,
for example in the case of abelian categories <code>A</code> and <code>B</code>, if <code>F : A ‚•§ B</code> is an
additive functor, we can show that the functors <code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.N">N</a></code> for <code>A</code> and <code>B</code> are compatible
with the functors <code>SimplicialObject A ‚•§ SimplicialObject B</code> and
<code><a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> A ‚Ñï ‚•§ <a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> B ‚Ñï</code> induced by <code>F</code>. (Note that this does not
require that <code>F</code> is an exact functor!)</p><p>TODO: Introduce the degenerate subcomplex <code>D[X]</code> which is generated by
degenerate simplices, show that the projector <code>PInfty</code> corresponds to
a decomposition <code>K[X] ‚âÖ N[X] ‚äû D[X]</code>.</p><p>TODO: dualise all of this as <code>CosimplicialObject A ‚•§ <a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#CochainComplex">CochainComplex</a> A ‚Ñï</code>. (It is unclear
what is the best way to do this. The exact design may be decided when it is needed.)</p><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li>[Albrecht Dold, Homology of Symmetric Products and Other Functors of Complexes][dold1958]</li>
<li>[Paul G. Goerss, John F. Jardine, Simplicial Homotopy Theory][goerss-jardine-2009]</li>
</ul></div><div class="decl" id="CategoryTheory.Abelian.DoldKan.N"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean#L137-L139">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.N"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">N</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian">Abelian</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../../.././Mathlib/AlgebraicTopology/SimplicialObject/Basic.html#CategoryTheory.SimplicialObject">SimplicialObject</a> <span class="fn">A</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> <span class="fn">A</span> <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>)</span></span></div></div><p>The functor <code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.N">N</a></code> for the equivalence is <code>normalizedMooreComplex A</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.N">CategoryTheory.Abelian.DoldKan.N</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/MooreComplex.html#AlgebraicTopology.normalizedMooreComplex">AlgebraicTopology.normalizedMooreComplex</a> <span class="fn">A</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Abelian.DoldKan.N" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Abelian.DoldKan.Œì"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean#L141-L143">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.Œì"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">Œì</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian">Abelian</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> <span class="fn">A</span> <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>)</span> <span class="fn">(<a href="../../.././Mathlib/AlgebraicTopology/SimplicialObject/Basic.html#CategoryTheory.SimplicialObject">SimplicialObject</a> <span class="fn">A</span>)</span></span></div></div><p>The functor <code><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.Œì">Œì</a></code> for the equivalence is the same as in the pseudoabelian case.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.Œì">CategoryTheory.Abelian.DoldKan.Œì</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.html#CategoryTheory.Idempotents.DoldKan.Œì">CategoryTheory.Idempotents.DoldKan.Œì</a></li></ul></details><details id="instances-for-list-CategoryTheory.Abelian.DoldKan.Œì" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Abelian.DoldKan.comparisonN"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean#L145-L157">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.comparisonN"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">comparisonN</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian">Abelian</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.N">N</a> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <a href="../../.././Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.html#CategoryTheory.Idempotents.DoldKan.N">Idempotents.DoldKan.N</a></div></div><p>The comparison isomorphism between <code>normalizedMooreComplex A</code> and
the functor <code>Idempotents.DoldKan.<a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.N">N</a></code> from the pseudoabelian case</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Abelian.DoldKan.comparisonN" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Abelian.DoldKan.comparisonN_inv_app_f"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean#L147-L147">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.comparisonN_inv_app_f"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">comparisonN_inv_app_f</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian">Abelian</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/SimplicialObject/Basic.html#CategoryTheory.SimplicialObject">SimplicialObject</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.comparisonN">comparisonN</a>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#HomologicalComplex.Hom.f">f</a></span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a>
    <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Idempotents/Karoubi.html#CategoryTheory.Idempotents.toKaroubiEquivalence">Idempotents.toKaroubiEquivalence</a> <span class="fn">(<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> <span class="fn">A</span> <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>)</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span>
          <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Normalized.html#AlgebraicTopology.DoldKan.N‚ÇÅ_iso_normalizedMooreComplex_comp_toKaroubi">AlgebraicTopology.DoldKan.N‚ÇÅ_iso_normalizedMooreComplex_comp_toKaroubi</a> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span>.<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#HomologicalComplex.Hom.f">f</a></span>
      <span class="fn">i</span>)</span>
    <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Idempotents/Karoubi.html#CategoryTheory.Idempotents.toKaroubiEquivalence">Idempotents.toKaroubiEquivalence</a> <span class="fn">(<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> <span class="fn">A</span> <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>)</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.N">N</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>.<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#HomologicalComplex.Hom.f">f</a></span> <span class="fn">i</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Abelian.DoldKan.comparisonN_hom_app_f"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean#L147-L147">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.comparisonN_hom_app_f"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">comparisonN_hom_app_f</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian">Abelian</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/SimplicialObject/Basic.html#CategoryTheory.SimplicialObject">SimplicialObject</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.comparisonN">comparisonN</a>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#HomologicalComplex.Hom.f">f</a></span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Idempotents/Karoubi.html#CategoryTheory.Idempotents.toKaroubiEquivalence">Idempotents.toKaroubiEquivalence</a> <span class="fn">(<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> <span class="fn">A</span> <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>)</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.N">N</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>.<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#HomologicalComplex.Hom.f">f</a></span> <span class="fn">i</span>)</span>
    <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Idempotents/Karoubi.html#CategoryTheory.Idempotents.toKaroubiEquivalence">Idempotents.toKaroubiEquivalence</a> <span class="fn">(<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> <span class="fn">A</span> <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>)</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span>
          <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Normalized.html#AlgebraicTopology.DoldKan.N‚ÇÅ_iso_normalizedMooreComplex_comp_toKaroubi">AlgebraicTopology.DoldKan.N‚ÇÅ_iso_normalizedMooreComplex_comp_toKaroubi</a> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span>.<a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#HomologicalComplex.Hom.f">f</a></span>
      <span class="fn">i</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Abelian.DoldKan.equivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean#L159-L162">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.equivalence"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian">Abelian</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/SimplicialObject/Basic.html#CategoryTheory.SimplicialObject">SimplicialObject</a> <span class="fn">A</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn"><a href="../../.././Mathlib/Algebra/Homology/HomologicalComplex.html#ChainComplex">ChainComplex</a> <span class="fn">A</span> <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a></span></div></div><p>The Dold-Kan equivalence for abelian categories</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.equivalence">CategoryTheory.Abelian.DoldKan.equivalence</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.html#CategoryTheory.Idempotents.DoldKan.equivalence">CategoryTheory.Idempotents.DoldKan.equivalence</a>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.comparisonN">CategoryTheory.Abelian.DoldKan.comparisonN</a>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Abelian.DoldKan.equivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Abelian.DoldKan.equivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean#L160-L160">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.equivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">equivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian">Abelian</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.equivalence">equivalence</a>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.N">N</a></div></div></div></div><div class="decl" id="CategoryTheory.Abelian.DoldKan.equivalence_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean#L164-L165">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.equivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Abelian</span>.<span class="name">DoldKan</span>.<span class="name">equivalence_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian">Abelian</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.equivalence">equivalence</a>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/AlgebraicTopology/DoldKan/Equivalence.html#CategoryTheory.Abelian.DoldKan.Œì">Œì</a></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>