<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Equivalence</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Equivalence";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Equivalence</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/CategoryTheory/EssentialImage.html">Mathlib.CategoryTheory.EssentialImage</a></li><li><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html">Mathlib.CategoryTheory.FullSubcategory</a></li><li><a href="../.././Mathlib/CategoryTheory/Whiskering.html">Mathlib.CategoryTheory.Whiskering</a></li><li><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html">Mathlib.CategoryTheory.Functor.FullyFaithful</a></li><li><a href="../.././Mathlib/Tactic/CategoryTheory/Slice.html">Mathlib.Tactic.CategoryTheory.Slice</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Equivalence" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ext_iff"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ext"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.«term_≌_»"><span class="name">CategoryTheory</span>.<span class="name">«term_≌_»</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functor_unit_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functor_unit_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_functor_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_functor_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_app_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counit_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit_app_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_inverse_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_inverse_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inverse_counitInv_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inverse_counitInv_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_app_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unitInv_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv_app_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fun_inv_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inv_fun_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.adjointifyη"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointifyη</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.adjointify_η_ε"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.adjointify_η_ε_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mk"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.instInhabited"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.funInvIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.funInvIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.funInvIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.invFunIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.invFunIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.invFunIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unitInv_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counit_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unit_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counitInv_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unit_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counitInv_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.powNat"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">powNat</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.instPowInt"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instPowInt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow_zero"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_zero</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_one</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow_neg_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_neg_one</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.essSurj_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurj_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.essSurj_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurj_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fullyFaithfulFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fullyFaithfulInverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulInverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.faithful_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">faithful_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.faithful_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">faithful_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.full_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">full_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.full_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">full_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_counitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_counitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_unitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_unitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_refl"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_trans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_counitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_unitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_counitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_unitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.isEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.isEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsEquivalence.mk'"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsEquivalence</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.asEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.asEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_refl"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_trans"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instIsEquivalenceObjWhiskeringLeft"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceObjWhiskeringLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instIsEquivalenceObjWhiskeringRight"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceObjWhiskeringRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">fun_inv_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv_fun_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_iff_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_iff_of_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_of_comp_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_of_comp_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.essSurjInducedFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurjInducedFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inducedFunctorOfEquiv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inducedFunctorOfEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fullyFaithfulToEssImage"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulToEssImage</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ofFullSubcategory"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ofFullSubcategory_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ofFullSubcategory_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ofFullSubcategory_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ofFullSubcategory_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInverseIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInverseIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInverseIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInverse_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInverse_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inverseCompIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inverseCompIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inverseCompIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseComp"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseOfIsoFunctor"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseOfIsoFunctor_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseOfIsoFunctor_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoFunctorOfIsoInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoFunctorOfIsoInverse_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoFunctorOfIsoInverse_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoFunctorOfIsoInverse_isoInverseOfIsoFunctor"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_isoInverseOfIsoFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseOfIsoFunctor_isoFunctorOfIsoInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_isoFunctorOfIsoInverse</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Equivalence-of-categories">Equivalence of categories <a class="hover-link" href="#Equivalence-of-categories">#</a></h1><p>An equivalence of categories <code>C</code> and <code>D</code> is a pair of functors <code>F : C ⥤ D</code> and <code>G : D ⥤ C</code> such
that <code>η : 𝟭 C ≅ F ⋙ G</code> and <code>ε : G ⋙ F ≅ 𝟭 D</code>. In many situations, equivalences are a better
notion of &quot;sameness&quot; of categories than the stricter isomorphism of categories.</p><p>Recall that one way to express that two functors <code>F : C ⥤ D</code> and <code>G : D ⥤ C</code> are adjoint is using
two natural transformations <code>η : 𝟭 C ⟶ F ⋙ G</code> and <code>ε : G ⋙ F ⟶ 𝟭 D</code>, called the unit and the
counit, such that the compositions <code>F ⟶ FGF ⟶ F</code> and <code>G ⟶ GFG ⟶ G</code> are the identity. Unfortunately,
it is not the case that the natural isomorphisms <code>η</code> and <code>ε</code> in the definition of an equivalence
automatically give an adjunction. However, it is true that</p><ul>
<li>if one of the two compositions is the identity, then so is the other, and</li>
<li>given an equivalence of categories, it is always possible to refine <code>η</code> in such a way that the
identities are satisfied.</li>
</ul><p>For this reason, in mathlib we define an equivalence to be a &quot;half-adjoint equivalence&quot;, which is
a tuple <code>(F, G, η, ε)</code> as in the first paragraph such that the composite <code>F ⟶ FGF ⟶ F</code> is the
identity. By the remark above, this already implies that the tuple is an &quot;adjoint equivalence&quot;,
i.e., that the composite <code>G ⟶ GFG ⟶ G</code> is also the identity.</p><p>We also define essentially surjective functors and show that a functor is an equivalence if and only
if it is full, faithful and essentially surjective.</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../.././Init/Core.html#Equivalence">Equivalence</a></code>: bundled (half-)adjoint equivalences of categories</li>
<li><code>Functor.EssSurj</code>: type class on a functor <code>F</code> containing the data of the preimages
and the isomorphisms <code>F.obj (preimage d) ≅ d</code>.</li>
<li><code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">Functor.IsEquivalence</a></code>: type class on a functor <code>F</code> which is full, faithful and
essentially surjective.</li>
</ul><h2 class="markdown-heading" id="Main-results">Main results <a class="hover-link" href="#Main-results">#</a></h2><ul>
<li><code><a href="../.././Init/Core.html#Equivalence.mk">Equivalence.mk</a></code>: upgrade an equivalence to a (half-)adjoint equivalence</li>
<li><code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_iff_of_iso">isEquivalence_iff_of_iso</a></code>: when <code>F</code> and <code>G</code> are isomorphic functors,
<code>F</code> is an equivalence iff <code>G</code> is.</li>
<li><code>Functor.asEquivalenceFunctor</code>: construction of an equivalence of categories from
a functor <code>F</code> which satisfies the property <code>F.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></code> (i.e. <code>F</code> is full, faithful
and essentially surjective).</li>
</ul><h2 class="markdown-heading" id="Notations">Notations <a class="hover-link" href="#Notations">#</a></h2><p>We write <code>C ≌ D</code> (<code>\backcong</code>, not to be confused with <code>≅</code>/<code>\cong</code>) for a bundled equivalence.</p></div><div class="decl" id="CategoryTheory.Equivalence"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L65-L88">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max (max (max u₁ u₂) v₁) v₂)</div></div><p>We define an equivalence as a (half)-adjoint equivalence, a pair of functors with
a unit and counit which are natural isomorphisms and the triangle law <code>Fη ≫ εF = 1</code>, or in other
words the composite <code>F ⟶ FGF ⟶ F</code> is the identity.</p><p>In <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_inverse_comp">unit_inverse_comp</a></code>, we show that this is actually an adjoint equivalence, i.e., that the
composite <code>G ⟶ GFG ⟶ G</code> is also the identity.</p><p>The triangle equation is written as a family of equalities between morphisms, it is more
complicated if we write it as an equality of natural transformations, because then we would have
to insert natural transformations like <code>F ⟶ F1</code>.</p><ul class="structure_ext"><li id="CategoryTheory.Equivalence.mk'" class="structure_ext_ctor">mk' :: (</li><ul class="structure_ext_fields"><li id="CategoryTheory.Equivalence.functor" class="structure_field"><div class="structure_field_info">functor : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span></div><div class="structure_field_doc"><p>A functor in one direction</p></div></li><li id="CategoryTheory.Equivalence.inverse" class="structure_field"><div class="structure_field_info">inverse : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>A functor in the other direction</p></div></li><li id="CategoryTheory.Equivalence.unitIso" class="structure_field"><div class="structure_field_info">unitIso : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div><div class="structure_field_doc"><p>The composition <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ⋙ <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code> is isomorphic to the identity</p></div></li><li id="CategoryTheory.Equivalence.counitIso" class="structure_field"><div class="structure_field_info">counitIso : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span></div><div class="structure_field_doc"><p>The composition <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ⋙ <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code> is also isomorphic to the identity</p></div></li><li id="CategoryTheory.Equivalence.functor_unitIso_comp" class="structure_field"><div class="structure_field_info">functor_unitIso_comp<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
 : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span></div><div class="structure_field_doc"><p>The natural isomorphisms compose to the identity.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-CategoryTheory.Equivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L75-L75">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ext_iff"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝¹</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L75-L75">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ext"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝¹</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">functor</span> : <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inverse</span> : <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unitIso</span> : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">counitIso</span> : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="CategoryTheory.«term_≌_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L90-L91">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.«term_≌_»"><span class="name">CategoryTheory</span>.<span class="name">«term_≌_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>We infix the usual notation for an equivalence</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.«term_≌_»">CategoryTheory.«term_≌_»</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`CategoryTheory.«term_≌_»</span> <span class="fn">10</span> <span class="fn">11</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ≌ &quot;</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">10</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.«term_≌_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.unit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L97-L99">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div><p>The unit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.unit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.counit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L101-L103">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span></div></div><p>The counit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.counit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.unitInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L105-L107">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span></div></div><p>The inverse of the unit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.unitInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L109-L111">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span></div></div><p>The inverse of the counit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.counitInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_unit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L115-L118">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">functor</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inverse</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unit_iso</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">inverse</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">counit_iso</span> : <span class="fn"><span class="fn"><span class="fn">inverse</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> :
  <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>       <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> }</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_counit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L120-L123">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">functor</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inverse</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unit_iso</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">inverse</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">counit_iso</span> : <span class="fn"><span class="fn"><span class="fn">inverse</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> :
  <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>       <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> }</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_unitInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L125-L128">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">functor</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inverse</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unit_iso</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">inverse</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">counit_iso</span> : <span class="fn"><span class="fn"><span class="fn">inverse</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> :
  <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>       <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> }</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_counitInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L130-L133">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">functor</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inverse</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unit_iso</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">inverse</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">counit_iso</span> : <span class="fn"><span class="fn"><span class="fn">inverse</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> :
  <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>       <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> }</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.functor_unit_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L135-L138">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_unit_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.functor_unit_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L135-L135">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_unit_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_functor_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L140-L145">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_functor_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_functor_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L140-L140">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_functor_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_app_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L147-L152">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_app_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counit_app_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L154-L157">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit_app_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_inverse_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L159-L185">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_inverse_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span></span></div></div><p>The other triangle equality. The proof follows the following proof in Globular:
<a href="http://globular.science/1905.001">http://globular.science/1905.001</a></p></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_inverse_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L161-L161">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_inverse_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inverse_counitInv_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L187-L192">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse_counitInv_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inverse_counitInv_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L187-L187">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse_counitInv_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_app_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L194-L197">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_app_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unitInv_app_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L199-L203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv_app_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.fun_inv_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L205-L208">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">f</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.fun_inv_map_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L205-L205">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fun_inv_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">f</span>)</span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span> <span class="fn">h</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inv_fun_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L210-L213">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">f</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inv_fun_map_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L210-L210">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inv_fun_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">f</span>)</span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span> <span class="fn">h</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.adjointifyη"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L220-L231">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointifyη</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span></div></div><p>If <code>η : 𝟭 C ≅ F ⋙ G</code> is part of a (not necessarily half-adjoint) equivalence, we can upgrade it
to a refined natural isomorphism <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">adjointifyη</a> η : 𝟭 C ≅ F ⋙ G</code> which exhibits the properties
required for a half-adjoint equivalence. See <code><a href="../.././Init/Core.html#Equivalence.mk">Equivalence.mk</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.adjointifyη" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.adjointify_η_ε"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L233-L242">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointify_η_ε"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">adjointifyη</a> <span class="fn">η</span> <span class="fn">ε</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">ε</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.adjointify_η_ε_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L233-L233">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointify_η_ε_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">adjointifyη</a> <span class="fn">η</span> <span class="fn">ε</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">ε</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L246-L250">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></div></div><p>Every equivalence of categories consisting of functors <code>F</code> and <code>G</code> such that <code>F ⋙ G</code> and
<code>G ⋙ F</code> are naturally isomorphic to identity functors can be transformed into a half-adjoint
equivalence without changing <code>F</code> or <code>G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk">CategoryTheory.Equivalence.mk</a> <span class="fn">F</span> <span class="fn">G</span> <span class="fn">η</span> <span class="fn">ε</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">functor</span> := <span class="fn">F</span>, <span class="fn">inverse</span> := <span class="fn">G</span>, <span class="fn">unitIso</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">CategoryTheory.Equivalence.adjointifyη</a> <span class="fn">η</span> <span class="fn">ε</span></span>, <span class="fn">counitIso</span> := <span class="fn">ε</span>,
    <span class="fn">functor_unitIso_comp</span> := <span class="fn">⋯</span> }</span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.refl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L252-L255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></div></div><p>Equivalence of categories is reflexive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.refl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L253-L253">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">refl</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L253-L253">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">refl</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L253-L253">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">refl</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L253-L253">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">refl</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.instInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L257-L258">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instInhabited"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instInhabited">CategoryTheory.Equivalence.instInhabited</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">CategoryTheory.Equivalence.refl</a> }</span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.symm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L260-L263">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></div></div><p>Equivalence of categories is symmetric.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">functor</span> := <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>, <span class="fn">inverse</span> := <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>, <span class="fn">unitIso</span> := <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span>, <span class="fn">counitIso</span> := <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span>,
    <span class="fn">functor_unitIso_comp</span> := <span class="fn">⋯</span> }</span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.symm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L261-L261">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L261-L261">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L261-L261">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L261-L261">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L267-L284">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></div></div><p>Equivalence of categories is transitive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.trans" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L268-L268">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans">trans</a></span> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L268-L268">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans">trans</a></span> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">isoWhiskerRight</a>
        (<span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">isoWhiskerLeft</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>)
        <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>       <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L268-L268">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans">trans</a></span> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L268-L268">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans">trans</a></span> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">isoWhiskerRight</a>
        (<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>           <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">isoWhiskerLeft</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span>)
        <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>       <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.funInvIdAssoc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L286-L289">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></div></div><p>Composing a functor with both functors of an equivalence yields a naturally isomorphic
functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">funInvIdAssoc</a></span> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.funInvIdAssoc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.funInvIdAssoc_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L291-L295">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">funInvIdAssoc</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.funInvIdAssoc_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L297-L301">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">funInvIdAssoc</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.invFunIdAssoc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L303-L306">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></div></div><p>Composing a functor with both functors of an equivalence yields a naturally isomorphic
functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">invFunIdAssoc</a></span> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.invFunIdAssoc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.invFunIdAssoc_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L308-L312">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">invFunIdAssoc</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.invFunIdAssoc_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L314-L318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">invFunIdAssoc</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L320-L331">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span></div></div><p>If <code>C</code> is equivalent to <code>D</code>, then <code>C ⥤ E</code> is equivalent to <code>D ⥤ E</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.congrLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L321-L321">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">congrLeft</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringLeft">whiskeringLeft</a> <span class="fn">C</span> <span class="fn">D</span> <span class="fn">E</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L321-L321">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">congrLeft</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">funInvIdAssoc</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L321-L321">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">congrLeft</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringLeft">whiskeringLeft</a> <span class="fn">D</span> <span class="fn">C</span> <span class="fn">E</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L321-L321">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">congrLeft</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">invFunIdAssoc</a></span> <span class="fn">F</span></span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L333-L341">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">D</span></span></div></div><p>If <code>C</code> is equivalent to <code>D</code>, then <code>E ⥤ C</code> is equivalent to <code>E ⥤ D</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.congrRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L334-L334">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">congrRight</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">C</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">isoWhiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L334-L334">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">congrRight</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringRight">whiskeringRight</a> <span class="fn">E</span> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L334-L334">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">congrRight</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringRight">whiskeringRight</a> <span class="fn">E</span> <span class="fn">D</span> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L334-L334">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">congrRight</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">D</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">isoWhiskerLeft</a> <span class="fn">F</span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unit_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L352-L354">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unitInv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L356-L358">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unitInv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counit_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L360-L362">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counit_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counitInv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L364-L366">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unit_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L368-L371">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unit_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W </span><span class="fn">X </span><span class="fn">X' </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">g'</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counitInv_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L373-L376">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counitInv_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W </span><span class="fn">X </span><span class="fn">X' </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">g'</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unit_right_assoc'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L378-L382">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unit_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W </span><span class="fn">X </span><span class="fn">X' </span><span class="fn">Y </span><span class="fn">Y' </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn">Y'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Z</span>)</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Z</span>)</span>)</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">h'</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counitInv_right_assoc'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L384-L388">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counitInv_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W </span><span class="fn">X </span><span class="fn">X' </span><span class="fn">Y </span><span class="fn">Y' </span><span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn">Y'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Z</span>)</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Z</span>)</span>)</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">h'</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.powNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L397-L401">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">powNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Nat">ℕ</a> → (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></div></div><p>Natural number powers of an auto-equivalence.  Use <code>(^)</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> <span class="fn">0</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">CategoryTheory.Equivalence.refl</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> <span class="fn">1</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> <span class="fn"><span class="fn"><span class="fn">n</span>.<a href="../.././Init/Prelude.html#Nat.succ">succ</a></span>.<a href="../.././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans">trans</a></span> <span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> (<span class="fn">n</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>))</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.powNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.pow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L403-L406">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a> → (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></div></div><p>Powers of an auto-equivalence.  Use <code>(^)</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow">pow</a></span> <span class="fn">(<a href="../.././Init/Data/Int/Basic.html#Int.ofNat">Int.ofNat</a> <span class="fn">n</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> <span class="fn">n</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow">pow</a></span> <span class="fn">(<a href="../.././Init/Data/Int/Basic.html#Int.negSucc">Int.negSucc</a> <span class="fn">n</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> (<span class="fn">n</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.pow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.instPowInt"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L408-L409">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instPowInt"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instPowInt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Pow">Pow</a> (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>) <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instPowInt">CategoryTheory.Equivalence.instPowInt</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pow</span> := <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow">CategoryTheory.Equivalence.pow</a> }</span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.pow_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L411-L413">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow_zero"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">0</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">refl</a></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.pow_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L415-L417">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.pow_neg_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L419-L421">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow_neg_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_neg_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">(-<span class="fn">1</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.essSurj_functor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L428-L431">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.essSurj_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurj_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div><p>The functor of an equivalence of categories is essentially surjective.</p><p><a href="https://stacks.math.columbia.edu/tag/02C3">Stacks Tag 02C3</a></p></div></div><div class="decl" id="CategoryTheory.Equivalence.essSurj_inverse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L433-L434">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.essSurj_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurj_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.fullyFaithfulFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L436-L438">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fullyFaithfulFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span></div></div><p>The functor of an equivalence of categories is fully faithful.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.fullyFaithfulFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.fullyFaithfulInverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L440-L442">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fullyFaithfulInverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span></div></div><p>The inverse of an equivalence of categories is fully faithful.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.fullyFaithfulInverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.faithful_functor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L444-L447">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.faithful_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">faithful_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div><p>The functor of an equivalence of categories is faithful.</p><p><a href="https://stacks.math.columbia.edu/tag/02C3">Stacks Tag 02C3</a></p></div></div><div class="decl" id="CategoryTheory.Equivalence.faithful_inverse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L449-L450">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.faithful_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">faithful_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.full_functor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L452-L455">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.full_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">full_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></div><p>The functor of an equivalence of categories is full.</p><p><a href="https://stacks.math.columbia.edu/tag/02C3">Stacks Tag 02C3</a></p></div></div><div class="decl" id="CategoryTheory.Equivalence.full_inverse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L457-L458">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.full_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">full_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L460-L467">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></div></div><p>If <code>e : C ≌ D</code> is an equivalence of categories, and <code>iso : e.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ G</code> is
an isomorphism, then there is an equivalence of categories whose functor is <code>G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.changeFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L462-L462">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_counitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L462-L462">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_counitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_counitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L462-L462">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_counitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_unitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L462-L462">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_unitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_unitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L462-L462">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_unitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L462-L462">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">G</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L469-L470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_refl"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></div></div><p>Compatibility of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></code> with identity isomorphisms of functors</p></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L472-L474">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_trans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso₁</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iso₂</span> : <span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso₁</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> (<span class="fn">iso₁</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn">iso₂</span>)</span></div></div><p>Compatibility of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></code> with the composition of isomorphisms of functors</p></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L476-L486">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></div></div><p>If <code>e : C ≌ D</code> is an equivalence of categories, and <code>iso : e.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ G</code> is
an isomorphism, then there is an equivalence of categories whose inverse is <code>G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.changeInverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_counitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L478-L478">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_counitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_unitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L478-L478">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_unitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_counitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L478-L478">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_counitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_unitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L478-L478">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_unitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L478-L478">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L478-L478">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">G</span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.IsEquivalence"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L490-L495">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>A functor is an equivalence of categories if it is faithful, full and
essentially surjective.</p><ul class="structure_fields" id="CategoryTheory.Functor.IsEquivalence.mk"><li id="CategoryTheory.Functor.IsEquivalence.faithful" class="structure_field"><div class="structure_field_info">faithful : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></li><li id="CategoryTheory.Functor.IsEquivalence.full" class="structure_field"><div class="structure_field_info">full : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></li><li id="CategoryTheory.Functor.IsEquivalence.essSurj" class="structure_field"><div class="structure_field_info">essSurj : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Functor.IsEquivalence" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.isEquivalence_functor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L497-L497">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.isEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.isEquivalence_inverse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L499-L500">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.isEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.IsEquivalence.mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L508-L512">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence.mk'"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsEquivalence</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div><p>To see that a functor is an equivalence, it suffices to provide an inverse functor <code>G</code> such that
<code>F ⋙ G</code> and <code>G ⋙ F</code> are naturally isomorphic to identity functors.</p></div></div><div class="decl" id="CategoryTheory.Functor.inv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L516-L522">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span></div></div><p>A quasi-inverse <code>D ⥤ C</code> to a functor that <code>F : C ⥤ D</code> that is an equivalence,
i.e. faithful, full, and essentially surjective.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.inv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.asEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L524-L532">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></div></div><p>Interpret a functor that is an equivalence as an equivalence.</p><p><a href="https://stacks.math.columbia.edu/tag/02C3">Stacks Tag 02C3</a></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.asEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.asEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L525-L525">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">asEquivalence</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">F</span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_refl"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L534-L535">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_refl"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_inv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L537-L538">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_trans"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L542-L543">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_trans"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instIsEquivalenceObjWhiskeringLeft"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L545-L546">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.instIsEquivalenceObjWhiskeringLeft"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceObjWhiskeringLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringLeft">whiskeringLeft</a> <span class="fn">C</span> <span class="fn">D</span> <span class="fn">E</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instIsEquivalenceObjWhiskeringRight"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L548-L549">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.instIsEquivalenceObjWhiskeringRight"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceObjWhiskeringRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.whiskeringRight">whiskeringRight</a> <span class="fn">E</span> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.fun_inv_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L556-L560">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">fun_inv_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">f</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">asEquivalence</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">asEquivalence</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.inv_fun_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L562-L566">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv_fun_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">f</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">asEquivalence</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">asEquivalence</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_of_iso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L568-L569">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_iff_of_iso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L571-L573">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_iff_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_iff_of_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_of_comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L575-L579">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_of_comp_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div><p>If <code>G</code> and <code>F ⋙ G</code> are equivalence of categories, then <code>F</code> is also an equivalence.</p></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_of_comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L581-L586">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_of_comp_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div><p>If <code>F</code> and <code>F ⋙ G</code> are equivalence of categories, then <code>G</code> is also an equivalence.</p></div></div><div class="decl" id="CategoryTheory.Equivalence.essSurjInducedFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L592-L593">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.essSurjInducedFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurjInducedFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C'</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C'</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.inducedFunctor">inducedFunctor</a> <span class="fn">⇑<span class="fn">e</span></span>)</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inducedFunctorOfEquiv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L595-L596">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inducedFunctorOfEquiv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inducedFunctorOfEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C'</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C'</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.inducedFunctor">inducedFunctor</a> <span class="fn">⇑<span class="fn">e</span></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.fullyFaithfulToEssImage"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L598-L599">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fullyFaithfulToEssImage"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulToEssImage</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.toEssImage">toEssImage</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.ofFullSubcategory"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L601-L609">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z </span><span class="fn">Z'</span> : <span class="fn"><span class="fn">C</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>), <span class="fn"><span class="fn">Z</span> <span class="fn">X</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">Z'</span> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">FullSubcategory</a> <span class="fn">Z</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">FullSubcategory</a> <span class="fn">Z'</span></span></div></div><p>A biimplication of properties on the objects of a category <code>C</code> induces an equivalence of the
respective induced full subcategories of <code>C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.ofFullSubcategory" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.ofFullSubcategory_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L603-L603">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z </span><span class="fn">Z'</span> : <span class="fn"><span class="fn">C</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>), <span class="fn"><span class="fn">Z</span> <span class="fn">X</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">Z'</span> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory">ofFullSubcategory</a> <span class="fn">h</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">FullSubcategory</a> <span class="fn">Z'</span></span>) =&gt; <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory.map">FullSubcategory.map</a> <span class="fn">⋯</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory.map">FullSubcategory.map</a> <span class="fn">⋯</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.ofFullSubcategory_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L603-L603">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z </span><span class="fn">Z'</span> : <span class="fn"><span class="fn">C</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>), <span class="fn"><span class="fn">Z</span> <span class="fn">X</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">Z'</span> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory">ofFullSubcategory</a> <span class="fn">h</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory.map">FullSubcategory.map</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.ofFullSubcategory_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L603-L603">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z </span><span class="fn">Z'</span> : <span class="fn"><span class="fn">C</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>), <span class="fn"><span class="fn">Z</span> <span class="fn">X</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">Z'</span> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory">ofFullSubcategory</a> <span class="fn">h</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">FullSubcategory</a> <span class="fn">Z</span></span>) =&gt; <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">FullSubcategory</a> <span class="fn">Z</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.ofFullSubcategory_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L603-L603">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z </span><span class="fn">Z'</span> : <span class="fn"><span class="fn">C</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>), <span class="fn"><span class="fn">Z</span> <span class="fn">X</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">Z'</span> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory">ofFullSubcategory</a> <span class="fn">h</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory.map">FullSubcategory.map</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.compInverseIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L617-L621">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></div></div><p>Construct an isomorphism <code>F ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ≅ G</code> from an isomorphism <code>F ≅ G ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso">compInverseIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a> <span class="fn">i</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn">G</span> <span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.compInverseIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.compInverseIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L618-L618">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso">compInverseIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.compInverseIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L618-L618">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso">compInverseIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L623-L627">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div><p>Construct an isomorphism <code>G ≅ F ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code> from an isomorphism <code>G ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">isoCompInverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn">G</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>       <span class="fn"><span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a> <span class="fn">i</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoCompInverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInverse_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L624-L624">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">isoCompInverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInverse_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L624-L624">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">isoCompInverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.inverseCompIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L629-L633">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H</span></div></div><p>Construct an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ⋙ F ≅ H</code> from an isomorphism <code>F ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ⋙ H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso">inverseCompIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn">i</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.inverseCompIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.inverseCompIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L630-L630">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso">inverseCompIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.inverseCompIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L630-L630">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso">inverseCompIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L635-L639">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">H</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span></div></div><p>Construct an isomorphism <code>H ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ⋙ F</code> from an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ⋙ H ≅ F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp">isoInverseComp</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerRight">CategoryTheory.isoWhiskerRight</a> <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>       <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn">i</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoInverseComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseComp_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L636-L636">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp">isoInverseComp</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseComp_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L636-L636">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp">isoInverseComp</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseOfIsoFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L641-L645">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></div></div><p>As a special case, given two equivalences <code>G</code> and <code>G'</code> between the same categories,
construct an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code> from an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.isoWhiskerLeft">CategoryTheory.isoWhiskerLeft</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn">i</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>).<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">isoCompInverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoInverseOfIsoFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseOfIsoFunctor_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L643-L643">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseOfIsoFunctor_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L643-L643">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoFunctorOfIsoInverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L647-L651">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></div></div><p>As a special case, given two equivalences <code>G</code> and <code>G'</code> between the same categories,
construct an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code> from an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoFunctorOfIsoInverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoFunctorOfIsoInverse_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L649-L649">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoFunctorOfIsoInverse_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L649-L649">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoFunctorOfIsoInverse_isoInverseOfIsoFunctor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L653-L658">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse_isoInverseOfIsoFunctor"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_isoInverseOfIsoFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">i</span></div></div><p>Sanity check: <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a> (isoInverseOfIsoFunctor i)</code> is just <code>i</code>.</p></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseOfIsoFunctor_isoFunctorOfIsoInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Equivalence.lean#L660-L663">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor_isoFunctorOfIsoInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_isoFunctorOfIsoInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">i</span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>