<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Basic</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Basic";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Batteries/Logic.html">Batteries.Logic</a></li><li><a href="../.././Batteries/Tactic/Trans.html">Batteries.Tactic.Trans</a></li><li><a href="../.././Batteries/Util/LibraryNote.html">Batteries.Util.LibraryNote</a></li><li><a href="../.././Mathlib/Tactic/Basic.html">Mathlib.Tactic.Basic</a></li><li><a href="../.././Mathlib/Data/Int/Notation.html">Mathlib.Data.Int.Notation</a></li><li><a href="../.././Mathlib/Data/Nat/Notation.html">Mathlib.Data.Nat.Notation</a></li><li><a href="../.././Mathlib/Tactic/Attr/Register.html">Mathlib.Tactic.Attr.Register</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#hidden"><span class="name">hidden</span></a></div><div class="nav_link"><a class="break_within" href="#decidableEq_of_subsingleton"><span class="name">decidableEq_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonSubtype_mathlib"><span class="name">instSubsingletonSubtype_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#congr_heq"><span class="name">congr_heq</span></a></div><div class="nav_link"><a class="break_within" href="#congr_arg_heq"><span class="name">congr_arg_heq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_eq_cancel_left"><span class="name">eq_iff_eq_cancel_left</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_eq_cancel_right"><span class="name">eq_iff_eq_cancel_right</span></a></div><div class="nav_link"><a class="break_within" href="#ne_and_eq_iff_right"><span class="name">ne_and_eq_iff_right</span></a></div><div class="nav_link"><a class="break_within" href="#Fact"><span class="name">Fact</span></a></div><div class="nav_link"><a class="break_within" href="#Fact.elim"><span class="name">Fact</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#fact_iff"><span class="name">fact_iff</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableFact"><span class="name">instDecidableFact</span></a></div><div class="nav_link"><a class="break_within" href="#Function.swap₂"><span class="name">Function</span>.<span class="name">swap₂</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.imp"><span class="name">Iff</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_right_iff"><span class="name">imp_iff_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#and_or_imp"><span class="name">and_or_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.mt"><span class="name">Function</span>.<span class="name">mt</span></a></div><div class="nav_link"><a class="break_within" href="#dec_em"><span class="name">dec_em</span></a></div><div class="nav_link"><a class="break_within" href="#dec_em'"><span class="name">dec_em'</span></a></div><div class="nav_link"><a class="break_within" href="#em"><span class="name">em</span></a></div><div class="nav_link"><a class="break_within" href="#em'"><span class="name">em'</span></a></div><div class="nav_link"><a class="break_within" href="#or_not"><span class="name">or_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.eq_or_ne"><span class="name">Decidable</span>.<span class="name">eq_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.ne_or_eq"><span class="name">Decidable</span>.<span class="name">ne_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_or_ne"><span class="name">eq_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_or_eq"><span class="name">ne_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#by_contradiction"><span class="name">by_contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#by_cases"><span class="name">by_cases</span></a></div><div class="nav_link"><a class="break_within" href="#by_contra"><span class="name">by_contra</span></a></div><div class="nav_link"><a class="break_within" href="#of_not_not"><span class="name">of_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_ne_iff"><span class="name">not_ne_iff</span></a></div><div class="nav_link"><a class="break_within" href="#of_not_imp"><span class="name">of_not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Not.decidable_imp_symm"><span class="name">Not</span>.<span class="name">decidable_imp_symm</span></a></div><div class="nav_link"><a class="break_within" href="#Not.imp_symm"><span class="name">Not</span>.<span class="name">imp_symm</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_comm"><span class="name">not_imp_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_self"><span class="name">not_imp_self</span></a></div><div class="nav_link"><a class="break_within" href="#Imp.swap"><span class="name">Imp</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not"><span class="name">Iff</span>.<span class="name">not</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not_left"><span class="name">Iff</span>.<span class="name">not_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not_right"><span class="name">Iff</span>.<span class="name">not_right</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne"><span class="name">Iff</span>.<span class="name">ne</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne_left"><span class="name">Iff</span>.<span class="name">ne_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne_right"><span class="name">Iff</span>.<span class="name">ne_right</span></a></div><div class="nav_link"><a class="break_within" href="#Xor'"><span class="name">Xor'</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableXor'"><span class="name">instDecidableXor'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_true"><span class="name">xor_true</span></a></div><div class="nav_link"><a class="break_within" href="#xor_false"><span class="name">xor_false</span></a></div><div class="nav_link"><a class="break_within" href="#xor_comm"><span class="name">xor_comm</span></a></div><div class="nav_link"><a class="break_within" href="#instCommutativeXor'"><span class="name">instCommutativeXor'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_self"><span class="name">xor_self</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_left"><span class="name">xor_not_left</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_right"><span class="name">xor_not_right</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_not"><span class="name">xor_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#Xor'.or"><span class="name">Xor'</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.and"><span class="name">Iff</span>.<span class="name">and</span></a></div><div class="nav_link"><a class="break_within" href="#And.rotate"><span class="name">And</span>.<span class="name">rotate</span></a></div><div class="nav_link"><a class="break_within" href="#and_symm_right"><span class="name">and_symm_right</span></a></div><div class="nav_link"><a class="break_within" href="#and_symm_left"><span class="name">and_symm_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.or"><span class="name">Iff</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Or.rotate"><span class="name">Or</span>.<span class="name">rotate</span></a></div><div class="nav_link"><a class="break_within" href="#Or.elim3"><span class="name">Or</span>.<span class="name">elim3</span></a></div><div class="nav_link"><a class="break_within" href="#Or.imp3"><span class="name">Or</span>.<span class="name">imp3</span></a></div><div class="nav_link"><a class="break_within" href="#not_or_of_imp"><span class="name">not_or_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.or_not_of_imp"><span class="name">Decidable</span>.<span class="name">or_not_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#or_not_of_imp"><span class="name">or_not_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_not_or"><span class="name">imp_iff_not_or</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_or_not"><span class="name">imp_iff_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_not"><span class="name">not_imp_not</span></a></div><div class="nav_link"><a class="break_within" href="#imp_and_neg_imp_iff"><span class="name">imp_and_neg_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.mtr"><span class="name">Function</span>.<span class="name">mtr</span></a></div><div class="nav_link"><a class="break_within" href="#or_congr_left'"><span class="name">or_congr_left'</span></a></div><div class="nav_link"><a class="break_within" href="#or_congr_right'"><span class="name">or_congr_right'</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.iff"><span class="name">Iff</span>.<span class="name">iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_mpr_iff_true_intro"><span class="name">iff_mpr_iff_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#imp_or"><span class="name">imp_or</span></a></div><div class="nav_link"><a class="break_within" href="#imp_or'"><span class="name">imp_or'</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp"><span class="name">not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#peirce"><span class="name">peirce</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_not"><span class="name">not_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_comm"><span class="name">not_iff_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff"><span class="name">not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_not_comm"><span class="name">iff_not_comm</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_and_or_not_and_not"><span class="name">iff_iff_and_or_not_and_not</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_not_or_and_or_not"><span class="name">iff_iff_not_or_and_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_and_not_right"><span class="name">not_and_not_right</span></a></div><div class="nav_link"><a class="break_within" href="#not_and_or"><span class="name">not_and_or</span></a></div><div class="nav_link"><a class="break_within" href="#or_iff_not_and_not"><span class="name">or_iff_not_and_not</span></a></div><div class="nav_link"><a class="break_within" href="#and_iff_not_or_not"><span class="name">and_iff_not_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_xor"><span class="name">not_xor</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_not_iff"><span class="name">xor_iff_not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_iff_not"><span class="name">xor_iff_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_not_iff'"><span class="name">xor_iff_not_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_or_and_not_and"><span class="name">xor_iff_or_and_not_and</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_not_mem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_not_mem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem'</span></a></div><div class="nav_link"><a class="break_within" href="#mem_dite"><span class="name">mem_dite</span></a></div><div class="nav_link"><a class="break_within" href="#dite_mem"><span class="name">dite_mem</span></a></div><div class="nav_link"><a class="break_within" href="#mem_ite"><span class="name">mem_ite</span></a></div><div class="nav_link"><a class="break_within" href="#ite_mem"><span class="name">ite_mem</span></a></div><div class="nav_link"><a class="break_within" href="#forall_cond_comm"><span class="name">forall_cond_comm</span></a></div><div class="nav_link"><a class="break_within" href="#forall_mem_comm"><span class="name">forall_mem_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_eq_of_ne"><span class="name">ne_of_eq_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_ne_of_eq"><span class="name">ne_of_ne_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.trans_ne"><span class="name">Eq</span>.<span class="name">trans_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.trans_eq"><span class="name">Ne</span>.<span class="name">trans_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_equivalence"><span class="name">eq_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#congr_refl_left"><span class="name">congr_refl_left</span></a></div><div class="nav_link"><a class="break_within" href="#congr_refl_right"><span class="name">congr_refl_right</span></a></div><div class="nav_link"><a class="break_within" href="#congr_arg_refl"><span class="name">congr_arg_refl</span></a></div><div class="nav_link"><a class="break_within" href="#congr_fun_rfl"><span class="name">congr_fun_rfl</span></a></div><div class="nav_link"><a class="break_within" href="#congr_fun_congr_arg"><span class="name">congr_fun_congr_arg</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.rec_eq_cast"><span class="name">Eq</span>.<span class="name">rec_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#eqRec_heq'"><span class="name">eqRec_heq'</span></a></div><div class="nav_link"><a class="break_within" href="#rec_heq_of_heq"><span class="name">rec_heq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#rec_heq_iff_heq"><span class="name">rec_heq_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_rec_iff_heq"><span class="name">heq_rec_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#cast_heq_iff_heq"><span class="name">cast_heq_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_cast_iff_heq"><span class="name">heq_cast_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eq_cast"><span class="name">heq_of_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#eq_cast_iff_heq"><span class="name">eq_cast_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_imp"><span class="name">forall₂_imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall₃_imp"><span class="name">forall₃_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Exists₂.imp"><span class="name">Exists₂</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#Exists₃.imp"><span class="name">Exists₃</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall_swap"><span class="name">forall_swap</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_swap"><span class="name">forall₂_swap</span></a></div><div class="nav_link"><a class="break_within" href="#imp_forall_iff"><span class="name">imp_forall_iff</span></a></div><div class="nav_link"><a class="break_within" href="#imp_forall_iff_forall"><span class="name">imp_forall_iff_forall</span></a></div><div class="nav_link"><a class="break_within" href="#exists_swap"><span class="name">exists_swap</span></a></div><div class="nav_link"><a class="break_within" href="#exists_and_exists_comm"><span class="name">exists_and_exists_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall_not"><span class="name">not_forall_not</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_exists_not"><span class="name">forall_or_exists_not</span></a></div><div class="nav_link"><a class="break_within" href="#exists_or_forall_not"><span class="name">exists_or_forall_not</span></a></div><div class="nav_link"><a class="break_within" href="#forall_imp_iff_exists_imp"><span class="name">forall_imp_iff_exists_imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_iff"><span class="name">forall_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_iff'"><span class="name">forall_true_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_true_iff"><span class="name">forall₂_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall₃_true_iff"><span class="name">forall₃_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.and_forall_ne"><span class="name">Decidable</span>.<span class="name">and_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#and_forall_ne"><span class="name">and_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ne_or_ne"><span class="name">Ne</span>.<span class="name">ne_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply'"><span class="name">exists_apply_eq_apply'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply2"><span class="name">exists_apply_eq_apply2</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply2'"><span class="name">exists_apply_eq_apply2'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply3"><span class="name">exists_apply_eq_apply3</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply3'"><span class="name">exists_apply_eq_apply3'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq"><span class="name">exists_apply_eq</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_and_eq_and"><span class="name">exists_exists_and_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_eq_and"><span class="name">exists_exists_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_and_exists_and_eq_and"><span class="name">exists_exists_and_exists_and_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_exists_and_eq"><span class="name">exists_exists_exists_and_eq</span></a></div><div class="nav_link"><a class="break_within" href="#forall_apply_eq_imp_iff'"><span class="name">forall_apply_eq_imp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#forall_eq_apply_imp_iff'"><span class="name">forall_eq_apply_imp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#exists₂_comm"><span class="name">exists₂_comm</span></a></div><div class="nav_link"><a class="break_within" href="#And.exists"><span class="name">And</span>.<span class="name">exists</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_of_or_forall"><span class="name">forall_or_of_or_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.forall_or_left"><span class="name">Decidable</span>.<span class="name">forall_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_left"><span class="name">forall_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.forall_or_right"><span class="name">Decidable</span>.<span class="name">forall_or_right</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_right"><span class="name">forall_or_right</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.fst"><span class="name">Exists</span>.<span class="name">fst</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.snd"><span class="name">Exists</span>.<span class="name">snd</span></a></div><div class="nav_link"><a class="break_within" href="#Prop.exists_iff"><span class="name">Prop</span>.<span class="name">exists_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Prop.forall_iff"><span class="name">Prop</span>.<span class="name">forall_iff</span></a></div><div class="nav_link"><a class="break_within" href="#exists_iff_of_forall"><span class="name">exists_iff_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#exists_prop_of_false"><span class="name">exists_prop_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#forall_prop_congr"><span class="name">forall_prop_congr</span></a></div><div class="nav_link"><a class="break_within" href="#forall_prop_congr'"><span class="name">forall_prop_congr'</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_eq"><span class="name">imp_congr_eq</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_ctx_eq"><span class="name">imp_congr_ctx_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_true_intro"><span class="name">eq_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#eq_false_intro"><span class="name">eq_false_intro</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.eq"><span class="name">Iff</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#iff_eq_eq"><span class="name">iff_eq_eq</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_left"><span class="name">forall_true_left</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.dec"><span class="name">Classical</span>.<span class="name">dec</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decPred"><span class="name">Classical</span>.<span class="name">decPred</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decRel"><span class="name">Classical</span>.<span class="name">decRel</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decEq"><span class="name">Classical</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.existsCases"><span class="name">Classical</span>.<span class="name">existsCases</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.some_spec₂"><span class="name">Classical</span>.<span class="name">some_spec₂</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.byContradiction'"><span class="name">Classical</span>.<span class="name">byContradiction'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choice_of_byContradiction'"><span class="name">Classical</span>.<span class="name">choice_of_byContradiction'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choose_eq"><span class="name">Classical</span>.<span class="name">choose_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choose_eq'"><span class="name">Classical</span>.<span class="name">choose_eq'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.axiom_of_choice"><span class="name">Classical</span>.<span class="name">axiom_of_choice</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.by_cases"><span class="name">Classical</span>.<span class="name">by_cases</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.by_contradiction"><span class="name">Classical</span>.<span class="name">by_contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.prop_complete"><span class="name">Classical</span>.<span class="name">prop_complete</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.classicalRecOn"><span class="name">Exists</span>.<span class="name">classicalRecOn</span></a></div><div class="nav_link"><a class="break_within" href="#bex_def"><span class="name">bex_def</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.elim"><span class="name">BEx</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.intro"><span class="name">BEx</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#BAll.imp_right"><span class="name">BAll</span>.<span class="name">imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.imp_right"><span class="name">BEx</span>.<span class="name">imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#BAll.imp_left"><span class="name">BAll</span>.<span class="name">imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.imp_left"><span class="name">BEx</span>.<span class="name">imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_of_exists"><span class="name">exists_mem_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#exists_of_exists_mem"><span class="name">exists_of_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#not_exists_mem"><span class="name">not_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall₂_of_exists₂_not"><span class="name">not_forall₂_of_exists₂_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.not_forall₂"><span class="name">Decidable</span>.<span class="name">not_forall₂</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall₂"><span class="name">not_forall₂</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_and"><span class="name">forall₂_and</span></a></div><div class="nav_link"><a class="break_within" href="#forall_and_left"><span class="name">forall_and_left</span></a></div><div class="nav_link"><a class="break_within" href="#forall_and_right"><span class="name">forall_and_right</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_or"><span class="name">exists_mem_or</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_or_left"><span class="name">forall₂_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_or_left"><span class="name">exists_mem_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_iff"><span class="name">dite_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_iff"><span class="name">ite_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#eq_ite_iff"><span class="name">eq_ite_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_iff'"><span class="name">dite_eq_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_iff'"><span class="name">ite_eq_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#dite_ne_left_iff"><span class="name">dite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_ne_right_iff"><span class="name">dite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ne_left_iff"><span class="name">ite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ne_right_iff"><span class="name">ite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_eq_left_iff"><span class="name">Ne</span>.<span class="name">dite_eq_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_eq_right_iff"><span class="name">Ne</span>.<span class="name">dite_eq_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_eq_left_iff"><span class="name">Ne</span>.<span class="name">ite_eq_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_eq_right_iff"><span class="name">Ne</span>.<span class="name">ite_eq_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_ne_left_iff"><span class="name">Ne</span>.<span class="name">dite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_ne_right_iff"><span class="name">Ne</span>.<span class="name">dite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_ne_left_iff"><span class="name">Ne</span>.<span class="name">ite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_ne_right_iff"><span class="name">Ne</span>.<span class="name">ite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_or_eq"><span class="name">dite_eq_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_or_eq"><span class="name">ite_eq_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#apply_dite₂"><span class="name">apply_dite₂</span></a></div><div class="nav_link"><a class="break_within" href="#apply_ite₂"><span class="name">apply_ite₂</span></a></div><div class="nav_link"><a class="break_within" href="#dite_apply"><span class="name">dite_apply</span></a></div><div class="nav_link"><a class="break_within" href="#ite_apply"><span class="name">ite_apply</span></a></div><div class="nav_link"><a class="break_within" href="#ite_and"><span class="name">ite_and</span></a></div><div class="nav_link"><a class="break_within" href="#ite_or"><span class="name">ite_or</span></a></div><div class="nav_link"><a class="break_within" href="#dite_dite_comm"><span class="name">dite_dite_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ite_comm"><span class="name">ite_ite_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ite_prop_iff_or"><span class="name">ite_prop_iff_or</span></a></div><div class="nav_link"><a class="break_within" href="#dite_prop_iff_or"><span class="name">dite_prop_iff_or</span></a></div><div class="nav_link"><a class="break_within" href="#ite_prop_iff_and"><span class="name">ite_prop_iff_and</span></a></div><div class="nav_link"><a class="break_within" href="#dite_prop_iff_and"><span class="name">dite_prop_iff_and</span></a></div><div class="nav_link"><a class="break_within" href="#if_ctx_congr"><span class="name">if_ctx_congr</span></a></div><div class="nav_link"><a class="break_within" href="#if_congr"><span class="name">if_congr</span></a></div><div class="nav_link"><a class="break_within" href="#not_beq_of_ne"><span class="name">not_beq_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#beq_eq_decide"><span class="name">beq_eq_decide</span></a></div><div class="nav_link"><a class="break_within" href="#beq_eq_beq"><span class="name">beq_eq_beq</span></a></div><div class="nav_link"><a class="break_within" href="#beq_ext"><span class="name">beq_ext</span></a></div><div class="nav_link"><a class="break_within" href="#beq_ext_iff"><span class="name">beq_ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#lawful_beq_subsingleton"><span class="name">lawful_beq_subsingleton</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Basic-logic-properties">Basic logic properties <a class="hover-link" href="#Basic-logic-properties">#</a></h1><p>This file is one of the earliest imports in mathlib.</p><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>Theorems that require decidability hypotheses are in the namespace <code><a href="../.././Init/Prelude.html#Decidable">Decidable</a></code>.
Classical versions are in the namespace <code>Classical</code>.</p></div><div class="decl" id="hidden"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L34-L37">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#hidden"><span class="name">hidden</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>An identity function with its main argument implicit. This will be printed as <code><a href="../.././Mathlib/Logic/Basic.html#hidden">hidden</a></code> even
if it is applied to a large term, so it can be used for elision,
as done in the <code>elide</code> and <code>unelide</code> tactics.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Basic.html#hidden">hidden</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-hidden" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="decidableEq_of_subsingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L41-L42">source</a></div><div class="attributes">@[instance 10]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#decidableEq_of_subsingleton"><span class="name">decidableEq_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#decidableEq_of_subsingleton">decidableEq_of_subsingleton</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instSubsingletonSubtype_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L44-L45">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instSubsingletonSubtype_mathlib"><span class="name">instSubsingletonSubtype_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href="../.././Init/Prelude.html#Subtype">Subtype</a> <span class="fn">p</span>)</span></span></div></div></div></div><div class="decl" id="congr_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L47-L49">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_heq"><span class="name">congr_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="congr_arg_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L51-L53">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_arg_heq"><span class="name">congr_arg_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span> → <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a₁</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a₂</span>)</span></span></span></div></div></div></div><div class="decl" id="eq_iff_eq_cancel_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L55-L56">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_iff_eq_cancel_left"><span class="name">eq_iff_eq_cancel_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="eq_iff_eq_cancel_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L58-L59">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_iff_eq_cancel_right"><span class="name">eq_iff_eq_cancel_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ {<span class="fn">c</span> : <span class="fn">α</span>}, <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="ne_and_eq_iff_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L61-L62">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_and_eq_iff_right"><span class="name">ne_and_eq_iff_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="Fact"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L64-L84">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact"><span class="name">Fact</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>Wrapper for adding elementary propositions to the type class systems.
Warning: this can easily be abused. See the rest of this docstring for details.</p><p>Certain propositions should not be treated as a class globally,
but sometimes it is very convenient to be able to use the type class system
in specific circumstances.</p><p>For example, <code>ZMod p</code> is a field if and only if <code>p</code> is a prime number.
In order to be able to find this field instance automatically by type class search,
we have to turn <code>p.prime</code> into an instance implicit assumption.</p><p>On the other hand, making <code>Nat.prime</code> a class would require a major refactoring of the library,
and it is questionable whether making <code>Nat.prime</code> a class is desirable at all.
The compromise is to add the assumption <code>[Fact p.prime]</code> to <code>ZMod.field</code>.</p><p>In particular, this class is not intended for turning the type class system
into an automated theorem prover for first order logic.</p><ul class="structure_fields" id="Fact.mk"><li id="Fact.out" class="structure_field"><div class="structure_field_info">out : <span class="fn">p</span></div><div class="structure_field_doc"><p><code><a href="../.././Mathlib/Logic/Basic.html#Fact.out">Fact.out</a></code> contains the unwrapped witness for the fact represented by the instance of
<code><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> p</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Fact" class="instances-list"></ul></details></div></div><div class="decl" id="Fact.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L92-L92">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact.elim"><span class="name">Fact</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="fact_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L93-L93">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#fact_iff"><span class="name">fact_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="instDecidableFact"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L95-L96">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instDecidableFact"><span class="name">instDecidableFact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Basic.html#instDecidableFact">instDecidableFact</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/PropLemmas.html#decidable_of_iff">decidable_of_iff</a> <span class="fn">p</span> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Function.swap₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L98-L101">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.swap₂"><span class="name">Function</span>.<span class="name">swap₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₁</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₂</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₁</span> : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₂</span> : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">φ</span> : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Sort</a> u_6</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn">(<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>) → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn">(<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>) → <span class="fn"><span class="fn">φ</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">φ</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></div></div><p>Swaps two pairs of arguments to a function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Function.swap₂">Function.swap₂</a> <span class="fn">f</span> <span class="fn">i₂</span> <span class="fn">j₂</span> <span class="fn">i₁</span> <span class="fn">j₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></li></ul></details><details id="instances-for-list-Function.swap₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-propositional-connectives">Declarations about propositional connectives <a class="hover-link" href="#Declarations-about-propositional-connectives">#</a></h3></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-implies">Declarations about <code>implies</code> <a class="hover-link" href="#Declarations-about-implies">#</a></h3></div><div class="decl" id="Iff.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L115-L115">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.imp"><span class="name">Iff</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#imp_congr">imp_congr</a></code>.</p></div></div><div class="decl" id="imp_iff_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L118-L118">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_right_iff"><span class="name">imp_iff_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="and_or_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L121-L121">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_or_imp"><span class="name">and_or_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Function.mt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L123-L124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.mt"><span class="name">Function</span>.<span class="name">mt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></div></div><p>Provide modus tollens (<code><a href="../.././Init/Core.html#mt">mt</a></code>) as dot notation for implications.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-not">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.not">not</a></code> <a class="hover-link" href="#Declarations-about-not">#</a></h3></div><div class="decl" id="dec_em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L128-L128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dec_em"><span class="name">dec_em</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#Decidable.em">Decidable.em</a></code>.</p></div></div><div class="decl" id="dec_em'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L130-L130">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dec_em'"><span class="name">dec_em'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L132-L132">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#em"><span class="name">em</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.em">Classical.em</a></code>.</p><hr></hr><p><strong>Diaconescu's theorem</strong>: excluded middle from choice, Function extensionality and propositional extensionality.</p></div></div><div class="decl" id="em'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L134-L134">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#em'"><span class="name">em'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L136-L136">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_not"><span class="name">or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></div></div></div></div><div class="decl" id="Decidable.eq_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L138-L139">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.eq_or_ne"><span class="name">Decidable</span>.<span class="name">eq_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="Decidable.ne_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L141-L142">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.ne_or_eq"><span class="name">Decidable</span>.<span class="name">ne_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="eq_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L144-L144">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_or_ne"><span class="name">eq_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="ne_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L146-L146">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_or_eq"><span class="name">ne_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="by_contradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L148-L148">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_contradiction"><span class="name">by_contradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <a href="../.././Init/Prelude.html#False">False</a>)</span> → <span class="fn">p</span></span></div></div></div></div><div class="decl" id="by_cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L150-L151">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_cases"><span class="name">by_cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hpq</span> : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hnpq</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div></div></div><div class="decl" id="by_contra"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L153-L153">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_contra"><span class="name">by_contra</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <a href="../.././Init/Prelude.html#False">False</a>)</span> → <span class="fn">p</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#by_contradiction">by_contradiction</a></code>.</p></div></div><div class="decl" id="of_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L180-L180">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#of_not_not"><span class="name">of_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_ne_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L182-L182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_ne_iff"><span class="name">not_ne_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="of_not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L184-L184">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#of_not_imp"><span class="name">of_not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Not.decidable_imp_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L186-L186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Not.decidable_imp_symm"><span class="name">Not</span>.<span class="name">decidable_imp_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#Decidable.not_imp_symm">Decidable.not_imp_symm</a></code>.</p></div></div><div class="decl" id="Not.imp_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L188-L188">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Not.imp_symm"><span class="name">Not</span>.<span class="name">imp_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="not_imp_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L190-L190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_comm"><span class="name">not_imp_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_imp_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L192-L192">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_self"><span class="name">not_imp_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Imp.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L194-L195">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Imp.swap"><span class="name">Imp</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Iff.not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L197-L197">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not"><span class="name">Iff</span>.<span class="name">not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#not_congr">not_congr</a></code>.</p></div></div><div class="decl" id="Iff.not_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L199-L199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not_left"><span class="name">Iff</span>.<span class="name">not_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Iff.not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L201-L201">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not_right"><span class="name">Iff</span>.<span class="name">not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="Iff.ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L203-L204">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne"><span class="name">Iff</span>.<span class="name">ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span>) → (<span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span>)</span></div></div></div></div><div class="decl" id="Iff.ne_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L206-L207">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne_left"><span class="name">Iff</span>.<span class="name">ne_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span>) → (<span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span>)</span></div></div></div></div><div class="decl" id="Iff.ne_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L209-L210">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne_right"><span class="name">Iff</span>.<span class="name">ne_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span>) → (<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span>)</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-Xor">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a></code> <a class="hover-link" href="#Declarations-about-Xor">#</a></h3></div><div class="decl" id="Xor'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L214-L215">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Xor'"><span class="name">Xor'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p><code><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> a b</code> is the exclusive-or of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</li></ul></details><details id="instances-for-list-Xor'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableXor'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L217-L217">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instDecidableXor'"><span class="name">instDecidableXor'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">b</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Basic.html#instDecidableXor'">instDecidableXor'</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href="../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>))</span></span></li></ul></details></div></div><div class="decl" id="xor_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L219-L220">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_true"><span class="name">xor_true</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Not">Not</a></div></div></div></div><div class="decl" id="xor_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L222-L222">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_false"><span class="name">xor_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#id">id</a></div></div></div></div><div class="decl" id="xor_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L224-L224">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_comm"><span class="name">xor_comm</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="instCommutativeXor'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L226-L226">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instCommutativeXor'"><span class="name">instCommutativeXor'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Std.Commutative">Std.Commutative</a> <a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a></span></div></div></div></div><div class="decl" id="xor_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L228-L228">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_self"><span class="name">xor_self</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="xor_not_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L230-L230">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_left"><span class="name">xor_not_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>) <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="xor_not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L232-L232">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_right"><span class="name">xor_not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="xor_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L234-L234">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_not"><span class="name">xor_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>) <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Xor'.or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L236-L236">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Xor'.or"><span class="name">Xor'</span>.<span class="name">or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-and">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.and">and</a></code> <a class="hover-link" href="#Declarations-about-and">#</a></h3></div><div class="decl" id="Iff.and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L240-L240">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.and"><span class="name">Iff</span>.<span class="name">and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">c </span><span class="fn">b </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">d</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#and_congr">and_congr</a></code>.</p></div></div><div class="decl" id="And.rotate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L241-L241">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#And.rotate"><span class="name">And</span>.<span class="name">rotate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../.././Init/PropLemmas.html#and_rotate">and_rotate</a></code>.</p></div></div><div class="decl" id="and_symm_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L243-L243">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_symm_right"><span class="name">and_symm_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="and_symm_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L244-L244">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_symm_left"><span class="name">and_symm_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">p</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-or">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Xor'.or">or</a></code> <a class="hover-link" href="#Declarations-about-or">#</a></h3></div><div class="decl" id="Iff.or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L248-L248">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.or"><span class="name">Iff</span>.<span class="name">or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">c </span><span class="fn">b </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">d</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#or_congr">or_congr</a></code>.</p></div></div><div class="decl" id="Or.rotate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L249-L249">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.rotate"><span class="name">Or</span>.<span class="name">rotate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../.././Init/PropLemmas.html#or_rotate">or_rotate</a></code>.</p></div></div><div class="decl" id="Or.elim3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L251-L252">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.elim3"><span class="name">Or</span>.<span class="name">elim3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><span class="fn">a</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><span class="fn">b</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">d</span></div></div></div></div><div class="decl" id="Or.imp3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L254-L256">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.imp3"><span class="name">Or</span>.<span class="name">imp3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">d </span><span class="fn">e </span><span class="fn">c </span><span class="fn">f</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">had</span> : <span class="fn"><span class="fn">a</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hbe</span> : <span class="fn"><span class="fn">b</span> → <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hcf</span> : <span class="fn"><span class="fn">c</span> → <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> → <span class="fn">d</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">e</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="not_or_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L260-L260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_or_of_imp"><span class="name">not_or_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Decidable.or_not_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L263-L264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.or_not_of_imp"><span class="name">Decidable</span>.<span class="name">or_not_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></div></div></div></div><div class="decl" id="or_not_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L266-L266">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_not_of_imp"><span class="name">or_not_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></div></div></div></div><div class="decl" id="imp_iff_not_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L268-L268">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_not_or"><span class="name">imp_iff_not_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="imp_iff_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L270-L270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_or_not"><span class="name">imp_iff_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="not_imp_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L272-L272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_not"><span class="name">not_imp_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="imp_and_neg_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L274-L274">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_and_neg_imp_iff"><span class="name">imp_and_neg_imp_iff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p </span><span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">p</span> → <span class="fn">q</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">q</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="Function.mtr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L276-L277">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.mtr"><span class="name">Function</span>.<span class="name">mtr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></span></div></div><p>Provide the reverse of modus tollens (<code><a href="../.././Init/Core.html#mt">mt</a></code>) as dot notation for implications.</p></div></div><div class="decl" id="or_congr_left'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L279-L280">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_congr_left'"><span class="name">or_congr_left'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">c</span> → (<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="or_congr_right'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L282-L282">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_congr_right'"><span class="name">or_congr_right'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → (<span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-distributivity">Declarations about distributivity <a class="hover-link" href="#Declarations-about-distributivity">#</a></h3></div><div class="mod_doc"><p>Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.iff">iff</a></code></p></div><div class="decl" id="Iff.iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L288-L288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.iff"><span class="name">Iff</span>.<span class="name">iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p₁ </span><span class="fn">p₂ </span><span class="fn">q₁ </span><span class="fn">q₂</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">p₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">q₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">p₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₁</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">p₂</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₂</span>)</div></div><p><strong>Alias</strong> of <code><a href="../.././Init/SimpLemmas.html#iff_congr">iff_congr</a></code>.</p></div></div><div class="decl" id="iff_mpr_iff_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L291-L291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_mpr_iff_true_intro"><span class="name">iff_mpr_iff_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="imp_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L293-L293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_or"><span class="name">imp_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span></div></div></div></div><div class="decl" id="imp_or'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L295-L295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_or'"><span class="name">imp_or'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span></div></div></div></div><div class="decl" id="not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L297-L297">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp"><span class="name">not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="peirce"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L299-L299">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#peirce"><span class="name">peirce</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn">a</span>)</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L301-L301">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff_not"><span class="name">not_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="not_iff_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L303-L303">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff_comm"><span class="name">not_iff_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</div></div></div></div><div class="decl" id="not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L305-L305">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff"><span class="name">not_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="iff_not_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L307-L307">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_not_comm"><span class="name">iff_not_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</div></div></div></div><div class="decl" id="iff_iff_and_or_not_and_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L309-L310">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_iff_and_or_not_and_not"><span class="name">iff_iff_and_or_not_and_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="iff_iff_not_or_and_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L312-L313">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_iff_not_or_and_or_not"><span class="name">iff_iff_not_or_and_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#And">∧</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</div></div></div></div><div class="decl" id="not_and_not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L315-L315">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_and_not_right"><span class="name">not_and_not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="De-Morgan-s-laws">De Morgan's laws <a class="hover-link" href="#De-Morgan-s-laws">#</a></h3></div><div class="decl" id="not_and_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L319-L321">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_and_or"><span class="name">not_and_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div><p>One of <strong>de Morgan's laws</strong>: the negation of a conjunction is logically equivalent to the
disjunction of the negations.</p></div></div><div class="decl" id="or_iff_not_and_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L323-L323">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_iff_not_and_not"><span class="name">or_iff_not_and_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a>(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</div></div></div></div><div class="decl" id="and_iff_not_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L325-L325">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_iff_not_or_not"><span class="name">and_iff_not_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a>(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</div></div></div></div><div class="decl" id="not_xor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L327-L328">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_xor"><span class="name">not_xor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">P</span> <span class="fn">Q</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</div></div></div></div><div class="decl" id="xor_iff_not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L330-L330">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_not_iff"><span class="name">xor_iff_not_iff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">P</span> <span class="fn">Q</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</div></div></div></div><div class="decl" id="xor_iff_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L332-L332">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_iff_not"><span class="name">xor_iff_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</div></div></div></div><div class="decl" id="xor_iff_not_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L334-L334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_not_iff'"><span class="name">xor_iff_not_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="xor_iff_or_and_not_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L336-L338">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_or_and_not_and"><span class="name">xor_iff_or_and_not_and</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span>)</div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Membership">Membership <a class="hover-link" href="#Membership">#</a></h3></div><div class="decl" id="Membership.mem.ne_of_not_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L344-L344">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_not_mem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#ne_of_mem_of_not_mem">ne_of_mem_of_not_mem</a></code>.</p></div></div><div class="decl" id="Membership.mem.ne_of_not_mem'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L345-L345">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_not_mem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span> → <span class="fn">s</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">t</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#ne_of_mem_of_not_mem'">ne_of_mem_of_not_mem'</a></code>.</p></div></div><div class="decl" id="mem_dite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L351-L353">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#mem_dite"><span class="name">mem_dite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><span class="fn">p</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">if h : <span class="fn">p</span> then <span class="fn"><span class="fn">s</span> <span class="fn">h</span></span> else <span class="fn"><span class="fn">t</span> <span class="fn">h</span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span>), <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">t</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="dite_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L355-L357">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_mem"><span class="name">dite_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn"><span class="fn">p</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(if h : <span class="fn">p</span> then <span class="fn"><span class="fn">a</span> <span class="fn">h</span></span> else <span class="fn"><span class="fn">b</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">a</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span>), <span class="fn"><span class="fn">b</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="mem_ite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L359-L360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#mem_ite"><span class="name">mem_ite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">p</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">s</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">t</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">p</span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span>)</span></div></div></div></div><div class="decl" id="ite_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L362-L363">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_mem"><span class="name">ite_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">p</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">p</span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-equality">Declarations about equality <a class="hover-link" href="#Declarations-about-equality">#</a></h3></div><div class="decl" id="forall_cond_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L372-L374">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_cond_comm"><span class="name">forall_cond_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_mem_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L376-L378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_mem_comm"><span class="name">forall_mem_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="ne_of_eq_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L381-L381">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_of_eq_of_ne"><span class="name">ne_of_eq_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="ne_of_ne_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L382-L382">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_of_ne_of_eq"><span class="name">ne_of_ne_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="Eq.trans_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L384-L384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Eq.trans_ne"><span class="name">Eq</span>.<span class="name">trans_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#ne_of_eq_of_ne">ne_of_eq_of_ne</a></code>.</p></div></div><div class="decl" id="Ne.trans_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L385-L385">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.trans_eq"><span class="name">Ne</span>.<span class="name">trans_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#ne_of_ne_of_eq">ne_of_ne_of_eq</a></code>.</p></div></div><div class="decl" id="eq_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L387-L388">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_equivalence"><span class="name">eq_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <a href="../.././Init/Prelude.html#Eq">Eq</a></span></div></div></div></div><div class="decl" id="congr_refl_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L394-L395">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_refl_left"><span class="name">congr_refl_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="congr_refl_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L398-L399">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_refl_right"><span class="name">congr_refl_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="congr_arg_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L402-L404">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_arg_refl"><span class="name">congr_arg_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="congr_fun_rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L407-L408">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_fun_rfl"><span class="name">congr_fun_rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="congr_fun_congr_arg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L411-L412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_fun_congr_arg"><span class="name">congr_fun_congr_arg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="Eq.rec_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L414-L415">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Eq.rec_eq_cast"><span class="name">Eq</span>.<span class="name">rec_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">z</span> : <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">h</span> <a href="../.././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">z</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">z</span></span></div></div></div></div><div class="decl" id="eqRec_heq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L417-L420">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eqRec_heq'"><span class="name">eqRec_heq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">a'</span> <span class="fn">⋯</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> (<span class="fn">t</span> <a href="../.././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">p</span>) <span class="fn">p</span></span></div></div></div></div><div class="decl" id="rec_heq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L422-L423">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#rec_heq_of_heq"><span class="name">rec_heq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> (<span class="fn">e</span> <a href="../.././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">x</span>) <span class="fn">y</span></span></div></div></div></div><div class="decl" id="rec_heq_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L425-L426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#rec_heq_iff_heq"><span class="name">rec_heq_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> (<span class="fn">e</span> <a href="../.././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">x</span>) <span class="fn">y</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="heq_rec_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L428-L429">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_rec_iff_heq"><span class="name">heq_rec_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> (<span class="fn">e</span> <a href="../.././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">y</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="cast_heq_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L431-L433">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#cast_heq_iff_heq"><span class="name">cast_heq_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">γ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">e</span> <span class="fn">a</span>)</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="heq_cast_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L435-L437">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_cast_iff_heq"><span class="name">heq_cast_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">β</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">γ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">(<a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">e</span> <span class="fn">b</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="heq_of_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L442-L442">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_of_eq_cast"><span class="name">heq_of_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">β</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">e</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="eq_cast_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L444-L444">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_cast_iff_heq"><span class="name">eq_cast_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">β</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">e</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-quantifiers">Declarations about quantifiers <a class="hover-link" href="#Declarations-about-quantifiers">#</a></h3></div><div class="decl" id="forall₂_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L454-L456">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_imp"><span class="name">forall₂_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> → <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="forall₃_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L458-L460">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₃_imp"><span class="name">forall₃_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span> → <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Exists₂.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L462-L464">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists₂.imp"><span class="name">Exists₂</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Exists₃.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L466-L468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists₃.imp"><span class="name">Exists₃</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="forall_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L474-L475">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_swap"><span class="name">forall_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">β</span>) (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="forall₂_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L477-L479">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_swap"><span class="name">forall₂_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₁</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₂</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₁</span> : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₂</span> : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_6</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>) (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>) (<span class="fn">i₂</span> : <span class="fn">ι₂</span>) (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>) (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>) (<span class="fn">i₁</span> : <span class="fn">ι₁</span>) (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></div></div></div></div><div class="decl" id="imp_forall_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L481-L484">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_forall_iff"><span class="name">imp_forall_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">p</span> → <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></div></div><p>We intentionally restrict the type of <code>α</code> in this lemma so that this is a safer to use in simp
than <code><a href="../.././Mathlib/Logic/Basic.html#forall_swap">forall_swap</a></code>.</p></div></div><div class="decl" id="imp_forall_iff_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L486-L487">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_forall_iff_forall"><span class="name">imp_forall_iff_forall</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">B</span> : <span class="fn"><span class="fn">A</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">A</span> → <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">A</span>), <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">A</span>), <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="exists_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L489-L490">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_swap"><span class="name">exists_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="exists_and_exists_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L492-L494">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_and_exists_comm"><span class="name">exists_and_exists_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Q</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">((<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>) <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">Q</span> <span class="fn">b</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Q</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="not_forall_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L498-L498">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall_not"><span class="name">not_forall_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="forall_or_exists_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L502-L503">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_exists_not"><span class="name">forall_or_exists_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="exists_or_forall_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L505-L506">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_or_forall_not"><span class="name">exists_or_forall_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>) <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="forall_imp_iff_exists_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L508-L512">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_imp_iff_exists_imp"><span class="name">forall_imp_iff_exists_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">ha</span> : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn">b</span></span></div></div></div></div><div class="decl" id="forall_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L514-L515">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_iff"><span class="name">forall_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="forall_true_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L519-L520">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_iff'"><span class="name">forall_true_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="forall₂_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L523-L523">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_true_iff"><span class="name">forall₂_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././Init/Prelude.html#True">True</a></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="forall₃_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L526-L527">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₃_true_iff"><span class="name">forall₃_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_4</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././Init/Prelude.html#True">True</a></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="Decidable.and_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L529-L531">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.and_forall_ne"><span class="name">Decidable</span>.<span class="name">and_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="and_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L533-L534">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_forall_ne"><span class="name">and_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Ne.ne_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L536-L537">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ne_or_ne"><span class="name">Ne</span>.<span class="name">ne_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">z</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">z</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">y</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">z</span></div></div></div></div><div class="decl" id="exists_apply_eq_apply'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L539-L540">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply'"><span class="name">exists_apply_eq_apply'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply2"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L542-L544">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply2"><span class="name">exists_apply_eq_apply2</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply2'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L546-L548">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply2'"><span class="name">exists_apply_eq_apply2'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L550-L553">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply3"><span class="name">exists_apply_eq_apply3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Sort</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">z</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">γ</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">z</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply3'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L555-L558">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply3'"><span class="name">exists_apply_eq_apply3'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Sort</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">z</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">γ</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">z</span></span></div></div></div></div><div class="decl" id="exists_apply_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L560-L566">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq"><span class="name">exists_apply_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">f</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div><p>The constant function witnesses that
there exists a function sending a given term to a given term.</p><p>This is sometimes useful in <code>simp</code> to discharge side conditions.</p></div></div><div class="decl" id="exists_exists_and_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L568-L570">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_and_eq_and"><span class="name">exists_exists_and_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">b</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="exists_exists_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L572-L574">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_eq_and"><span class="name">exists_exists_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="exists_exists_and_exists_and_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L576-L580">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_and_exists_and_eq_and"><span class="name">exists_exists_and_exists_and_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">γ</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>) <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">c</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="exists_exists_exists_and_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L582-L586">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_exists_and_eq"><span class="name">exists_exists_exists_and_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">γ</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>) <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">c</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="forall_apply_eq_imp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L588-L589">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_apply_eq_imp_iff'"><span class="name">forall_apply_eq_imp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></div></div></div></div><div class="decl" id="forall_eq_apply_imp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L591-L592">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_eq_apply_imp_iff'"><span class="name">forall_eq_apply_imp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></div></div></div></div><div class="decl" id="exists₂_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L594-L597">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists₂_comm"><span class="name">exists₂_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₁</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₂</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₁</span> : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₂</span> : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_6</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">i₁</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">ι₁</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">j₁</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">i₂</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">ι₂</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">j₂</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span>) <a href="../.././Init/Core.html#Iff">↔</a>   <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">i₂</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">ι₂</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">j₂</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">i₁</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">ι₁</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">j₁</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></div></div></div></div><div class="decl" id="And.exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L599-L600">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#And.exists"><span class="name">And</span>.<span class="name">exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">h</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">hp</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">p</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">hq</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">q</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="forall_or_of_or_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L602-L604">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_of_or_forall"><span class="name">forall_or_of_or_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="Decidable.forall_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L607-L610">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.forall_or_left"><span class="name">Decidable</span>.<span class="name">forall_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="forall_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L612-L613">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_left"><span class="name">forall_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Decidable.forall_or_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L616-L617">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.forall_or_right"><span class="name">Decidable</span>.<span class="name">forall_or_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="forall_or_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L619-L620">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_right"><span class="name">forall_or_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="Exists.fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L622-L623">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.fst"><span class="name">Exists</span>.<span class="name">fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">b</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span> → <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Exists.snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L625-L626">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.snd"><span class="name">Exists</span>.<span class="name">snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">b</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Prop.exists_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L628-L630">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Prop.exists_iff"><span class="name">Prop</span>.<span class="name">exists_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <a href="../.././foundational_types.html">Prop</a><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">h</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="Prop.forall_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L632-L633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Prop.forall_iff"><span class="name">Prop</span>.<span class="name">forall_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">h</span> : <a href="../.././foundational_types.html">Prop</a>), <span class="fn"><span class="fn">p</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="exists_iff_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L635-L636">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_iff_of_forall"><span class="name">exists_iff_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">p</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="exists_prop_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L638-L639">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_prop_of_false"><span class="name">exists_prop_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <a href="../.././Init/Prelude.html#Not">¬</a><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h'</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">p</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">h'</span></span></span></div></div></div></div><div class="decl" id="forall_prop_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L643-L645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_prop_congr"><span class="name">forall_prop_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">p'</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q </span><span class="fn">q'</span> : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hq</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="forall_prop_congr'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L647-L649">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_prop_congr'"><span class="name">forall_prop_congr'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">p'</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q </span><span class="fn">q'</span> : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hq</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="imp_congr_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L651-L652">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_congr_eq"><span class="name">imp_congr_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">c</span> → <span class="fn">d</span>)</span></div></div></div></div><div class="decl" id="imp_congr_ctx_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L654-L655">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_congr_ctx_eq"><span class="name">imp_congr_ctx_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">c</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">c</span> → <span class="fn">d</span>)</span></div></div></div></div><div class="decl" id="eq_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L657-L657">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_true_intro"><span class="name">eq_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="eq_false_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L659-L659">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_false_intro"><span class="name">eq_false_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="Iff.eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L662-L662">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.eq"><span class="name">Iff</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#propext">propext</a></code>.</p><hr></hr><p>The axiom of <strong>propositional extensionality</strong>. It asserts that if propositions
<code>a</code> and <code>b</code> are logically equivalent (i.e. we can prove <code>a</code> from <code>b</code> and vice versa),
then <code>a</code> and <code>b</code> are <em>equal</em>, meaning that we can replace <code>a</code> with <code>b</code> in all
contexts.</p><p>For simple expressions like <code>a ∧ c ∨ d → e</code> we can prove that because all the logical
connectives respect logical equivalence, we can replace <code>a</code> with <code>b</code> in this expression
without using <code><a href="../.././Init/Core.html#propext">propext</a></code>. However, for higher order expressions like <code>P a</code> where
<code>P : Prop → Prop</code> is unknown, or indeed for <code>a = b</code> itself, we cannot replace <code>a</code> with <code>b</code>
without an axiom which says exactly this.</p><p>This is a relatively uncontroversial axiom, which is intuitionistically valid.
It does however block computation when using <code>#reduce</code> to reduce proofs directly
(which is not recommended), meaning that canonicity,
the property that all closed terms of type <code><a href="../.././Init/Prelude.html#Nat">Nat</a></code> normalize to numerals,
fails to hold when this (or any) axiom is used:</p><pre><code>set_option pp.proofs true

def foo : <a href="../.././Init/Prelude.html#Nat">Nat</a> := by
  have : (True → True) ↔ <a href="../.././Init/Prelude.html#True">True</a> := ⟨λ _ =&gt; trivial, λ _ _ =&gt; trivial⟩
  have := <a href="../.././Init/Core.html#propext">propext</a> this ▸ (2 : Nat)
  exact this

#reduce foo
-- <a href="../.././Init/Core.html#propext">propext</a> { mp := fun x x =&gt; True.intro, mpr := fun x =&gt; <a href="../.././Init/Prelude.html#True.intro">True.intro</a> } ▸ 2

#eval foo -- 2
</code></pre><p><code>#eval</code> can evaluate it to a numeral because the compiler erases casts and
does not evaluate proofs, so <code><a href="../.././Init/Core.html#propext">propext</a></code>, whose return type is a proposition,
can never block it.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href="../.././Mathlib/Logic/Basic.html#Iff.eq">Iff.eq</a> <a href="../.././Init/Prelude.html#Eq">=</a> @<a href="../.././Init/Core.html#propext">propext</a></li></ul></details><details id="instances-for-list-Iff.eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="iff_eq_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L664-L664">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_eq_eq"><span class="name">iff_eq_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="forall_true_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L668-L670">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_left"><span class="name">forall_true_left</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../.././Init/Prelude.html#True">True</a> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#True">True</a>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True.intro">True.intro</a></span></div></div><p>See <code>IsEmpty.<a href="../.././Mathlib/Logic/Basic.html#Prop.forall_iff">forall_iff</a></code> for the <code><a href="../.././Init/Prelude.html#False">False</a></code> version.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Classical-lemmas">Classical lemmas <a class="hover-link" href="#Classical-lemmas">#</a></h3></div><div class="decl" id="Classical.dec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L679-L680">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.dec"><span class="name">Classical</span>.<span class="name">dec</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span></div></div><p>Any prop <code>p</code> is decidable classically. A shorthand for <code><a href="../.././Init/Classical.html#Classical.propDecidable">Classical.propDecidable</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.dec">Classical.dec</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#inferInstance">inferInstance</a></li></ul></details><details id="instances-for-list-Classical.dec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decPred"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L684-L685">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decPred"><span class="name">Classical</span>.<span class="name">decPred</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span></div></div><p>Any predicate <code>p</code> is decidable classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decPred">Classical.decPred</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#inferInstance">inferInstance</a></li></ul></details><details id="instances-for-list-Classical.decPred" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decRel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L687-L688">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decRel"><span class="name">Classical</span>.<span class="name">decRel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">p</span></span></div></div><p>Any relation <code>p</code> is decidable classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decRel">Classical.decRel</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#inferInstance">inferInstance</a></li></ul></details><details id="instances-for-list-Classical.decRel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L690-L691">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decEq"><span class="name">Classical</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><p>Any type <code>α</code> has decidable equality classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decEq">Classical.decEq</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#inferInstance">inferInstance</a></li></ul></details><details id="instances-for-list-Classical.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.existsCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L693-L696">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.existsCases"><span class="name">Classical</span>.<span class="name">existsCases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H0</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">C</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>Construct a function from a default value <code>H0</code>, and a function to use if there exists a value
satisfying the predicate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.existsCases">Classical.existsCases</a> <span class="fn">H0</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> then <span class="fn"><span class="fn">H</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span>)</span> <span class="fn">⋯</span></span> else <span class="fn">H0</span></span></li></ul></details><details id="instances-for-list-Classical.existsCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.some_spec₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L698-L699">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.some_spec₂"><span class="name">Classical</span>.<span class="name">some_spec₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hpq</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">q</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">choose</a> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Classical.byContradiction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L701-L703">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'"><span class="name">Classical</span>.<span class="name">byContradiction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">α</span> → <a href="../.././Init/Prelude.html#False">False</a>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A version of <code>byContradiction</code> that uses types instead of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'">Classical.byContradiction'</a> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Classical.choice">Classical.choice</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Classical.byContradiction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.choice_of_byContradiction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L705-L707">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choice_of_byContradiction'"><span class="name">Classical</span>.<span class="name">choice_of_byContradiction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contra</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">α</span> → <a href="../.././Init/Prelude.html#False">False</a>)</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span> → <span class="fn">α</span></span></div></div><p><code><a href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'">Classical.byContradiction'</a></code> is equivalent to lean's axiom <code><a href="../.././Init/Prelude.html#Classical.choice">Classical.choice</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.choice_of_byContradiction'">Classical.choice_of_byContradiction'</a> <span class="fn">contra</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">contra</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Classical.choice_of_byContradiction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.choose_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L709-L709">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choose_eq"><span class="name">Classical</span>.<span class="name">choose_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span>.<a href="../.././Init/Classical.html#Exists.choose">choose</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Classical.choose_eq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L711-L713">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choose_eq'"><span class="name">Classical</span>.<span class="name">choose_eq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span>.<a href="../.././Init/Classical.html#Exists.choose">choose</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Classical.axiom_of_choice"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L715-L715">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.axiom_of_choice"><span class="name">Classical</span>.<span class="name">axiom_of_choice</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">f</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.axiomOfChoice">Classical.axiomOfChoice</a></code>.</p><hr></hr><p>the axiom of choice</p></div></div><div class="decl" id="Classical.by_cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L716-L716">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.by_cases"><span class="name">Classical</span>.<span class="name">by_cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hpq</span> : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hnpq</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.byCases">Classical.byCases</a></code>.</p></div></div><div class="decl" id="Classical.by_contradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L717-L717">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.by_contradiction"><span class="name">Classical</span>.<span class="name">by_contradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.byContradiction">Classical.byContradiction</a></code>.</p></div></div><div class="decl" id="Classical.prop_complete"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L723-L723">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.prop_complete"><span class="name">Classical</span>.<span class="name">prop_complete</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#True">True</a> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.propComplete">Classical.propComplete</a></code>.</p></div></div><div class="decl" id="Exists.classicalRecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L727-L732">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.classicalRecOn"><span class="name">Exists</span>.<span class="name">classicalRecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">C</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>This function has the same type as <code><a href="../.././Init/Core.html#Exists.recOn">Exists.recOn</a></code>, and can be used to case on an equality,
but <code><a href="../.././Init/Core.html#Exists.recOn">Exists.recOn</a></code> can only eliminate into Prop, while this version eliminates into any universe
using the axiom of choice.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">h</span>.<a href="../.././Mathlib/Logic/Basic.html#Exists.classicalRecOn">classicalRecOn</a></span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">H</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span>)</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Exists.classicalRecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-bounded-quantifiers">Declarations about bounded quantifiers <a class="hover-link" href="#Declarations-about-bounded-quantifiers">#</a></h3></div><div class="decl" id="bex_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L739-L740">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_def"><span class="name">bex_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="BEx.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L742-L743">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.elim"><span class="name">BEx</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>) → <span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h</span></span> → <span class="fn">b</span></span>)</span> → <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="BEx.intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L745-L746">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.intro"><span class="name">BEx</span>.<span class="name">intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="BAll.imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L748-L749">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BAll.imp_right"><span class="name">BAll</span>.<span class="name">imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="BEx.imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L751-L752">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.imp_right"><span class="name">BEx</span>.<span class="name">imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="BAll.imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L754-L755">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BAll.imp_left"><span class="name">BAll</span>.<span class="name">imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="BEx.imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L757-L758">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.imp_left"><span class="name">BEx</span>.<span class="name">imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="exists_mem_of_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L760-L761">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_of_exists"><span class="name">exists_mem_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="exists_of_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L763-L764">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_of_exists_mem"><span class="name">exists_of_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="not_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L767-L767">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_exists_mem"><span class="name">not_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="not_forall₂_of_exists₂_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L769-L770">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall₂_of_exists₂_not"><span class="name">not_forall₂_of_exists₂_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>) → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="Decidable.not_forall₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L773-L776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.not_forall₂"><span class="name">Decidable</span>.<span class="name">not_forall₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>)</span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>) → <span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span>)</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="not_forall₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L778-L778">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall₂"><span class="name">not_forall₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="forall₂_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L780-L781">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_and"><span class="name">forall₂_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="forall_and_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L783-L784">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_and_left"><span class="name">forall_and_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">q</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="forall_and_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L786-L787">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_and_right"><span class="name">forall_and_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="exists_mem_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L789-L790">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_or"><span class="name">exists_mem_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>) <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="forall₂_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L792-L793">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_or_left"><span class="name">forall₂_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="exists_mem_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L795-L798">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_or_left"><span class="name">exists_mem_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span>) <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="dite_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L807-L808">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_iff"><span class="name">dite_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>) <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="ite_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L810-L811">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_iff"><span class="name">ite_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="eq_ite_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L813-L814">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_ite_iff"><span class="name">eq_ite_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">c</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="dite_eq_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L816-L818">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_iff'"><span class="name">dite_eq_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>), <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="ite_eq_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L820-L820">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_iff'"><span class="name">ite_eq_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">P</span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></div></div></div></div><div class="decl" id="dite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L822-L824">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_ne_left_iff"><span class="name">dite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="dite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L826-L827">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_ne_right_iff"><span class="name">dite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="ite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L829-L830">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ne_left_iff"><span class="name">ite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="ite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L832-L833">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ne_right_iff"><span class="name">ite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Ne.dite_eq_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L835-L836">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_eq_left_iff"><span class="name">Ne</span>.<span class="name">dite_eq_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>), <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.dite_eq_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L838-L839">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_eq_right_iff"><span class="name">Ne</span>.<span class="name">dite_eq_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.ite_eq_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L841-L842">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_eq_left_iff"><span class="name">Ne</span>.<span class="name">ite_eq_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.ite_eq_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L844-L845">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_eq_right_iff"><span class="name">Ne</span>.<span class="name">ite_eq_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.dite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L847-L848">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_ne_left_iff"><span class="name">Ne</span>.<span class="name">dite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>), <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.dite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L850-L851">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_ne_right_iff"><span class="name">Ne</span>.<span class="name">dite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.ite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L853-L854">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_ne_left_iff"><span class="name">Ne</span>.<span class="name">ite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.ite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L856-L857">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_ne_right_iff"><span class="name">Ne</span>.<span class="name">ite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></div></div></div></div><div class="decl" id="dite_eq_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L861-L862">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_or_eq"><span class="name">dite_eq_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span>) <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="ite_eq_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L864-L865">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_or_eq"><span class="name">ite_eq_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> (<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="apply_dite₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L867-L872">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#apply_dite₂"><span class="name">apply_dite₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">a</span> <span class="fn">b</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">c</span> <span class="fn">d</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">a</span> <span class="fn">h</span>)</span> <span class="fn">(<span class="fn">c</span> <span class="fn">h</span>)</span></span> else <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">b</span> <span class="fn">h</span>)</span> <span class="fn">(<span class="fn">d</span> <span class="fn">h</span>)</span></span></span></div></div><p>A two-argument function applied to two <code><a href="../.././Init/Prelude.html#dite">dite</a></code>s is a <code><a href="../.././Init/Prelude.html#dite">dite</a></code> of that two-argument function
applied to each of the branches.</p></div></div><div class="decl" id="apply_ite₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L874-L878">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#apply_ite₂"><span class="name">apply_ite₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c </span><span class="fn">d</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> (<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) (<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">d</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">d</span></span></div></div><p>A two-argument function applied to two <code><a href="../.././Init/Prelude.html#ite">ite</a></code>s is a <code><a href="../.././Init/Prelude.html#ite">ite</a></code> of that two-argument function
applied to each of the branches.</p></div></div><div class="decl" id="dite_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L880-L883">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_apply"><span class="name">dite_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">h</span> <span class="fn">a</span></span> else <span class="fn"><span class="fn">g</span> <span class="fn">h</span> <span class="fn">a</span></span></span></div></div><p>A 'dite' producing a <code>Pi</code> type <code>Π a, σ a</code>, applied to a value <code>a : α</code> is a <code><a href="../.././Init/Prelude.html#dite">dite</a></code> that applies
either branch to <code>a</code>.</p></div></div><div class="decl" id="ite_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L885-L888">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_apply"><span class="name">ite_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">g</span>) <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">g</span> <span class="fn">a</span></span></div></div><p>A 'ite' producing a <code>Pi</code> type <code>Π a, σ a</code>, applied to a value <code>a : α</code> is a <code><a href="../.././Init/Prelude.html#ite">ite</a></code> that applies
either branch to <code>a</code>.</p></div></div><div class="decl" id="ite_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L893-L894">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_and"><span class="name">ite_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="ite_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L896-L897">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_or"><span class="name">ite_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="dite_dite_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L899-L904">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_dite_comm"><span class="name">dite_dite_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><span class="fn">Q</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span> → <span class="fn">α</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">P</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(if p : <span class="fn">P</span> then <span class="fn"><span class="fn">A</span> <span class="fn">p</span></span> else <span class="fn">if q : <span class="fn">Q</span> then <span class="fn"><span class="fn">B</span> <span class="fn">q</span></span> else <span class="fn"><span class="fn">C</span> <span class="fn">p</span> <span class="fn">q</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if q : <span class="fn">Q</span> then <span class="fn"><span class="fn">B</span> <span class="fn">q</span></span> else <span class="fn">if p : <span class="fn">P</span> then <span class="fn"><span class="fn">A</span> <span class="fn">p</span></span> else <span class="fn"><span class="fn">C</span> <span class="fn">p</span> <span class="fn">q</span></span></span></span></div></div></div></div><div class="decl" id="ite_ite_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L906-L909">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ite_comm"><span class="name">ite_ite_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">P</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">c</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#ite">else</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="ite_prop_iff_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L915-L916">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_prop_iff_or"><span class="name">ite_prop_iff_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q </span><span class="fn">R</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">R</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">R</span></div></div></div></div><div class="decl" id="dite_prop_iff_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L918-L920">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_prop_iff_or"><span class="name">dite_prop_iff_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Q</span> : <span class="fn"><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">Q</span> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">p</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">Q</span> <span class="fn">p</span></span>) <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">p</span> <a href="../.././Init/Core.html#Exists">:</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">R</span> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="ite_prop_iff_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L923-L924">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_prop_iff_and"><span class="name">ite_prop_iff_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q </span><span class="fn">R</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">R</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">P</span> → <span class="fn">Q</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">R</span>)</span></div></div></div></div><div class="decl" id="dite_prop_iff_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L926-L928">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_prop_iff_and"><span class="name">dite_prop_iff_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Q</span> : <span class="fn"><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">Q</span> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">Q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>), <span class="fn"><span class="fn">R</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="if_ctx_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L934-L939">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#if_ctx_congr"><span class="name">if_ctx_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y </span><span class="fn">u </span><span class="fn">v</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h_c</span> : <span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_t</span> : <span class="fn"><span class="fn">Q</span> → <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">u</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_e</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span> → <span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">y</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">u</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="if_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L941-L942">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#if_congr"><span class="name">if_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y </span><span class="fn">u </span><span class="fn">v</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h_c</span> : <span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_t</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">u</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_e</span> : <span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">y</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">u</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="not_beq_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L948-L949">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_beq_of_ne"><span class="name">not_beq_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ne</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="beq_eq_decide"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L951-L953">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_eq_decide"><span class="name">beq_eq_decide</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></div></div></div></div><div class="decl" id="beq_eq_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L955-L956">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_eq_beq"><span class="name">beq_eq_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b₁ </span><span class="fn">b₂</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a₁</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a₂</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">b₁</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b₂</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span>)</div></div></div></div><div class="decl" id="beq_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L958-L966">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_ext"><span class="name">beq_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">inst1 </span><span class="fn">inst2</span> : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), (<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></div></div></div></div><div class="decl" id="beq_ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L958-L958">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_ext_iff"><span class="name">beq_ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst1 </span><span class="fn">inst2</span> : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), (<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>)</span></div></div></div></div><div class="decl" id="lawful_beq_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Logic/Basic.lean#L968-L973">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#lawful_beq_subsingleton"><span class="name">lawful_beq_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">inst1 </span><span class="fn">inst2</span> : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>