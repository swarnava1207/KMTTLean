<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Data.QPF.Univariate.Basic</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Mathlib.Data.QPF.Univariate.Basic";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Data</span>.<span class="name">QPF</span>.<span class="name">Univariate</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Init.html">Init</a></li><li><a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html">Mathlib.Data.PFunctor.Univariate.M</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Data.QPF.Univariate.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#QPF"><span class="name">QPF</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.id_map"><span class="name">QPF</span>.<span class="name">id_map</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.comp_map"><span class="name">QPF</span>.<span class="name">comp_map</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.lawfulFunctor"><span class="name">QPF</span>.<span class="name">lawfulFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.liftp_iff"><span class="name">QPF</span>.<span class="name">liftp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.liftp_iff'"><span class="name">QPF</span>.<span class="name">liftp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.liftr_iff"><span class="name">QPF</span>.<span class="name">liftr_iff</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.recF"><span class="name">QPF</span>.<span class="name">recF</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.recF_eq"><span class="name">QPF</span>.<span class="name">recF_eq</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.recF_eq'"><span class="name">QPF</span>.<span class="name">recF_eq'</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Wequiv"><span class="name">QPF</span>.<span class="name">Wequiv</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.recF_eq_of_Wequiv"><span class="name">QPF</span>.<span class="name">recF_eq_of_Wequiv</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Wequiv.abs'"><span class="name">QPF</span>.<span class="name">Wequiv</span>.<span class="name">abs'</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Wequiv.refl"><span class="name">QPF</span>.<span class="name">Wequiv</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Wequiv.symm"><span class="name">QPF</span>.<span class="name">Wequiv</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Wrepr"><span class="name">QPF</span>.<span class="name">Wrepr</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Wrepr_equiv"><span class="name">QPF</span>.<span class="name">Wrepr_equiv</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Wsetoid"><span class="name">QPF</span>.<span class="name">Wsetoid</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix"><span class="name">QPF</span>.<span class="name">Fix</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix.rec"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">rec</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.fixToW"><span class="name">QPF</span>.<span class="name">fixToW</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix.mk"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix.dest"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">dest</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix.rec_eq"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">rec_eq</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix.ind_aux"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">ind_aux</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix.ind_rec"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">ind_rec</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix.rec_unique"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">rec_unique</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix.mk_dest"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">mk_dest</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix.dest_mk"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">dest_mk</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Fix.ind"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">ind</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.corecF"><span class="name">QPF</span>.<span class="name">corecF</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.corecF_eq"><span class="name">QPF</span>.<span class="name">corecF_eq</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.IsPrecongr"><span class="name">QPF</span>.<span class="name">IsPrecongr</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Mcongr"><span class="name">QPF</span>.<span class="name">Mcongr</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Cofix"><span class="name">QPF</span>.<span class="name">Cofix</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.instInhabitedCofixOfAP"><span class="name">QPF</span>.<span class="name">instInhabitedCofixOfAP</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Cofix.corec"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">corec</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Cofix.dest"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">dest</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Cofix.dest_corec"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">dest_corec</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Cofix.bisim_rel"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">bisim_rel</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Cofix.bisim"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">bisim</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.Cofix.bisim'"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">bisim'</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.comp"><span class="name">QPF</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.quotientQPF"><span class="name">QPF</span>.<span class="name">quotientQPF</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.mem_supp"><span class="name">QPF</span>.<span class="name">mem_supp</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.supp_eq"><span class="name">QPF</span>.<span class="name">supp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.has_good_supp_iff"><span class="name">QPF</span>.<span class="name">has_good_supp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.IsUniform"><span class="name">QPF</span>.<span class="name">IsUniform</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.LiftpPreservation"><span class="name">QPF</span>.<span class="name">LiftpPreservation</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.SuppPreservation"><span class="name">QPF</span>.<span class="name">SuppPreservation</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.supp_eq_of_isUniform"><span class="name">QPF</span>.<span class="name">supp_eq_of_isUniform</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.liftp_iff_of_isUniform"><span class="name">QPF</span>.<span class="name">liftp_iff_of_isUniform</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.supp_map"><span class="name">QPF</span>.<span class="name">supp_map</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.suppPreservation_iff_uniform"><span class="name">QPF</span>.<span class="name">suppPreservation_iff_uniform</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.suppPreservation_iff_liftpPreservation"><span class="name">QPF</span>.<span class="name">suppPreservation_iff_liftpPreservation</span></a></div><div class="nav_link"><a class="break_within" href="#QPF.liftpPreservation_iff_uniform"><span class="name">QPF</span>.<span class="name">liftpPreservation_iff_uniform</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Quotients-of-Polynomial-Functors">Quotients of Polynomial Functors <a class="hover-link" href="#Quotients-of-Polynomial-Functors">#</a></h1><p>We assume the following:</p><ul>
<li><code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a></code>: a polynomial functor</li>
<li><code>W</code>: its W-type</li>
<li><code>M</code>: its M-type</li>
<li><code>F</code>: a functor</li>
</ul><p>We define:</p><ul>
<li><code>q</code>: <code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a></code> data, representing <code>F</code> as a quotient of <code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a></code></li>
</ul><p>The main goal is to construct:</p><ul>
<li><code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a></code>: the initial algebra with structure map <code>F <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> → <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a></code>.</li>
<li><code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a></code>: the final coalgebra with structure map <code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> → F <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a></code></li>
</ul><p>We also show that the composition of qpfs is a qpf, and that the quotient of a qpf
is a qpf.</p><p>The present theory focuses on the univariate case for qpfs</p><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li>[Jeremy Avigad, Mario M. Carneiro and Simon Hudon, <em>Data Types as Quotients of Polynomial
Functors</em>][avigad-carneiro-hudon2019]</li>
</ul></div><div class="decl" id="QPF"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L43-L54">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF"><span class="name">QPF</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../../../.././Init/Prelude.html#Functor">Functor</a> <span class="fn">F</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a> (u + 1)</div></div><p>Quotients of polynomial functors.</p><p>Roughly speaking, saying that <code>F</code> is a quotient of a polynomial functor means that for each <code>α</code>,
elements of <code>F α</code> are represented by pairs <code>⟨a, f⟩</code>, where <code>a</code> is the shape of the object and
<code>f</code> indexes the relevant elements of <code>α</code>, in a suitably natural manner.</p><ul class="structure_fields" id="QPF.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../../.././Init/Prelude.html#Functor.map">map</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span> → <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">F</span> <span class="fn">β</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../../.././Init/Prelude.html#Functor.mapConst">mapConst</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span></span></span></div></li><li id="QPF.P" class="structure_field"><div class="structure_field_info">P : <a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor">PFunctor.{u}</a></div></li><li id="QPF.abs" class="structure_field"><div class="structure_field_info">abs<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">↑<span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span></span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span></span></div></li><li id="QPF.repr" class="structure_field"><div class="structure_field_info">repr<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">↑<span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span></span> <span class="fn">α</span></span></span></div></li><li id="QPF.abs_repr" class="structure_field"><div class="structure_field_info">abs_repr<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
 : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.repr">repr</a> <span class="fn">x</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></div></li><li id="QPF.abs_map" class="structure_field"><div class="structure_field_info">abs_map<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">↑<span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span></span> <span class="fn">α</span></span>)</span></span>
 : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.map">map</a></span> <span class="fn">f</span> <span class="fn">p</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">p</span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-QPF" class="instances-list"></ul></details></div></div><div class="decl" id="QPF.id_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L68-L72">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.id_map"><span class="name">QPF</span>.<span class="name">id_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#id">id</a> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="QPF.comp_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L74-L79">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.comp_map"><span class="name">QPF</span>.<span class="name">comp_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">g</span> <a href="../../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>) <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="QPF.lawfulFunctor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L81-L86">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.lawfulFunctor"><span class="name">QPF</span>.<span class="name">lawfulFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">α </span><span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u), <a href="../../../.././Init/Prelude.html#Functor.mapConst">Functor.mapConst</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Functor.map">Functor.map</a> <a href="../../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Function.const">Function.const</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulFunctor">LawfulFunctor</a> <span class="fn">F</span></span></div></div></div></div><div class="decl" id="QPF.liftp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L95-L108">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.liftp_iff"><span class="name">QPF</span>.<span class="name">liftp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.Liftp">Functor.Liftp</a> <span class="fn">p</span> <span class="fn">x</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>) (<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn">α</span></span>), <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span></span></span></div></div></div></div><div class="decl" id="QPF.liftp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L110-L124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.liftp_iff'"><span class="name">QPF</span>.<span class="name">liftp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.Liftp">Functor.Liftp</a> <span class="fn">p</span> <span class="fn">x</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">u</span> : <span class="fn"><span class="fn">↑<span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span></span> <span class="fn">α</span></span>), <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">u</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn"><span class="fn">u</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn"><span class="fn">u</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">i</span>)</span></span></span></span></div></div></div></div><div class="decl" id="QPF.liftr_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L126-L145">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.liftr_iff"><span class="name">QPF</span>.<span class="name">liftr_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.Liftr">Functor.Liftr</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∃ (<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>) (<span class="fn">f₀</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn">α</span></span>) (<span class="fn">f₁</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn">α</span></span>),
    <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f₀</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f₁</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">(<span class="fn">f₀</span> <span class="fn">i</span>)</span> <span class="fn">(<span class="fn">f₁</span> <span class="fn">i</span>)</span></span></span></span></div></div></div></div><div class="decl" id="QPF.recF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L154-L156">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF"><span class="name">QPF</span>.<span class="name">recF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">α</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span> → <span class="fn">α</span></span></div></div><p>does recursion on <code>q.P.W</code> using <code>g : F α → α</code> rather than <code>g : <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> α → α</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">QPF.recF</a> <span class="fn">g</span> <span class="fn">(<a href="../../../.././Mathlib/Data/W/Basic.html#WType.mk">WType.mk</a> <span class="fn">a</span> <span class="fn">f</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span>) =&gt; <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">QPF.recF</a> <span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span>⟩</span>)</span></span></li></ul></details><details id="instances-for-list-QPF.recF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.recF_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L158-L161">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF_eq"><span class="name">QPF</span>.<span class="name">recF_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">α</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">recF</a> <span class="fn">g</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.map">map</a></span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">recF</a> <span class="fn">g</span>)</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W.dest">dest</a></span>)</span>)</span></span></div></div></div></div><div class="decl" id="QPF.recF_eq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L163-L165">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF_eq'"><span class="name">QPF</span>.<span class="name">recF_eq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">α</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">recF</a> <span class="fn">g</span> <span class="fn">(<a href="../../../.././Mathlib/Data/W/Basic.html#WType.mk">WType.mk</a> <span class="fn">a</span> <span class="fn">f</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.map">map</a></span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">recF</a> <span class="fn">g</span>)</span> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f</span>⟩</span>)</span>)</span></span></div></div></div></div><div class="decl" id="QPF.Wequiv"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L167-L172">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv"><span class="name">QPF</span>.<span class="name">Wequiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span> → <a href="../../../.././foundational_types.html">Prop</a></span></div></div><p>two trees are equivalent if their F-abstractions are</p><ul class="constructors"><li class="constructor" id="QPF.Wequiv.ind">ind<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span></span>)</span></span>
 : <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span>), <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span> <span class="fn">(<span class="fn">f'</span> <span class="fn">x</span>)</span></span>)</span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">(<a href="../../../.././Mathlib/Data/W/Basic.html#WType.mk">WType.mk</a> <span class="fn">a</span> <span class="fn">f</span>)</span> <span class="fn">(<a href="../../../.././Mathlib/Data/W/Basic.html#WType.mk">WType.mk</a> <span class="fn">a</span> <span class="fn">f'</span>)</span></span></span></li><li class="constructor" id="QPF.Wequiv.abs">abs<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a'</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span></span>)</span></span>
 : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn">⟨<span class="fn">a'</span>, <span class="fn">f'</span>⟩</span></span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">(<a href="../../../.././Mathlib/Data/W/Basic.html#WType.mk">WType.mk</a> <span class="fn">a</span> <span class="fn">f</span>)</span> <span class="fn">(<a href="../../../.././Mathlib/Data/W/Basic.html#WType.mk">WType.mk</a> <span class="fn">a'</span> <span class="fn">f'</span>)</span></span></span></li><li class="constructor" id="QPF.Wequiv.trans">trans<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">u </span><span class="fn">v </span><span class="fn">w</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span>)</span></span>
 : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">u</span> <span class="fn">v</span></span> → <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">v</span> <span class="fn">w</span></span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">u</span> <span class="fn">w</span></span></span></span></li></ul><details id="instances-for-list-QPF.Wequiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.recF_eq_of_Wequiv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L174-L181">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF_eq_of_Wequiv"><span class="name">QPF</span>.<span class="name">recF_eq_of_Wequiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">u</span> : <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">α</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">recF</a> <span class="fn">u</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">recF</a> <span class="fn">u</span> <span class="fn">y</span></span></span></div></div><p><code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">recF</a></code> is insensitive to the representation</p></div></div><div class="decl" id="QPF.Wequiv.abs'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L183-L187">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv.abs'"><span class="name">QPF</span>.<span class="name">Wequiv</span>.<span class="name">abs'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W.dest">dest</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn"><span class="fn">y</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W.dest">dest</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="QPF.Wequiv.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L189-L191">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv.refl"><span class="name">QPF</span>.<span class="name">Wequiv</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">x</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="QPF.Wequiv.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L193-L198">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv.symm"><span class="name">QPF</span>.<span class="name">Wequiv</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">y</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="QPF.Wrepr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L200-L202">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wrepr"><span class="name">QPF</span>.<span class="name">Wrepr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span></span></div></div><p>maps every element of the W type to a canonical representative</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wrepr">QPF.Wrepr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">QPF.recF</a> (<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W.mk">PFunctor.W.mk</a> <a href="../../../.././Init/Prelude.html#Function.comp">∘</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.repr">QPF.repr</a>)</span></li></ul></details><details id="instances-for-list-QPF.Wrepr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.Wrepr_equiv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L204-L212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wrepr_equiv"><span class="name">QPF</span>.<span class="name">Wrepr_equiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wrepr">Wrepr</a> <span class="fn">x</span>)</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="QPF.Wsetoid"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L214-L216">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wsetoid"><span class="name">QPF</span>.<span class="name">Wsetoid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Core.html#Setoid">Setoid</a> <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span></span></div></div><p>Define the fixed point as the quotient of trees under the equivalence relation <code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">Wequiv</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wsetoid">QPF.Wsetoid</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">r</span> := <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wequiv">QPF.Wequiv</a>, <span class="fn">iseqv</span> := <span class="fn">⋯</span> }</span></li></ul></details><details id="instances-for-list-QPF.Wsetoid" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.Fix"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L220-L222">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix"><span class="name">QPF</span>.<span class="name">Fix</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a> u</div></div><p>inductive type defined as initial algebra of a Quotient of Polynomial Functor</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">QPF.Fix</a> <span class="fn">F</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Core.html#Quotient">Quotient</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wsetoid">QPF.Wsetoid</a></span></li></ul></details><details id="instances-for-list-QPF.Fix" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.Fix.rec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L224-L226">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.rec"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">rec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">α</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span></span> → <span class="fn">α</span></span></div></div><p>recursor of a type defined by a qpf</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.rec">QPF.Fix.rec</a> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.recF">QPF.recF</a> <span class="fn">g</span>)</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-QPF.Fix.rec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.fixToW"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L228-L230">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.fixToW"><span class="name">QPF</span>.<span class="name">fixToW</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span></span></div></div><p>access the underlying W-type of a fixpoint data type</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.fixToW">QPF.fixToW</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Core.html#Quotient.lift">Quotient.lift</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wrepr">QPF.Wrepr</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-QPF.fixToW" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.Fix.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L232-L234">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span></span></div></div><p>constructor of a type defined by a qpf</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk">QPF.Fix.mk</a> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">(⇑<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Wsetoid">QPF.Wsetoid</a>)</span> <span class="fn">(<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W.mk">PFunctor.W.mk</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.map">map</a></span> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.fixToW">QPF.fixToW</a> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.repr">QPF.repr</a> <span class="fn">x</span>)</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-QPF.Fix.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.Fix.dest"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L236-L238">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.dest"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">dest</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span></span> → <span class="fn"><span class="fn">F</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span>)</span></span></span></div></div><p>destructor of a type defined by a qpf</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.dest">QPF.Fix.dest</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.rec">QPF.Fix.rec</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Functor.map">Functor.map</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk">QPF.Fix.mk</a>)</span></span></li></ul></details><details id="instances-for-list-QPF.Fix.dest" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.Fix.rec_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L240-L253">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.rec_eq"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">rec_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">α</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.rec">rec</a> <span class="fn">g</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk">mk</a> <span class="fn">x</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> (<span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.rec">rec</a> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span>)</span></div></div></div></div><div class="decl" id="QPF.Fix.ind_aux"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L255-L264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.ind_aux"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">ind_aux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.W">W</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk">mk</a> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Core.html#Quotient.mk">⟦</a><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span><a href="../../../.././Init/Core.html#Quotient.mk">⟧</a></span></span>⟩</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Core.html#Quotient.mk">⟦</a><span class="fn"><a href="../../../.././Mathlib/Data/W/Basic.html#WType.mk">WType.mk</a> <span class="fn">a</span> <span class="fn">f</span></span><a href="../../../.././Init/Core.html#Quotient.mk">⟧</a></span></div></div></div></div><div class="decl" id="QPF.Fix.ind_rec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L266-L275">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.ind_rec"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">ind_rec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g₁ </span><span class="fn">g₂</span> : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span>)</span></span>), <span class="fn"><span class="fn">g₁</span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g₂</span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span> → <span class="fn"><span class="fn">g₁</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk">mk</a> <span class="fn">x</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g₂</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk">mk</a> <span class="fn">x</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">g₁</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g₂</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="QPF.Fix.rec_unique"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L277-L282">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.rec_unique"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">rec_unique</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">α</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hyp</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span>)</span></span>), <span class="fn"><span class="fn">h</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk">mk</a> <span class="fn">x</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> (<span class="fn">h</span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.rec">rec</a> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="QPF.Fix.mk_dest"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L284-L290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk_dest"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">mk_dest</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk">mk</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.dest">dest</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="QPF.Fix.dest_mk"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L292-L298">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.dest_mk"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">dest_mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk">mk</a> <span class="fn">x</span>)</span>.<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.dest">dest</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="QPF.Fix.ind"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L300-L308">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.ind"><span class="name">QPF</span>.<span class="name">Fix</span>.<span class="name">ind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span></span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span>)</span></span>), <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.Liftp">Functor.Liftp</a> <span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix.mk">mk</a> <span class="fn">x</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Fix">Fix</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="QPF.corecF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L321-L323">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.corecF"><span class="name">QPF</span>.<span class="name">corecF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M">M</a></span></span></div></div><p>does recursion on <code>q.P.M</code> using <code>g : α → F α</code> rather than <code>g : α → <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> α</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.corecF">QPF.corecF</a> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M.corec">PFunctor.M.corec</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.repr">QPF.repr</a> <span class="fn">(<span class="fn">g</span> <span class="fn">x</span>)</span></span></span></span></li></ul></details><details id="instances-for-list-QPF.corecF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.corecF_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L325-L327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.corecF_eq"><span class="name">QPF</span>.<span class="name">corecF_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.corecF">corecF</a> <span class="fn">g</span> <span class="fn">x</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M.dest">dest</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.map">map</a></span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.corecF">corecF</a> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.repr">repr</a> <span class="fn">(<span class="fn">g</span> <span class="fn">x</span>)</span>)</span></span></div></div></div></div><div class="decl" id="QPF.IsPrecongr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L330-L333">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.IsPrecongr"><span class="name">QPF</span>.<span class="name">IsPrecongr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M">M</a></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M">M</a></span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Prop</a></div></div><p>A pre-congruence on <code>q.P.M</code> <em>viewed as an F-coalgebra</em>. Not necessarily symmetric.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.IsPrecongr">QPF.IsPrecongr</a> <span class="fn">r</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">∀ ⦃<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M">M</a></span>⦄, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.map">map</a></span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span>)</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M.dest">dest</a></span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.map">map</a></span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span>)</span> <span class="fn"><span class="fn">y</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M.dest">dest</a></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-QPF.IsPrecongr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.Mcongr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L335-L336">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Mcongr"><span class="name">QPF</span>.<span class="name">Mcongr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M">M</a></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M">M</a></span> → <a href="../../../.././foundational_types.html">Prop</a></span></div></div><p>The maximal congruence on <code>q.P.M</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Mcongr">QPF.Mcongr</a> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (<span class="fn">r</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M">M</a></span> → <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M">M</a></span> → <a href="../../../.././foundational_types.html">Prop</a></span>), <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.IsPrecongr">QPF.IsPrecongr</a> <span class="fn">r</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></li></ul></details><details id="instances-for-list-QPF.Mcongr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.Cofix"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L338-L340">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix"><span class="name">QPF</span>.<span class="name">Cofix</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a> u</div></div><p>coinductive type defined as the final coalgebra of a qpf</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">QPF.Cofix</a> <span class="fn">F</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Quot">Quot</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Mcongr">QPF.Mcongr</a></span></li></ul></details><details id="instances-for-list-QPF.Cofix" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.instInhabitedCofixOfAP"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L342-L343">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.instInhabitedCofixOfAP"><span class="name">QPF</span>.<span class="name">instInhabitedCofixOfAP</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.instInhabitedCofixOfAP">QPF.instInhabitedCofixOfAP</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href="../../../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Mcongr">QPF.Mcongr</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span> }</span></li></ul></details></div></div><div class="decl" id="QPF.Cofix.corec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L345-L347">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.corec"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">corec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span></div></div><p>corecursor for type defined by <code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.corec">QPF.Cofix.corec</a> <span class="fn">g</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Mcongr">QPF.Mcongr</a> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.corecF">QPF.corecF</a> <span class="fn">g</span> <span class="fn">x</span>)</span></span></li></ul></details><details id="instances-for-list-QPF.Cofix.corec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.Cofix.dest"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L349-L361">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.dest"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">dest</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span> → <span class="fn"><span class="fn">F</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span>)</span></span></span></div></div><p>destructor for type defined by <code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.dest">QPF.Cofix.dest</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M">M</a></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Mcongr">QPF.Mcongr</a></span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M.dest">dest</a></span></span>)</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-QPF.Cofix.dest" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.Cofix.dest_corec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L363-L369">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.dest_corec"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">dest_corec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.corec">corec</a> <span class="fn">g</span> <span class="fn">x</span>)</span>.<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.dest">dest</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.corec">corec</a> <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn"><span class="fn">g</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="QPF.Cofix.bisim_rel"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L399-L416">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.bisim_rel"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">bisim_rel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span></span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.dest">dest</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span></span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn"><span class="fn">y</span>.<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.dest">dest</a></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="QPF.Cofix.bisim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L418-L426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.bisim"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">bisim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.Liftr">Functor.Liftr</a> <span class="fn">r</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.dest">dest</a></span> <span class="fn"><span class="fn">y</span>.<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.dest">dest</a></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="QPF.Cofix.bisim'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L428-L438">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.bisim'"><span class="name">QPF</span>.<span class="name">Cofix</span>.<span class="name">bisim'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Q</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">u </span><span class="fn">v</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>),
    <span class="fn"><span class="fn"><span class="fn">Q</span> <span class="fn">x</span></span> →
      <span class="fn">∃ (<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>) (<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span></span>) (<span class="fn">f'</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix">Cofix</a> <span class="fn">F</span></span></span>),
        <span class="fn"><span class="fn">(<span class="fn">u</span> <span class="fn">x</span>)</span>.<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.dest">dest</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a>           <span class="fn"><span class="fn">(<span class="fn">v</span> <span class="fn">x</span>)</span>.<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.Cofix.dest">dest</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f'</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span>), <span class="fn">∃ (<span class="fn">x'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x'</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">f</span> <span class="fn">i</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">u</span> <span class="fn">x'</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">f'</span> <span class="fn">i</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">v</span> <span class="fn">x'</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">u</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">v</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="QPF.comp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L450-L490">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.comp"><span class="name">QPF</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F₂</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q₂</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F₂</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F₁</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q₁</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F₁</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">(<a href="../../../.././Mathlib/Control/Functor.html#Functor.Comp">Functor.Comp</a> <span class="fn">F₂</span> <span class="fn">F₁</span>)</span></span></div></div><p>composition of qpfs gives another qpf</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-QPF.comp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.quotientQPF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L506-L516">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.quotientQPF"><span class="name">QPF</span>.<span class="name">quotientQPF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Functor">Functor</a> <span class="fn">G</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">FG_abs</span> : <span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">G</span> <span class="fn">α</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">FG_repr</span> : <span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn"><span class="fn">G</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">FG_abs_repr</span> : <span class="fn">∀ {<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u} (<span class="fn">x</span> : <span class="fn"><span class="fn">G</span> <span class="fn">α</span></span>), <span class="fn"><span class="fn">FG_abs</span> <span class="fn">(<span class="fn">FG_repr</span> <span class="fn">x</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">FG_abs_map</span> : <span class="fn">∀ {<span class="fn">α </span><span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u} (<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>), <span class="fn"><span class="fn">FG_abs</span> (<span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn"><span class="fn">FG_abs</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">G</span></span></div></div><p>Given a qpf <code>F</code> and a well-behaved surjection <code>FG_abs</code> from <code>F α</code> to
functor <code>G α</code>, <code>G</code> is a qpf. We can consider <code>G</code> a quotient on <code>F</code> where
elements <code>x y : F α</code> are in the same equivalence class if
<code>FG_abs x = FG_abs y</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-QPF.quotientQPF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.mem_supp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L531-L542">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.mem_supp"><span class="name">QPF</span>.<span class="name">mem_supp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">u</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">u</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.supp">Functor.supp</a> <span class="fn">x</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>) (<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn">α</span></span>), <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span> → <span class="fn">u</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></span></div></div></div></div><div class="decl" id="QPF.supp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L544-L547">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.supp_eq"><span class="name">QPF</span>.<span class="name">supp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.supp">Functor.supp</a> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">u</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn">α</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>) (<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn">α</span></span>), <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span> → <span class="fn">u</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></span><a href="../../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></div></div></div></div><div class="decl" id="QPF.has_good_supp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L549-L572">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.has_good_supp_iff"><span class="name">QPF</span>.<span class="name">has_good_supp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>), <span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.Liftp">Functor.Liftp</a> <span class="fn">p</span> <span class="fn">x</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ <span class="fn">u</span> ∈ <span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.supp">Functor.supp</a> <span class="fn">x</span></span>, <span class="fn"><span class="fn">p</span> <span class="fn">u</span></span></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∃ (<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>) (<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn">α</span></span>),
    <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">a'</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>) (<span class="fn">f'</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a'</span></span> → <span class="fn">α</span></span>), <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a'</span>, <span class="fn">f'</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span> → <span class="fn">f</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> <a href="../../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">f'</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></span></span></div></div></div></div><div class="decl" id="QPF.IsUniform"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L574-L578">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.IsUniform"><span class="name">QPF</span>.<span class="name">IsUniform</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Prop</a></div></div><p>A qpf is said to be uniform if every polynomial functor
representing a single value all have the same range.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.IsUniform">QPF.IsUniform</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">∀ ⦃<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> ?u.21⦄ (<span class="fn">a </span><span class="fn">a'</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>) (<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn">α</span></span>) (<span class="fn">f'</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a'</span></span> → <span class="fn">α</span></span>),
    <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f</span>⟩</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn">⟨<span class="fn">a'</span>, <span class="fn">f'</span>⟩</span></span> → <span class="fn">f</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></span></li></ul></details><details id="instances-for-list-QPF.IsUniform" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.LiftpPreservation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L580-L582">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.LiftpPreservation"><span class="name">QPF</span>.<span class="name">LiftpPreservation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Prop</a></div></div><p>does <code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a></code> preserve <code>Liftp</code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.LiftpPreservation">QPF.LiftpPreservation</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">∀ ⦃<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> ?u.4⦄ (<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">↑<span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span></span> <span class="fn">α</span></span>), <span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.Liftp">Functor.Liftp</a> <span class="fn">p</span> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn">x</span>)</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.Liftp">Functor.Liftp</a> <span class="fn">p</span> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-QPF.LiftpPreservation" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.SuppPreservation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L584-L586">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.SuppPreservation"><span class="name">QPF</span>.<span class="name">SuppPreservation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Prop</a></div></div><p>does <code><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a></code> preserve <code>supp</code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.SuppPreservation">QPF.SuppPreservation</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ ⦃<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> ?u.13⦄ (<span class="fn">x</span> : <span class="fn"><span class="fn">↑<span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">QPF.P</a> <span class="fn">F</span>)</span></span> <span class="fn">α</span></span>), <span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.supp">Functor.supp</a> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">QPF.abs</a> <span class="fn">x</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.supp">Functor.supp</a> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-QPF.SuppPreservation" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="QPF.supp_eq_of_isUniform"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L588-L594">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.supp_eq_of_isUniform"><span class="name">QPF</span>.<span class="name">supp_eq_of_isUniform</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.IsUniform">IsUniform</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.A">A</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.P">P</a> <span class="fn">F</span>)</span>.<a href="../../../.././Mathlib/Data/PFunctor/Univariate/Basic.html#PFunctor.B">B</a></span> <span class="fn">a</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.supp">Functor.supp</a> <span class="fn">(<a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.abs">abs</a> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">f</span>⟩</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></div></div></div></div><div class="decl" id="QPF.liftp_iff_of_isUniform"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L596-L608">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.liftp_iff_of_isUniform"><span class="name">QPF</span>.<span class="name">liftp_iff_of_isUniform</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.IsUniform">IsUniform</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.Liftp">Functor.Liftp</a> <span class="fn">p</span> <span class="fn">x</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ <span class="fn">u</span> ∈ <span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.supp">Functor.supp</a> <span class="fn">x</span></span>, <span class="fn"><span class="fn">p</span> <span class="fn">u</span></span></span></div></div></div></div><div class="decl" id="QPF.supp_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L610-L613">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.supp_map"><span class="name">QPF</span>.<span class="name">supp_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.IsUniform">IsUniform</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">F</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.supp">Functor.supp</a> (<span class="fn">g</span> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn"><a href="../../../.././Mathlib/Control/Functor.html#Functor.supp">Functor.supp</a> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="QPF.suppPreservation_iff_uniform"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L615-L620">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.suppPreservation_iff_uniform"><span class="name">QPF</span>.<span class="name">suppPreservation_iff_uniform</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.SuppPreservation">SuppPreservation</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.IsUniform">IsUniform</a></div></div></div></div><div class="decl" id="QPF.suppPreservation_iff_liftpPreservation"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L622-L633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.suppPreservation_iff_liftpPreservation"><span class="name">QPF</span>.<span class="name">suppPreservation_iff_liftpPreservation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.SuppPreservation">SuppPreservation</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.LiftpPreservation">LiftpPreservation</a></div></div></div></div><div class="decl" id="QPF.liftpPreservation_iff_uniform"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/Data/QPF/Univariate/Basic.lean#L635-L636">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.liftpPreservation_iff_uniform"><span class="name">QPF</span>.<span class="name">liftpPreservation_iff_uniform</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> u → <a href="../../../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">q</span> : <span class="fn"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF">QPF</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.LiftpPreservation">LiftpPreservation</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Mathlib/Data/QPF/Univariate/Basic.html#QPF.IsUniform">IsUniform</a></div></div></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>