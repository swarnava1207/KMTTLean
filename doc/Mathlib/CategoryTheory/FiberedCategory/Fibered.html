<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.FiberedCategory.Fibered</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.FiberedCategory.Fibered";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">FiberedCategory</span>.<span class="name">Fibered</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html">Mathlib.CategoryTheory.FiberedCategory.Cartesian</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.FiberedCategory.Fibered" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsPreFibered"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsPreFibered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsPreFibered.exists_isCartesian"><span class="name">CategoryTheory</span>.<span class="name">IsPreFibered</span>.<span class="name">exists_isCartesian</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsFibered"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsFibered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCartesianCompOfIsFibered"><span class="name">CategoryTheory</span>.<span class="name">instIsCartesianCompOfIsFibered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsPreFibered.pullbackObj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsPreFibered</span>.<span class="name">pullbackObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsPreFibered.pullbackMap"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsPreFibered</span>.<span class="name">pullbackMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsPreFibered.pullbackMap.IsCartesian"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsPreFibered</span>.<span class="name">pullbackMap</span>.<span class="name">IsCartesian</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsPreFibered.pullbackObj_proj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsPreFibered</span>.<span class="name">pullbackObj_proj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsFibered.isStronglyCartesian_of_isCartesian"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsFibered</span>.<span class="name">isStronglyCartesian_of_isCartesian</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsFibered.isStronglyCartesian_of_exists_isCartesian"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsFibered</span>.<span class="name">isStronglyCartesian_of_exists_isCartesian</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsFibered.of_exists_isStronglyCartesian"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsFibered</span>.<span class="name">of_exists_isStronglyCartesian</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsFibered.pullbackPullbackIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsFibered</span>.<span class="name">pullbackPullbackIso</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Fibered-categories">Fibered categories <a class="hover-link" href="#Fibered-categories">#</a></h1><p>This file defines what it means for a functor <code>p : 𝒳 ⥤ 𝒮</code> to be (pre)fibered.</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><p><code><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered">IsPreFibered</a> p</code> expresses <code>𝒳</code> is fibered over <code>𝒮</code> via a functor <code>p : 𝒳 ⥤ 𝒮</code>, as in SGA VI.6.1.
This means that any morphism in the base <code>𝒮</code> can be lifted to a cartesian morphism in <code>𝒳</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered">IsFibered</a> p</code> expresses <code>𝒳</code> is fibered over <code>𝒮</code> via a functor <code>p : 𝒳 ⥤ 𝒮</code>, as in SGA VI.6.1.
This means that it is prefibered, and that the composition of any two cartesian morphisms is
cartesian.</p>
</li>
</ul><p>In the literature one often sees the notion of a fibered category defined as the existence of
strongly cartesian morphisms lying over any given morphism in the base. This is equivalent to the
notion above, and we give an alternate constructor <code>IsFibered.of_exists_isCartesian'</code> for
constructing a fibered category this way.</p><h2 class="markdown-heading" id="Implementation">Implementation <a class="hover-link" href="#Implementation">#</a></h2><p>The constructor of <code><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered">IsPreFibered</a></code> is called <code><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.exists_isCartesian'">exists_isCartesian'</a></code>. The reason for the prime is that
when wanting to apply this condition, it is recommended to instead use the lemma
<code><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.IsPreFibered.exists_isCartesian">exists_isCartesian</a></code> (without the prime), which is more applicable with respect to non-definitional
equalities.</p><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li><a href="https://arxiv.org/abs/math/0206203">A. Grothendieck, M. Raynaud, <em>SGA 1</em></a></li>
</ul></div><div class="decl" id="CategoryTheory.Functor.IsPreFibered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L49-L53">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsPreFibered</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Definition of a prefibered category.</p><p>See SGA 1 VI.6.1.</p><ul class="structure_fields" id="CategoryTheory.Functor.IsPreFibered.mk"><li id="CategoryTheory.Functor.IsPreFibered.exists_isCartesian'" class="structure_field"><div class="structure_field_info">exists_isCartesian'<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">a</span></span>)</span></span>
 : <a href="../../.././Init/Core.html#Exists">∃</a> <a href="../../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../../.././Init/Core.html#Exists">:</a> <span class="fn">𝒳</span><a href="../../.././Init/Core.html#Exists">)</a><a href="../../.././Init/Core.html#Exists">,</a> <a href="../../.././Init/Core.html#Exists">∃</a> <a href="../../.././Init/Core.html#Exists">(</a><span class="fn">φ</span> <a href="../../.././Init/Core.html#Exists">:</a> <span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">a</span><a href="../../.././Init/Core.html#Exists">)</a><a href="../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Functor.IsPreFibered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsPreFibered.exists_isCartesian"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L55-L57">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.IsPreFibered.exists_isCartesian"><span class="name">CategoryTheory</span>.<span class="name">IsPreFibered</span>.<span class="name">exists_isCartesian</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered">IsPreFibered</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R </span><span class="fn">S</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Core.html#Exists">∃</a> <a href="../../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../../.././Init/Core.html#Exists">:</a> <span class="fn">𝒳</span><a href="../../.././Init/Core.html#Exists">)</a><a href="../../.././Init/Core.html#Exists">,</a> <a href="../../.././Init/Core.html#Exists">∃</a> <a href="../../.././Init/Core.html#Exists">(</a><span class="fn">φ</span> <a href="../../.././Init/Core.html#Exists">:</a> <span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">a</span><a href="../../.././Init/Core.html#Exists">)</a><a href="../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.IsFibered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L59-L64">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsFibered</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered">IsPreFibered</a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Definition of a fibered category.</p><p>See SGA 1 VI.6.1.</p><ul class="structure_fields" id="CategoryTheory.Functor.IsFibered.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.exists_isCartesian'">exists_isCartesian'</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">a</span></span>)</span></span>
 : <a href="../../.././Init/Core.html#Exists">∃</a> <a href="../../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../../.././Init/Core.html#Exists">:</a> <span class="fn">𝒳</span><a href="../../.././Init/Core.html#Exists">)</a><a href="../../.././Init/Core.html#Exists">,</a> <a href="../../.././Init/Core.html#Exists">∃</a> <a href="../../.././Init/Core.html#Exists">(</a><span class="fn">φ</span> <a href="../../.././Init/Core.html#Exists">:</a> <span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">a</span><a href="../../.././Init/Core.html#Exists">)</a><a href="../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span></div></li><li id="CategoryTheory.Functor.IsFibered.comp" class="structure_field"><div class="structure_field_info">comp<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R </span><span class="fn">S </span><span class="fn">T</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">S</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">φ</span> : <span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ψ</span> : <span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">g</span> <span class="fn">ψ</span></span>]</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">φ</span> <span class="fn">ψ</span>)</span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Functor.IsFibered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCartesianCompOfIsFibered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L66-L68">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.instIsCartesianCompOfIsFibered"><span class="name">CategoryTheory</span>.<span class="name">instIsCartesianCompOfIsFibered</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered">IsFibered</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R </span><span class="fn">S </span><span class="fn">T</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">S</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">φ</span> : <span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ψ</span> : <span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">g</span> <span class="fn">ψ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">φ</span> <span class="fn">ψ</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.IsPreFibered.pullbackObj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L76-L80">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackObj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsPreFibered</span>.<span class="name">pullbackObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered">IsPreFibered</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R </span><span class="fn">S</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">𝒳</span></div></div><p>Given a fibered category <code>p : 𝒳 ⥤ 𝒫</code>, a morphism <code>f : R ⟶ S</code> and an object <code>a</code> lying over <code>S</code>,
then <code><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackObj">pullbackObj</a></code> is the domain of some choice of a cartesian morphism lying over <code>f</code> with
codomain <code>a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackObj">CategoryTheory.Functor.IsPreFibered.pullbackObj</a> <span class="fn">ha</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.IsPreFibered.pullbackObj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.IsPreFibered.pullbackMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L82-L85">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackMap"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsPreFibered</span>.<span class="name">pullbackMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered">IsPreFibered</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R </span><span class="fn">S</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackObj">pullbackObj</a> <span class="fn">ha</span> <span class="fn">f</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">a</span></div></div><p>Given a fibered category <code>p : 𝒳 ⥤ 𝒫</code>, a morphism <code>f : R ⟶ S</code> and an object <code>a</code> lying over <code>S</code>,
then <code><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackMap">pullbackMap</a></code> is a choice of a cartesian morphism lying over <code>f</code> with codomain <code>a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackMap">CategoryTheory.Functor.IsPreFibered.pullbackMap</a> <span class="fn">ha</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.IsPreFibered.pullbackMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.IsPreFibered.pullbackMap.IsCartesian"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L87-L88">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackMap.IsCartesian"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsPreFibered</span>.<span class="name">pullbackMap</span>.<span class="name">IsCartesian</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered">IsPreFibered</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R </span><span class="fn">S</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackMap">pullbackMap</a> <span class="fn">ha</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.IsPreFibered.pullbackObj_proj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L90-L91">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackObj_proj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsPreFibered</span>.<span class="name">pullbackObj_proj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered">IsPreFibered</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R </span><span class="fn">S</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackObj">pullbackObj</a> <span class="fn">ha</span> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">R</span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.IsFibered.isStronglyCartesian_of_isCartesian"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L99-L118">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered.isStronglyCartesian_of_isCartesian"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsFibered</span>.<span class="name">isStronglyCartesian_of_isCartesian</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered">IsFibered</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R </span><span class="fn">S</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">φ</span> : <span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsStronglyCartesian">IsStronglyCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span></div></div><p>In a fibered category, any cartesian morphism is strongly cartesian.</p></div></div><div class="decl" id="CategoryTheory.Functor.IsFibered.isStronglyCartesian_of_exists_isCartesian"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L120-L144">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered.isStronglyCartesian_of_exists_isCartesian"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsFibered</span>.<span class="name">isStronglyCartesian_of_exists_isCartesian</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">𝒳</span>) (<span class="fn">R</span> : <span class="fn">𝒮</span>) (<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">a</span></span>), <a href="../../.././Init/Core.html#Exists">∃</a> <a href="../../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../../.././Init/Core.html#Exists">:</a> <span class="fn">𝒳</span><a href="../../.././Init/Core.html#Exists">)</a><a href="../../.././Init/Core.html#Exists">,</a> <a href="../../.././Init/Core.html#Exists">∃</a> <a href="../../.././Init/Core.html#Exists">(</a><span class="fn">φ</span> <a href="../../.././Init/Core.html#Exists">:</a> <span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">a</span><a href="../../.././Init/Core.html#Exists">)</a><a href="../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsStronglyCartesian">IsStronglyCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R </span><span class="fn">S</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">φ</span> : <span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsCartesian">IsCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsStronglyCartesian">IsStronglyCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span></div></div><p>In a category which admits strongly cartesian pullbacks, any cartesian morphism is
strongly cartesian. This is a helper-lemma for the fact that admitting strongly cartesian pullbacks
implies being fibered.</p></div></div><div class="decl" id="CategoryTheory.Functor.IsFibered.of_exists_isStronglyCartesian"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L146-L167">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered.of_exists_isStronglyCartesian"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsFibered</span>.<span class="name">of_exists_isStronglyCartesian</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">𝒳</span>) (<span class="fn">R</span> : <span class="fn">𝒮</span>) (<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">a</span></span>), <a href="../../.././Init/Core.html#Exists">∃</a> <a href="../../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../../.././Init/Core.html#Exists">:</a> <span class="fn">𝒳</span><a href="../../.././Init/Core.html#Exists">)</a><a href="../../.././Init/Core.html#Exists">,</a> <a href="../../.././Init/Core.html#Exists">∃</a> <a href="../../.././Init/Core.html#Exists">(</a><span class="fn">φ</span> <a href="../../.././Init/Core.html#Exists">:</a> <span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">a</span><a href="../../.././Init/Core.html#Exists">)</a><a href="../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Cartesian.html#CategoryTheory.Functor.IsStronglyCartesian">IsStronglyCartesian</a></span> <span class="fn">f</span> <span class="fn">φ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered">IsFibered</a></span></div></div><p>Alternate constructor for <code><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered">IsFibered</a></code>, a functor <code>p : 𝒳 ⥤ 𝒴</code> is fibered if any diagram of the
form</p><pre><code>          a
          -
          |
          v
R --f--&gt; p(a)
</code></pre><p>admits a strongly cartesian lift <code>b ⟶ a</code> of <code>f</code>.</p></div></div><div class="decl" id="CategoryTheory.Functor.IsFibered.pullbackPullbackIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/FiberedCategory/Fibered.lean#L169-L182">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered.pullbackPullbackIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsFibered</span>.<span class="name">pullbackPullbackIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒮</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝒳</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">𝒮</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">𝒳</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">𝒳</span> <span class="fn">𝒮</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsFibered">IsFibered</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R </span><span class="fn">S </span><span class="fn">T</span> : <span class="fn">𝒮</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">𝒳</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">R</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">T</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackObj">IsPreFibered.pullbackObj</a> <span class="fn">ha</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/FiberedCategory/Fibered.html#CategoryTheory.Functor.IsPreFibered.pullbackObj">IsPreFibered.pullbackObj</a> <span class="fn">⋯</span> <span class="fn">g</span></span></div></div><p>Given a diagram</p><pre><code>                  a
                  -
                  |
                  v
T --g--&gt; R --f--&gt; S
</code></pre><p>we have an isomorphism <code>T ×_S a ≅ T ×_R (R ×_S a)</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.IsFibered.pullbackPullbackIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>