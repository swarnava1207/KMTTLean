<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Sites.Sheaf</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Sites.Sheaf";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Sites</span>.<span class="name">Sheaf</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Yoneda.html">Mathlib.CategoryTheory.Limits.Yoneda</a></li><li><a href="../../.././Mathlib/CategoryTheory/Preadditive/FunctorCategory.html">Mathlib.CategoryTheory.Preadditive.FunctorCategory</a></li><li><a href="../../.././Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html">Mathlib.CategoryTheory.Sites.EqualizerSheafCondition</a></li><li><a href="../../.././Mathlib/CategoryTheory/Sites/SheafOfTypes.html">Mathlib.CategoryTheory.Sites.SheafOfTypes</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Constructions/EpiMono.html">Mathlib.CategoryTheory.Limits.Constructions.EpiMono</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Shapes/Equalizers.html">Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Shapes/Products.html">Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Sites.Sheaf" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSeparated"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSeparated</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.conesEquivSieveCompatibleFamily"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">conesEquivSieveCompatibleFamily</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presieve.FamilyOfElements.SieveCompatible.cone"><span class="name">CategoryTheory</span>.<span class="name">Presieve</span>.<span class="name">FamilyOfElements</span>.<span class="name">SieveCompatible</span>.<span class="name">cone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.homEquivAmalgamation"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">homEquivAmalgamation</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isLimit_iff_isSheafFor"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isLimit_iff_isSheafFor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.subsingleton_iff_isSeparatedFor"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">subsingleton_iff_isSeparatedFor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_iff_isLimit"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isLimit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSeparated_iff_subsingleton"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSeparated_iff_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isLimit_iff_isSheafFor_presieve"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isLimit_iff_isSheafFor_presieve</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_iff_isLimit_pretopology"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isLimit_pretopology</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.amalgamate"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamate</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.amalgamate_map"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamate_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.amalgamate_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamate_map_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.hom_ext"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">hom_ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.hom_ext_ofArrows"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">hom_ext_ofArrows</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.existsUnique_amalgamation_ofArrows"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">existsUnique_amalgamation_ofArrows</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.exists_unique_amalgamation_ofArrows"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">exists_unique_amalgamation_ofArrows</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamateOfArrows</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows_map"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamateOfArrows_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamateOfArrows_map_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_of_iso_iff"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_of_iso_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_of_isTerminal"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_of_isTerminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.Hom"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.Hom.ext"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.Hom.ext_iff"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.instCategorySheaf"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">instCategorySheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.instCategorySheaf_comp_val"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">instCategorySheaf_comp_val</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.instCategorySheaf_id_val"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">instCategorySheaf_id_val</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.instInhabitedHom"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">instInhabitedHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.hom_ext"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">hom_ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.hom_ext_iff"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">hom_ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafToPresheaf"><span class="name">CategoryTheory</span>.<span class="name">sheafToPresheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafToPresheaf_map"><span class="name">CategoryTheory</span>.<span class="name">sheafToPresheaf_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafToPresheaf_obj"><span class="name">CategoryTheory</span>.<span class="name">sheafToPresheaf_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafSections"><span class="name">CategoryTheory</span>.<span class="name">sheafSections</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fullyFaithfulSheafToPresheaf"><span class="name">CategoryTheory</span>.<span class="name">fullyFaithfulSheafToPresheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fullyFaithfulSheafToPresheaf_preimage_val"><span class="name">CategoryTheory</span>.<span class="name">fullyFaithfulSheafToPresheaf_preimage_val</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.homEquiv"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">homEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instFullSheafFunctorOppositeSheafToPresheaf"><span class="name">CategoryTheory</span>.<span class="name">instFullSheafFunctorOppositeSheafToPresheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instFaithfulSheafFunctorOppositeSheafToPresheaf"><span class="name">CategoryTheory</span>.<span class="name">instFaithfulSheafFunctorOppositeSheafToPresheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instReflectsIsomorphismsSheafFunctorOppositeSheafToPresheaf"><span class="name">CategoryTheory</span>.<span class="name">instReflectsIsomorphismsSheafFunctorOppositeSheafToPresheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.Hom.mono_of_presheaf_mono"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">mono_of_presheaf_mono</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.Hom.epi_of_presheaf_epi"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">epi_of_presheaf_epi</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isSheaf_iff_isSheaf_of_type"><span class="name">CategoryTheory</span>.<span class="name">isSheaf_iff_isSheaf_of_type</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafOver"><span class="name">CategoryTheory</span>.<span class="name">sheafOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafOver_val"><span class="name">CategoryTheory</span>.<span class="name">sheafOver_val</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.isSheafFor"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">isSheafFor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_bot"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_bot</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafBotEquivalence"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafBotEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafBotEquivalence_inverse_obj_val"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence_inverse_obj_val</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafBotEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafBotEquivalence_inverse_map_val"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence_inverse_map_val</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafBotEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instInhabitedSheafBotGrothendieckTopologyType"><span class="name">CategoryTheory</span>.<span class="name">instInhabitedSheafBotGrothendieckTopologyType</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.isTerminalOfBotCover"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">isTerminalOfBotCover</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafHomHasZSMul"><span class="name">CategoryTheory</span>.<span class="name">sheafHomHasZSMul</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instSubHomSheaf"><span class="name">CategoryTheory</span>.<span class="name">instSubHomSheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instNegHomSheaf"><span class="name">CategoryTheory</span>.<span class="name">instNegHomSheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sheafHomHasNSMul"><span class="name">CategoryTheory</span>.<span class="name">sheafHomHasNSMul</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instZeroHomSheaf"><span class="name">CategoryTheory</span>.<span class="name">instZeroHomSheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instAddHomSheaf"><span class="name">CategoryTheory</span>.<span class="name">instAddHomSheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.Hom.add_app"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">add_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Sheaf.Hom.addCommGroup"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">addCommGroup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instPreadditiveSheaf"><span class="name">CategoryTheory</span>.<span class="name">instPreadditiveSheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isLimitOfIsSheaf"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isLimitOfIsSheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_iff_multifork"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_multifork</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf.isLimitMultifork"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">isLimitMultifork</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_iff_multiequalizer"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_multiequalizer</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.firstObj"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">firstObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.forkMap"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">forkMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.secondObj"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">secondObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.firstMap"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">firstMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.secondMap"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">secondMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.w"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.IsSheaf'"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheafForIsSheafFor'"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheafForIsSheafFor'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_iff_isSheaf'"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isSheaf'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_of_isSheaf_comp"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_of_isSheaf_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_comp_of_isSheaf"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_comp_of_isSheaf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_iff_isSheaf_comp"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isSheaf_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isSheaf_forget</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Sheaves-taking-values-in-a-category">Sheaves taking values in a category <a class="hover-link" href="#Sheaves-taking-values-in-a-category">#</a></h1><p>If C is a category with a Grothendieck topology, we define the notion of a sheaf taking values in
an arbitrary category <code>A</code>. We follow the definition in <a href="https://stacks.math.columbia.edu/tag/00VR">https://stacks.math.columbia.edu/tag/00VR</a>,
noting that the presheaf of sets &quot;defined above&quot; can be seen in the comments between tags 00VQ and
00VR on the page <a href="https://stacks.math.columbia.edu/tag/00VL">https://stacks.math.columbia.edu/tag/00VL</a>. The advantage of this definition is
that we need no assumptions whatsoever on <code>A</code> other than the assumption that the morphisms in <code>C</code>
and <code>A</code> live in the same universe.</p><ul>
<li>An <code>A</code>-valued presheaf <code>P : Cᵒᵖ ⥤ A</code> is defined to be a sheaf (for the topology <code>J</code>) iff for
every <code>E : A</code>, the type-valued presheaves of sets given by sending <code>U : Cᵒᵖ</code> to <code>Hom_{A}(E, P U)</code>
are all sheaves of sets, see <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">CategoryTheory.Presheaf.IsSheaf</a></code>.</li>
<li>When <code>A = Type</code>, this recovers the basic definition of sheaves of sets, see
<code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.isSheaf_iff_isSheaf_of_type">CategoryTheory.isSheaf_iff_isSheaf_of_type</a></code>.</li>
<li>A alternate definition in terms of limits, unconditionally equivalent to the original one:
see <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_isLimit">CategoryTheory.Presheaf.isSheaf_iff_isLimit</a></code>.</li>
<li>An alternate definition when <code>C</code> is small, has pullbacks and <code>A</code> has products is given by an
equalizer condition <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf'">CategoryTheory.Presheaf.IsSheaf'</a></code>. This is equivalent to the earlier
definition, shown in <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_isSheaf'">CategoryTheory.Presheaf.isSheaf_iff_isSheaf'</a></code>.</li>
<li>When <code>A = Type</code>, this is <em>definitionally</em> equal to the equalizer condition for presieves in
<code>CategoryTheory.Sites.SheafOfTypes</code>.</li>
<li>When <code>A</code> has limits and there is a functor <code>s : A ⥤ Type</code> which is faithful, reflects isomorphisms
and preserves limits, then <code>P : Cᵒᵖ ⥤ A</code> is a sheaf iff the underlying presheaf of types
<code>P ⋙ s : Cᵒᵖ ⥤ Type</code> is a sheaf (<code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget">CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget</a></code>).
Cf <a href="https://stacks.math.columbia.edu/tag/0073">https://stacks.math.columbia.edu/tag/0073</a>, which is a weaker version of this statement (it's
only over spaces, not sites) and <a href="https://stacks.math.columbia.edu/tag/00YR">https://stacks.math.columbia.edu/tag/00YR</a> (a), which
additionally assumes filtered colimits.</li>
</ul><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>Occasionally we need to take a limit in <code>A</code> of a collection of morphisms of <code>C</code> indexed
by a collection of objects in <code>C</code>. This turns out to force the morphisms of <code>A</code> to be
in a sufficiently large universe. Rather than use <code><a href="../../.././Mathlib/Logic/UnivLE.html#UnivLE">UnivLE</a></code> we prove some results for
a category <code>A'</code> instead, whose morphism universe of <code>A'</code> is defined to be <code>max u₁ v₁</code>, where
<code>u₁, v₁</code> are the universes for <code>C</code>. Perhaps after we get better at handling universe
inequalities this can be changed.</p></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L70-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A sheaf of A is a presheaf P : Cᵒᵖ =&gt; A such that for every E : A, the
presheaf of types given by sending U : C to Hom_{A}(E, P U) is a sheaf of types.</p><p><a href="https://stacks.math.columbia.edu/tag/00VR">Stacks Tag 00VR</a></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">CategoryTheory.Presheaf.IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">∀ (<span class="fn">E</span> : <span class="fn">A</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf">CategoryTheory.Presieve.IsSheaf</a> <span class="fn">J</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">CategoryTheory.coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">E</span>)</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.IsSheaf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSeparated"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L76-L81">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSeparated"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSeparated</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">FA</span> : <span class="fn"><span class="fn">A</span> → <span class="fn">A</span> → <a href="../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">CA</span> : <span class="fn"><span class="fn">A</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">A</span>) → <span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">(<span class="fn">FA</span> <span class="fn">X</span> <span class="fn">Y</span>)</span> <span class="fn">(<span class="fn">CA</span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn">CA</span> <span class="fn">Y</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory">ConcreteCategory</a> <span class="fn">A</span> <span class="fn">FA</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Condition that a presheaf with values in a concrete category is separated for
a Grothendieck topology.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.IsSeparated" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.conesEquivSieveCompatibleFamily"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L89-L110">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.conesEquivSieveCompatibleFamily"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">conesEquivSieveCompatibleFamily</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve">Sieve</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">E</span> : <span class="fn">A</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.diagram">diagram</a></span>.<a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">P</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.cones">cones</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">E</span></span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a>   <a href="../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Subtype">:</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements">Presieve.FamilyOfElements</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">E</span>)</span>)</span> <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span></span> <a href="../../.././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements.SieveCompatible">SieveCompatible</a></span> <a href="../../.././Init/Prelude.html#Subtype">}</a></div></div><p>Given a sieve <code>S</code> on <code>X : C</code>, a presheaf <code>P : Cᵒᵖ ⥤ A</code>, and an object <code>E</code> of <code>A</code>,
the cones over the natural diagram <code>S.arrows.diagram.op ⋙ P</code> associated to <code>S</code> and <code>P</code>
with cone point <code>E</code> are in 1-1 correspondence with sieve_compatible family of elements
for the sieve <code>S</code> and the presheaf of types <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom">Hom</a> (E, P -)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.conesEquivSieveCompatibleFamily" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presieve.FamilyOfElements.SieveCompatible.cone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L115-L120">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presieve.FamilyOfElements.SieveCompatible.cone"><span class="name">CategoryTheory</span>.<span class="name">Presieve</span>.<span class="name">FamilyOfElements</span>.<span class="name">SieveCompatible</span>.<span class="name">cone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve">Sieve</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements">FamilyOfElements</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">E</span>)</span>)</span> <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements.SieveCompatible">SieveCompatible</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.diagram">diagram</a></span>.<a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">P</span>)</span></span></div></div><p>The cone corresponding to a sieve_compatible family of elements, dot notation enabled.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">hx</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presieve.FamilyOfElements.SieveCompatible.cone">cone</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">E</span></span>, <span class="fn">π</span> := <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.conesEquivSieveCompatibleFamily">CategoryTheory.Presheaf.conesEquivSieveCompatibleFamily</a> <span class="fn">P</span> <span class="fn">S</span> <span class="fn">E</span>)</span>.<a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.invFun">invFun</a></span> <span class="fn">⟨<span class="fn">x</span>, <span class="fn">hx</span>⟩</span></span> }</span></li></ul></details><details id="instances-for-list-CategoryTheory.Presieve.FamilyOfElements.SieveCompatible.cone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.homEquivAmalgamation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L122-L130">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.homEquivAmalgamation"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">homEquivAmalgamation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve">Sieve</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements">Presieve.FamilyOfElements</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">E</span>)</span>)</span> <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements.SieveCompatible">SieveCompatible</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">hx</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presieve.FamilyOfElements.SieveCompatible.cone">cone</a></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">cocone</a></span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></span></span>) <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <a href="../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">t</span> <a href="../../.././Init/Prelude.html#Subtype">:</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">E</span>)</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span> <a href="../../.././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation">IsAmalgamation</a></span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Subtype">}</a></div></div><p>Cone morphisms from the cone corresponding to a sieve_compatible family to the natural
cone associated to a sieve <code>S</code> and a presheaf <code>P</code> are in 1-1 correspondence with amalgamations
of the family.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.homEquivAmalgamation" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.isLimit_iff_isSheafFor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L134-L151">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isLimit_iff_isSheafFor"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isLimit_iff_isSheafFor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve">Sieve</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">Limits.IsLimit</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">cocone</a></span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></span>)</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">E</span> : <span class="fn">A</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor">Presieve.IsSheafFor</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">E</span>)</span>)</span> <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span></span></span></div></div><p>Given sieve <code>S</code> and presheaf <code>P : Cᵒᵖ ⥤ A</code>, their natural associated cone is a limit cone
iff <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom">Hom</a> (E, P -)</code> is a sheaf of types for the sieve <code>S</code> and all <code>E : A</code>.</p></div></div><div class="decl" id="CategoryTheory.Presheaf.subsingleton_iff_isSeparatedFor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L153-L175">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.subsingleton_iff_isSeparatedFor"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">subsingleton_iff_isSeparatedFor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve">Sieve</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.diagram">diagram</a></span>.<a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">P</span>)</span></span>), <span class="fn"><a href="../../.././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">cocone</a></span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></span></span>)</span>)</span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">E</span> : <span class="fn">A</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSeparatedFor">Presieve.IsSeparatedFor</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">E</span>)</span>)</span> <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span></span></span></div></div><p>Given sieve <code>S</code> and presheaf <code>P : Cᵒᵖ ⥤ A</code>, their natural associated cone admits at most one
morphism from every cone in the same category (i.e. over the same diagram),
iff <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom">Hom</a> (E, P -)</code>is separated for the sieve <code>S</code> and all <code>E : A</code>.</p></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_iff_isLimit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L177-L183">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_isLimit"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isLimit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ ⦃<span class="fn">X</span> : <span class="fn">C</span>⦄, <span class="fn">∀ <span class="fn">S</span> ∈ <span class="fn"><span class="fn">J</span> <span class="fn">X</span></span>, <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">Limits.IsLimit</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">cocone</a></span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></span>)</span>)</span></span></span></span></div></div><p>A presheaf <code>P</code> is a sheaf for the Grothendieck topology <code>J</code> iff for every covering sieve
<code>S</code> of <code>J</code>, the natural cone associated to <code>P</code> and <code>S</code> is a limit cone.</p></div></div><div class="decl" id="CategoryTheory.Presheaf.isSeparated_iff_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L185-L192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSeparated_iff_subsingleton"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSeparated_iff_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">E</span> : <span class="fn">A</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSeparated">Presieve.IsSeparated</a> <span class="fn">J</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">E</span>)</span>)</span>)</span></span>)</span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ ⦃<span class="fn">X</span> : <span class="fn">C</span>⦄,
    <span class="fn">∀ <span class="fn">S</span> ∈ <span class="fn"><span class="fn">J</span> <span class="fn">X</span></span>, <span class="fn">∀ (<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.diagram">diagram</a></span>.<a href="../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">P</span>)</span></span>), <span class="fn"><a href="../../.././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn">c</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">cocone</a></span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></span></span>)</span></span></span></span></div></div><p>A presheaf <code>P</code> is separated for the Grothendieck topology <code>J</code> iff for every covering sieve
<code>S</code> of <code>J</code>, the natural cone associated to <code>P</code> and <code>S</code> admits at most one morphism from every
cone in the same category.</p></div></div><div class="decl" id="CategoryTheory.Presheaf.isLimit_iff_isSheafFor_presieve"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L194-L200">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isLimit_iff_isSheafFor_presieve"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isLimit_iff_isSheafFor_presieve</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">Presieve</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">Limits.IsLimit</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">Sieve.generate</a> <span class="fn">R</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">cocone</a></span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></span>)</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">E</span> : <span class="fn">A</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor">Presieve.IsSheafFor</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">E</span>)</span>)</span> <span class="fn">R</span></span></span></div></div><p>Given presieve <code>R</code> and presheaf <code>P : Cᵒᵖ ⥤ A</code>, the natural cone associated to <code>P</code> and
the sieve <code>Sieve.generate R</code> generated by <code>R</code> is a limit cone iff <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom">Hom</a> (E, P -)</code> is a
sheaf of types for the presieve <code>R</code> and all <code>E : A</code>.</p></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_iff_isLimit_pretopology"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L202-L213">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_isLimit_pretopology"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isLimit_pretopology</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPullbacks">Limits.HasPullbacks</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Pretopology.html#CategoryTheory.Pretopology">Pretopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Pretopology.html#CategoryTheory.Pretopology.toGrothendieck">Pretopology.toGrothendieck</a> <span class="fn">C</span> <span class="fn">K</span>)</span> <span class="fn">P</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ ⦃<span class="fn">X</span> : <span class="fn">C</span>⦄, <span class="fn">∀ <span class="fn">R</span> ∈ <span class="fn"><span class="fn"><span class="fn">K</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Pretopology.html#CategoryTheory.Pretopology.coverings">coverings</a></span> <span class="fn">X</span></span>, <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">Limits.IsLimit</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">Sieve.generate</a> <span class="fn">R</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">cocone</a></span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">op</a></span>)</span>)</span></span></span></span></div></div><p>A presheaf <code>P</code> is a sheaf for the Grothendieck topology generated by a pretopology <code>K</code>
iff for every covering presieve <code>R</code> of <code>K</code>, the natural cone associated to <code>P</code> and
<code>Sieve.generate R</code> is a limit cone.</p></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.amalgamate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L219-L228">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamate"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover">Cover</a></span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow">Arrow</a></span>) → <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">I</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Y">Y</a></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx</span> :
  <span class="fn">∀ ⦃<span class="fn">I₁ </span><span class="fn">I₂</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow">Arrow</a></span>⦄ (<span class="fn">r</span> : <span class="fn"><span class="fn"><span class="fn">I₁</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation">Relation</a></span> <span class="fn">I₂</span></span>),
    <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">I₁</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.g₁">g₁</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">I₂</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.g₂">g₂</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span></div></div><p>This is a wrapper around <code>Presieve.IsSheafFor.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamate">amalgamate</a></code> to be used below.
If <code>P</code>s a sheaf, <code>S</code> is a cover of <code>X</code>, and <code>x</code> is a collection of morphisms from <code>E</code>
to <code>P</code> evaluated at terms in the cover which are compatible, then we can amalgamate
the <code>x</code>s to obtain a single morphism <code>E ⟶ P.obj (op X)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">hP</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamate">amalgamate</a></span> <span class="fn">S</span> <span class="fn">x</span> <span class="fn">hx</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">⋯</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor.amalgamate">amalgamate</a></span> <span class="fn">(fun (<span class="fn">Y</span> : <span class="fn">C</span>) (<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>) (<span class="fn">hf</span> : <span class="fn"><span class="fn"><span class="fn">(↑<span class="fn">S</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span> <span class="fn">f</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <span class="fn">{ <span class="fn">Y</span> := <span class="fn">Y</span>, <span class="fn">f</span> := <span class="fn">f</span>, <span class="fn">hf</span> := <span class="fn">hf</span> }</span></span>)</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.IsSheaf.amalgamate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.amalgamate_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L230-L237">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamate_map"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamate_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover">Cover</a></span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow">Arrow</a></span>) → <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">I</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Y">Y</a></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx</span> :
  <span class="fn">∀ ⦃<span class="fn">I₁ </span><span class="fn">I₂</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow">Arrow</a></span>⦄ (<span class="fn">r</span> : <span class="fn"><span class="fn"><span class="fn">I₁</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation">Relation</a></span> <span class="fn">I₂</span></span>),
    <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">I₁</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.g₁">g₁</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">I₂</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.g₂">g₂</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow">Arrow</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">hP</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamate">amalgamate</a></span> <span class="fn">S</span> <span class="fn">x</span> <span class="fn">hx</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn"><span class="fn">I</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.f">f</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <span class="fn">I</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.amalgamate_map_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L230-L230">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamate_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamate_map_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover">Cover</a></span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow">Arrow</a></span>) → <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">I</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Y">Y</a></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx</span> :
  <span class="fn">∀ ⦃<span class="fn">I₁ </span><span class="fn">I₂</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow">Arrow</a></span>⦄ (<span class="fn">r</span> : <span class="fn"><span class="fn"><span class="fn">I₁</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation">Relation</a></span> <span class="fn">I₂</span></span>),
    <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">I₁</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.g₁">g₁</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">I₂</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn"><span class="fn">r</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Relation.g₂">g₂</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow">Arrow</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">A</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">I</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.Y">Y</a></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">hP</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamate">amalgamate</a></span> <span class="fn">S</span> <span class="fn">x</span> <span class="fn">hx</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn"><span class="fn">I</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.f">f</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">I</span>)</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.hom_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L239-L242">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.hom_ext"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">hom_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover">Cover</a></span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e₁ </span><span class="fn">e₂</span> : <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow">Arrow</a></span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">e₁</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn"><span class="fn">I</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.f">f</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">e₂</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn"><span class="fn">I</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow.f">f</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e₂</span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.hom_ext_ofArrows"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L244-L252">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.hom_ext_ofArrows"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">hom_ext_ofArrows</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">I</span> → <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.ofArrows">Sieve.ofArrows</a> <span class="fn">X</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">J</span> <span class="fn">S</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">S</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">I</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">y</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.existsUnique_amalgamation_ofArrows"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L263-L266">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.existsUnique_amalgamation_ofArrows"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">existsUnique_amalgamation_ofArrows</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">I</span> → <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.ofArrows">Sieve.ofArrows</a> <span class="fn">X</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">J</span> <span class="fn">S</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx</span> :
  <span class="fn">∀ ⦃<span class="fn">W</span> : <span class="fn">C</span>⦄ ⦃<span class="fn">i </span><span class="fn">j</span> : <span class="fn">I</span>⦄ (<span class="fn">a</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn">b</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>),
    <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">j</span>)</span></span> →
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">i</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">j</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">∃!</a> <span class="fn">g</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">:</a> <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">S</span>)</span></span><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">,</a> <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">I</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <span class="fn">i</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.exists_unique_amalgamation_ofArrows"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L268-L269">source</a></div><div class="attributes">@[deprecated CategoryTheory.Presheaf.IsSheaf.existsUnique_amalgamation_ofArrows (since := &quot;2024-12-17&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.exists_unique_amalgamation_ofArrows"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">exists_unique_amalgamation_ofArrows</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">I</span> → <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.ofArrows">Sieve.ofArrows</a> <span class="fn">X</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">J</span> <span class="fn">S</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx</span> :
  <span class="fn">∀ ⦃<span class="fn">W</span> : <span class="fn">C</span>⦄ ⦃<span class="fn">i </span><span class="fn">j</span> : <span class="fn">I</span>⦄ (<span class="fn">a</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn">b</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>),
    <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">j</span>)</span></span> →
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">i</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">j</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">∃!</a> <span class="fn">g</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">:</a> <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">S</span>)</span></span><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">,</a> <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">I</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <span class="fn">i</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.existsUnique_amalgamation_ofArrows">CategoryTheory.Presheaf.IsSheaf.existsUnique_amalgamation_ofArrows</a></code>.</p></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L271-L275">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamateOfArrows</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">I</span> → <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.ofArrows">Sieve.ofArrows</a> <span class="fn">X</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">J</span> <span class="fn">S</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx</span> :
  <span class="fn">∀ ⦃<span class="fn">W</span> : <span class="fn">C</span>⦄ ⦃<span class="fn">i </span><span class="fn">j</span> : <span class="fn">I</span>⦄ (<span class="fn">a</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn">b</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>),
    <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">j</span>)</span></span> →
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">i</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">j</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">S</span>)</span></span></div></div><p>If <code>P : Cᵒᵖ ⥤ A</code> is a sheaf and <code>f i : X i ⟶ S</code> is a covering family, then
a morphism <code>E ⟶ P.obj (op S)</code> can be constructed from a compatible family of
morphisms <code>x : E ⟶ P.obj (op (X i))</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">hP</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows">amalgamateOfArrows</a></span> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">x</span> <span class="fn">hx</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Classical.html#Exists.choose">Exists.choose</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L277-L280">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows_map"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamateOfArrows_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">I</span> → <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.ofArrows">Sieve.ofArrows</a> <span class="fn">X</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">J</span> <span class="fn">S</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx</span> :
  <span class="fn">∀ ⦃<span class="fn">W</span> : <span class="fn">C</span>⦄ ⦃<span class="fn">i </span><span class="fn">j</span> : <span class="fn">I</span>⦄ (<span class="fn">a</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn">b</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>),
    <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">j</span>)</span></span> →
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">i</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">j</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">hP</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows">amalgamateOfArrows</a></span> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">x</span> <span class="fn">hx</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <span class="fn">i</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows_map_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L277-L277">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">amalgamateOfArrows_map_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">I</span> → <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.ofArrows">Sieve.ofArrows</a> <span class="fn">X</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">J</span> <span class="fn">S</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn">A</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>) → <span class="fn">E</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx</span> :
  <span class="fn">∀ ⦃<span class="fn">W</span> : <span class="fn">C</span>⦄ ⦃<span class="fn">i </span><span class="fn">j</span> : <span class="fn">I</span>⦄ (<span class="fn">a</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>) (<span class="fn">b</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">X</span> <span class="fn">j</span></span>),
    <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">j</span>)</span></span> →
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">i</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">j</span>)</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">I</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">A</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">hP</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows">amalgamateOfArrows</a></span> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">x</span> <span class="fn">hx</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">x</span> <span class="fn">i</span>)</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_of_iso_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L284-L287">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_of_iso_iff"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_of_iso_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">P'</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">P</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">P'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P'</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_of_isTerminal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L291-L293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_of_isTerminal"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_of_isTerminal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">A</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hX</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/IsTerminal.html#CategoryTheory.Limits.IsTerminal">Limits.IsTerminal</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Const.html#CategoryTheory.Functor.const">Functor.const</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Sheaf"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L301-L306">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max (max (max u₁ u₂) v₁) v₂)</div></div><p>The category of sheaves taking values in <code>A</code> on a grothendieck topology.</p><ul class="structure_fields" id="CategoryTheory.Sheaf.mk"><li id="CategoryTheory.Sheaf.val" class="structure_field"><div class="structure_field_info">val : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span></div><div class="structure_field_doc"><p>the underlying presheaf</p></div></li><li id="CategoryTheory.Sheaf.cond" class="structure_field"><div class="structure_field_info">cond : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">Presheaf.IsSheaf</a> <span class="fn">J</span> <span class="fn"><span class="fn">self</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span></span></div><div class="structure_field_doc"><p>the condition that the presheaf is a sheaf</p></div></li></ul><details id="instances-for-list-CategoryTheory.Sheaf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Sheaf.Hom"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L312-L316">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u₁ v₂)</div></div><p>Morphisms between sheaves are just morphisms of presheaves.</p><ul class="structure_fields" id="CategoryTheory.Sheaf.Hom.mk"><li id="CategoryTheory.Sheaf.Hom.val" class="structure_field"><div class="structure_field_info">val : <span class="fn"><span class="fn">X</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">Y</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span></div><div class="structure_field_doc"><p>a morphism between the underlying presheaves</p></div></li></ul><details id="instances-for-list-CategoryTheory.Sheaf.Hom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Sheaf.Hom.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L313-L313">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.ext"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝¹</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><span class="fn"><span class="fn">X</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom">Hom</a></span> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="CategoryTheory.Sheaf.Hom.ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L313-L313">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.ext_iff"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝¹</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><span class="fn"><span class="fn">X</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom">Hom</a></span> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Sheaf.instCategorySheaf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L318-L325">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.instCategorySheaf"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">instCategorySheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{max u₁ v₂, max (max (max u₂ u₁) v₂) v₁}</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Sheaf.instCategorySheaf_comp_val"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L318-L318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.instCategorySheaf_comp_val"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">instCategorySheaf_comp_val</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X✝ </span><span class="fn">Y✝ </span><span class="fn">Z✝</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">X✝</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom">Hom</a></span> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn"><span class="fn">Y✝</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom">Hom</a></span> <span class="fn">Z✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Sheaf.instCategorySheaf_id_val"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L318-L318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.instCategorySheaf_id_val"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">instCategorySheaf_id_val</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x✝</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">x✝</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Sheaf.instInhabitedHom"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L328-L329">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.instInhabitedHom"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">instInhabitedHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><span class="fn">X</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom">Hom</a></span> <span class="fn">X</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">X</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.instInhabitedHom">instInhabitedHom</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span></span> }</span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Sheaf.hom_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L331-L333">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.hom_ext"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">hom_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="CategoryTheory.Sheaf.hom_ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L331-L331">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.hom_ext_iff"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">hom_ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">x</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span></div></div></div></div><div class="decl" id="CategoryTheory.sheafToPresheaf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L337-L343">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf"><span class="name">CategoryTheory</span>.<span class="name">sheafToPresheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span>)</span></span></div></div><p>The inclusion functor from sheaves to presheaves.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">CategoryTheory.sheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">obj</span> := <a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">CategoryTheory.Sheaf.val</a>, <span class="fn">map</span> := <span class="fn">fun {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">CategoryTheory.Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>} (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>) =&gt; <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span></span>, <span class="fn">map_id</span> := <span class="fn">⋯</span>,
    <span class="fn">map_comp</span> := <span class="fn">⋯</span> }</span></li></ul></details><details id="instances-for-list-CategoryTheory.sheafToPresheaf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.sheafToPresheaf_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L338-L338">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf_map"><span class="name">CategoryTheory</span>.<span class="name">sheafToPresheaf_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X✝ </span><span class="fn">Y✝</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">sheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span></div></div></div></div><div class="decl" id="CategoryTheory.sheafToPresheaf_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L338-L338">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf_obj"><span class="name">CategoryTheory</span>.<span class="name">sheafToPresheaf_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">self</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">sheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">self</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">self</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span></div></div></div></div><div class="decl" id="CategoryTheory.sheafSections"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L345-L346">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafSections"><span class="name">CategoryTheory</span>.<span class="name">sheafSections</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span> <span class="fn">A</span>)</span></span></div></div><p>The sections of a sheaf (i.e. evaluation as a presheaf on <code>C</code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafSections">CategoryTheory.sheafSections</a> <span class="fn">J</span> <span class="fn">A</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">CategoryTheory.sheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.flip">flip</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.sheafSections" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.fullyFaithfulSheafToPresheaf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L348-L351">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.fullyFaithfulSheafToPresheaf"><span class="name">CategoryTheory</span>.<span class="name">fullyFaithfulSheafToPresheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">sheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span></div></div><p>The functor <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> J A ⥤ Cᵒᵖ ⥤ A</code> is fully faithful.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.fullyFaithfulSheafToPresheaf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.fullyFaithfulSheafToPresheaf_preimage_val"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L349-L349">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.fullyFaithfulSheafToPresheaf_preimage_val"><span class="name">CategoryTheory</span>.<span class="name">fullyFaithfulSheafToPresheaf_preimage_val</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X✝ </span><span class="fn">Y✝</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">sheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">X✝</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">sheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.fullyFaithfulSheafToPresheaf">fullyFaithfulSheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful.preimage">preimage</a></span> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="CategoryTheory.Sheaf.homEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L354-L356">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.homEquiv"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">homEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>) <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> (<span class="fn"><span class="fn">X</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">Y</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span>)</div></div><p>The bijection <code>(X ⟶ Y) ≃ (X.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a> ⟶ Y.val)</code> when <code>X</code> and <code>Y</code> are sheaves.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.homEquiv">CategoryTheory.Sheaf.homEquiv</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.fullyFaithfulSheafToPresheaf">CategoryTheory.fullyFaithfulSheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful.homEquiv">homEquiv</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Sheaf.homEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.instFullSheafFunctorOppositeSheafToPresheaf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L358-L359">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instFullSheafFunctorOppositeSheafToPresheaf"><span class="name">CategoryTheory</span>.<span class="name">instFullSheafFunctorOppositeSheafToPresheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">sheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></div></div></div><div class="decl" id="CategoryTheory.instFaithfulSheafFunctorOppositeSheafToPresheaf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L361-L362">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instFaithfulSheafFunctorOppositeSheafToPresheaf"><span class="name">CategoryTheory</span>.<span class="name">instFaithfulSheafFunctorOppositeSheafToPresheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">sheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div></div></div><div class="decl" id="CategoryTheory.instReflectsIsomorphismsSheafFunctorOppositeSheafToPresheaf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L364-L365">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instReflectsIsomorphismsSheafFunctorOppositeSheafToPresheaf"><span class="name">CategoryTheory</span>.<span class="name">instReflectsIsomorphismsSheafFunctorOppositeSheafToPresheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">sheafToPresheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/ReflectsIso/Basic.html#CategoryTheory.Functor.ReflectsIsomorphisms">ReflectsIsomorphisms</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Sheaf.Hom.mono_of_presheaf_mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L367-L370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.mono_of_presheaf_mono"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">mono_of_presheaf_mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">f</span></span></div></div><p>This is stated as a lemma to prevent class search from forming a loop since a sheaf morphism is
monic if and only if it is monic as a presheaf morphism (under suitable assumption).</p></div></div><div class="decl" id="CategoryTheory.Sheaf.Hom.epi_of_presheaf_epi"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L372-L373">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.epi_of_presheaf_epi"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">epi_of_presheaf_epi</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isSheaf_iff_isSheaf_of_type"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L375-L393">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.isSheaf_iff_isSheaf_of_type"><span class="name">CategoryTheory</span>.<span class="name">isSheaf_iff_isSheaf_of_type</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <a href="../../.././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">Presheaf.IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf">Presieve.IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="CategoryTheory.sheafOver"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L395-L402">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafOver"><span class="name">CategoryTheory</span>.<span class="name">sheafOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ℱ</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">E</span> : <span class="fn">A</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <a href="../../.././foundational_types.html">(Type</a> v₂)</span></div></div><p>The sheaf of sections guaranteed by the sheaf condition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafOver">CategoryTheory.sheafOver</a> <span class="fn">ℱ</span> <span class="fn">E</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn"><span class="fn"><span class="fn"><span class="fn">ℱ</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">CategoryTheory.coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">E</span>)</span>)</span></span>, <span class="fn">cond</span> := <span class="fn">⋯</span> }</span></li></ul></details><details id="instances-for-list-CategoryTheory.sheafOver" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.sheafOver_val"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L396-L396">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafOver_val"><span class="name">CategoryTheory</span>.<span class="name">sheafOver_val</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ℱ</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">E</span> : <span class="fn">A</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafOver">sheafOver</a> <span class="fn">ℱ</span> <span class="fn">E</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">ℱ</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">E</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.isSheafFor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L405-L408">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.isSheafFor"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">isSheafFor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <a href="../../.././foundational_types.html">(Type</a> w)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve">Sieve</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hS</span> : <span class="fn">S</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">J</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor">Presieve.IsSheafFor</a> <span class="fn">P</span> <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.arrows">arrows</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_bot"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L411-L411">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_bot"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_bot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="CategoryTheory.sheafBotEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L413-L424">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a> <span class="fn">A</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span></div></div><p>The category of sheaves on the bottom (trivial) Grothendieck topology is
equivalent to the category of presheaves.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.sheafBotEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.sheafBotEquivalence_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L417-L417">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence">sheafBotEquivalence</a> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a>
    <span class="fn">(<span class="fn"><span class="fn">{ <span class="fn">obj</span> := <span class="fn">fun (<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>) =&gt; <span class="fn">{ <span class="fn">val</span> := <span class="fn">P</span>, <span class="fn">cond</span> := <span class="fn">⋯</span> }</span></span>,
          <span class="fn">map</span> := <span class="fn">fun {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>} (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>) =&gt; <span class="fn">{ <span class="fn">val</span> := <span class="fn">f</span> }</span></span>, <span class="fn">map_id</span> := <span class="fn">⋯</span>, <span class="fn">map_comp</span> := <span class="fn">⋯</span> }</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span>
      <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">sheafToPresheaf</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a> <span class="fn">A</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.sheafBotEquivalence_inverse_obj_val"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L417-L417">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence_inverse_obj_val"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence_inverse_obj_val</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence">sheafBotEquivalence</a> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">P</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">P</span></div></div></div></div><div class="decl" id="CategoryTheory.sheafBotEquivalence_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L417-L417">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence">sheafBotEquivalence</a> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a> <span class="fn">A</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.sheafBotEquivalence_inverse_map_val"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L417-L417">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence_inverse_map_val"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence_inverse_map_val</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X✝ </span><span class="fn">Y✝</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence">sheafBotEquivalence</a> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="CategoryTheory.sheafBotEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L417-L417">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">sheafBotEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafBotEquivalence">sheafBotEquivalence</a> <span class="fn">A</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafToPresheaf">sheafToPresheaf</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a> <span class="fn">A</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instInhabitedSheafBotGrothendieckTopologyType"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L426-L427">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instInhabitedSheafBotGrothendieckTopologyType"><span class="name">CategoryTheory</span>.<span class="name">instInhabitedSheafBotGrothendieckTopologyType</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a> <a href="../../.././foundational_types.html">(Type</a> w))</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Sheaf.isTerminalOfBotCover"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L431-L437">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.isTerminalOfBotCover"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">isTerminalOfBotCover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">J</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/IsTerminal.html#CategoryTheory.Limits.IsTerminal">Limits.IsTerminal</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></div></div><p>If the empty sieve is a cover of <code>X</code>, then <code>F(X)</code> is terminal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.isTerminalOfBotCover">isTerminalOfBotCover</a></span> <span class="fn">X</span> <span class="fn">H</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/IsTerminal.html#CategoryTheory.Limits.IsTerminal.ofUnique">CategoryTheory.Limits.IsTerminal.ofUnique</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val">val</a></span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Sheaf.isTerminalOfBotCover" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.sheafHomHasZSMul"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L445-L455">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafHomHasZSMul"><span class="name">CategoryTheory</span>.<span class="name">sheafHomHasZSMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Basic.html#CategoryTheory.Preadditive">Preadditive</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Algebra/Notation/Defs.html#SMul">SMul</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a> (<span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafHomHasZSMul">CategoryTheory.sheafHomHasZSMul</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">smul</span> := <span class="fn">fun (<span class="fn">n</span> : <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a>) (<span class="fn">f</span> : <span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>) =&gt; <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">app</span> := <span class="fn">fun (<span class="fn">U</span> : <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>) =&gt; <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">U</span></span></span>, <span class="fn">naturality</span> := <span class="fn">⋯</span> }</span> }</span></span> }</span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instSubHomSheaf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L457-L457">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instSubHomSheaf"><span class="name">CategoryTheory</span>.<span class="name">instSubHomSheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Basic.html#CategoryTheory.Preadditive">Preadditive</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Sub">Sub</a> (<span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instSubHomSheaf">CategoryTheory.instSubHomSheaf</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">sub</span> := <span class="fn">fun (<span class="fn">f</span> <span class="fn">g</span> : <span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>) =&gt; <span class="fn">{ <span class="fn">val</span> := <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> }</span></span> }</span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instNegHomSheaf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L459-L459">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instNegHomSheaf"><span class="name">CategoryTheory</span>.<span class="name">instNegHomSheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Basic.html#CategoryTheory.Preadditive">Preadditive</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Neg">Neg</a> (<span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instNegHomSheaf">CategoryTheory.instNegHomSheaf</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">neg</span> := <span class="fn">fun (<span class="fn">f</span> : <span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>) =&gt; <span class="fn">{ <span class="fn">val</span> := <a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> }</span></span> }</span></li></ul></details></div></div><div class="decl" id="CategoryTheory.sheafHomHasNSMul"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L461-L469">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafHomHasNSMul"><span class="name">CategoryTheory</span>.<span class="name">sheafHomHasNSMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Basic.html#CategoryTheory.Preadditive">Preadditive</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Algebra/Notation/Defs.html#SMul">SMul</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a> (<span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.sheafHomHasNSMul">CategoryTheory.sheafHomHasNSMul</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">smul</span> := <span class="fn">fun (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>) (<span class="fn">f</span> : <span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>) =&gt; <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">app</span> := <span class="fn">fun (<span class="fn">U</span> : <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>) =&gt; <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Notation/Defs.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">U</span></span></span>, <span class="fn">naturality</span> := <span class="fn">⋯</span> }</span> }</span></span> }</span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instZeroHomSheaf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L471-L471">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instZeroHomSheaf"><span class="name">CategoryTheory</span>.<span class="name">instZeroHomSheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Basic.html#CategoryTheory.Preadditive">Preadditive</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Zero">Zero</a> (<span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instZeroHomSheaf">CategoryTheory.instZeroHomSheaf</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">zero</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">0</span> }</span> }</span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instAddHomSheaf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L473-L473">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instAddHomSheaf"><span class="name">CategoryTheory</span>.<span class="name">instAddHomSheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Basic.html#CategoryTheory.Preadditive">Preadditive</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> (<span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instAddHomSheaf">CategoryTheory.instAddHomSheaf</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">add</span> := <span class="fn">fun (<span class="fn">f</span> <span class="fn">g</span> : <span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>) =&gt; <span class="fn">{ <span class="fn">val</span> := <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span> }</span></span> }</span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Sheaf.Hom.add_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L475-L477">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.add_app"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">add_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Basic.html#CategoryTheory.Preadditive">Preadditive</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">g</span>).<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">U</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">U</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span>.<a href="../../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">U</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Sheaf.Hom.addCommGroup"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L479-L482">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.addCommGroup"><span class="name">CategoryTheory</span>.<span class="name">Sheaf</span>.<span class="name">Hom</span>.<span class="name">addCommGroup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Basic.html#CategoryTheory.Preadditive">Preadditive</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> (<span class="fn">P</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.addCommGroup">CategoryTheory.Sheaf.Hom.addCommGroup</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Algebra/Group/InjSurj.html#Function.Injective.addCommGroup">Function.Injective.addCommGroup</a> <span class="fn">(fun (<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom">Hom</a></span> <span class="fn">Q</span></span>) =&gt; <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val">val</a></span>)</span> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instPreadditiveSheaf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L484-L485">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instPreadditiveSheaf"><span class="name">CategoryTheory</span>.<span class="name">instPreadditiveSheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Basic.html#CategoryTheory.Preadditive">Preadditive</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Basic.html#CategoryTheory.Preadditive">Preadditive</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">Sheaf</a> <span class="fn">J</span> <span class="fn">A</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.instPreadditiveSheaf">CategoryTheory.instPreadditiveSheaf</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">homGroup</span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf">CategoryTheory.Sheaf</a> <span class="fn">J</span> <span class="fn">A</span></span>) =&gt; <a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.addCommGroup">CategoryTheory.Sheaf.Hom.addCommGroup</a></span>, <span class="fn">add_comp</span> := <span class="fn">⋯</span>,
    <span class="fn">comp_add</span> := <span class="fn">⋯</span> }</span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.isLimitOfIsSheaf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L517-L534">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isLimitOfIsSheaf"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isLimitOfIsSheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover">Cover</a></span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">Limits.IsLimit</a> <span class="fn">(<span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.multifork">multifork</a></span> <span class="fn">P</span>)</span></span></div></div><p>When <code>P</code> is a sheaf and <code>S</code> is a cover, the associated multifork is a limit.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isLimitOfIsSheaf">CategoryTheory.Presheaf.isLimitOfIsSheaf</a> <span class="fn">J</span> <span class="fn">P</span> <span class="fn">S</span> <span class="fn">hP</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">lift</span> := <span class="fn">fun (<span class="fn">E</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.Multifork">CategoryTheory.Limits.Multifork</a> <span class="fn">(<span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.index">index</a></span> <span class="fn">P</span>)</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">hP</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.amalgamate">amalgamate</a></span> <span class="fn">S</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.Arrow">Arrow</a></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">E</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.Multifork.ι">ι</a></span> <span class="fn">x</span></span>)</span> <span class="fn">⋯</span></span></span>,
    <span class="fn">fac</span> := <span class="fn">⋯</span>, <span class="fn">uniq</span> := <span class="fn">⋯</span> }</span></li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.isLimitOfIsSheaf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_iff_multifork"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L536-L555">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_multifork"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_multifork</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>) (<span class="fn">S</span> : <span class="fn"><span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover">Cover</a></span> <span class="fn">X</span></span>), <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">Limits.IsLimit</a> <span class="fn">(<span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.multifork">multifork</a></span> <span class="fn">P</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf.isLimitMultifork"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L558-L563">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.isLimitMultifork"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf</span>.<span class="name">isLimitMultifork</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover">Cover</a></span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">Limits.IsLimit</a> <span class="fn">(<span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.multifork">multifork</a></span> <span class="fn">P</span>)</span></span></div></div><p>If <code>F : Cᵒᵖ ⥤ A</code> is a sheaf for a Grothendieck topology <code>J</code> on <code>C</code>,
and <code>S</code> is a cover of <code>X : C</code>, then the multifork <code>S.multifork F</code> is limit.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">hP</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf.isLimitMultifork">isLimitMultifork</a></span> <span class="fn">S</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Mathlib/Logic/Nonempty.html#Nonempty.some">some</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.IsSheaf.isLimitMultifork" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_iff_multiequalizer"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L565-L578">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_multiequalizer"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_multiequalizer</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>) (<span class="fn">S</span> : <span class="fn"><span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover">Cover</a></span> <span class="fn">X</span></span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMultiequalizer">Limits.HasMultiequalizer</a> <span class="fn">(<span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.index">index</a></span> <span class="fn">P</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>) (<span class="fn">S</span> : <span class="fn"><span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover">Cover</a></span> <span class="fn">X</span></span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn">(<span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.Cover.toMultiequalizer">toMultiequalizer</a></span> <span class="fn">P</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.firstObj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L587-L591">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.firstObj"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">firstObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">Presieve</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasProducts">Limits.HasProducts</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">A</span></div></div><p>The middle object of the fork diagram given in Equation (3) of [MM92], as well as the fork
diagram of the Stacks entry.</p><p><a href="https://stacks.math.columbia.edu/tag/00VM">Stacks Tag 00VM</a> (The middle object of the fork diagram there.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.firstObj">CategoryTheory.Presheaf.firstObj</a> <span class="fn">R</span> <span class="fn">P</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.piObj">∏ᶜ</a> <span class="fn">fun (<span class="fn">f</span> : <span class="fn">(<span class="fn">V</span> : <span class="fn">C</span>) × <a href="../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">V</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">U</span> <a href="../../.././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">R</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Subtype">}</a></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">f</span>.<a href="../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.firstObj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.forkMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L593-L597">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.forkMap"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">forkMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">Presieve</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasProducts">Limits.HasProducts</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">U</span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.firstObj">firstObj</a> <span class="fn">R</span> <span class="fn">P</span></span></div></div><p>The left morphism of the fork diagram given in Equation (3) of [MM92], as well as the fork
diagram of the Stacks entry.</p><p><a href="https://stacks.math.columbia.edu/tag/00VM">Stacks Tag 00VM</a> (The left morphism the fork diagram there.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.forkMap">CategoryTheory.Presheaf.forkMap</a> <span class="fn">R</span> <span class="fn">P</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.lift">CategoryTheory.Limits.Pi.lift</a> <span class="fn">fun (<span class="fn">f</span> : <span class="fn">(<span class="fn">V</span> : <span class="fn">C</span>) × <a href="../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">V</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">U</span> <a href="../../.././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">R</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Subtype">}</a></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Prefunctor.html#Prefunctor.map">map</a></span> <span class="fn"><span class="fn">(↑<span class="fn"><span class="fn">f</span>.<a href="../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span>.<a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.forkMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.secondObj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L601-L607">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.secondObj"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">secondObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">Presieve</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasProducts">Limits.HasProducts</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPullbacks">Limits.HasPullbacks</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">A</span></div></div><p>The rightmost object of the fork diagram of the Stacks entry, which
contains the data used to check a family of elements for a presieve is compatible.</p><p><a href="https://stacks.math.columbia.edu/tag/00VM">Stacks Tag 00VM</a> (The rightmost object of the fork diagram there.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.secondObj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.firstMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L609-L612">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.firstMap"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">firstMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">Presieve</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasProducts">Limits.HasProducts</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPullbacks">Limits.HasPullbacks</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.firstObj">firstObj</a> <span class="fn">R</span> <span class="fn">P</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.secondObj">secondObj</a> <span class="fn">R</span> <span class="fn">P</span></span></div></div><p>The map <code>pr₀*</code> of the Stacks entry.</p><p><a href="https://stacks.math.columbia.edu/tag/00VM">Stacks Tag 00VM</a> (The map <code>pr₀*</code> there.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.firstMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.secondMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L614-L617">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.secondMap"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">secondMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">Presieve</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasProducts">Limits.HasProducts</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPullbacks">Limits.HasPullbacks</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.firstObj">firstObj</a> <span class="fn">R</span> <span class="fn">P</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.secondObj">secondObj</a> <span class="fn">R</span> <span class="fn">P</span></span></div></div><p>The map <code>pr₁*</code> of the Stacks entry.</p><p><a href="https://stacks.math.columbia.edu/tag/00VM">Stacks Tag 00VM</a> (The map <code>pr₁*</code> there.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.secondMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L619-L625">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.w"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">Presieve</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasProducts">Limits.HasProducts</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPullbacks">Limits.HasPullbacks</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.forkMap">forkMap</a> <span class="fn">R</span> <span class="fn">P</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.firstMap">firstMap</a> <span class="fn">R</span> <span class="fn">P</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.forkMap">forkMap</a> <span class="fn">R</span> <span class="fn">P</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.secondMap">secondMap</a> <span class="fn">R</span> <span class="fn">P</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.IsSheaf'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L627-L631">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf'"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">IsSheaf'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasProducts">Limits.HasProducts</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPullbacks">Limits.HasPullbacks</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>An alternative definition of the sheaf condition in terms of equalizers. This is shown to be
equivalent in <code><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_isSheaf'">CategoryTheory.Presheaf.isSheaf_iff_isSheaf'</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.IsSheaf'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheafForIsSheafFor'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L635-L655">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheafForIsSheafFor'"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheafForIsSheafFor'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasProducts">Limits.HasProducts</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPullbacks">Limits.HasPullbacks</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">A</span> <a href="../../.././foundational_types.html">(Type</a> (max v₁ u₁))</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> (max v₁ u₁)), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Basic.html#CategoryTheory.Limits.PreservesLimitsOfShape">Limits.PreservesLimitsOfShape</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Discrete/Basic.html#CategoryTheory.Discrete">Discrete</a> <span class="fn">J</span>)</span> <span class="fn">s</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">Presieve</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">Limits.IsLimit</a> <span class="fn">(<span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Functor.mapCone">mapCone</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι">Limits.Fork.ofι</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.forkMap">forkMap</a> <span class="fn">R</span> <span class="fn">P</span>)</span> <span class="fn">⋯</span>)</span>)</span></span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">Limits.IsLimit</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι">Limits.Fork.ofι</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap">Equalizer.forkMap</a> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">s</span>)</span> <span class="fn">R</span>)</span> <span class="fn">⋯</span>)</span></span></div></div><p>(Implementation). An auxiliary lemma to convert between sheaf conditions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Presheaf.isSheafForIsSheafFor'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_iff_isSheaf'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L659-L678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_isSheaf'"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isSheaf'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A'</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{max v₁ u₁, u₂}</a> <span class="fn">A'</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P'</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasProducts">Limits.HasProducts</a> <span class="fn">A'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPullbacks">Limits.HasPullbacks</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P'</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf'">IsSheaf'</a> <span class="fn">J</span> <span class="fn">P'</span></span></div></div><p>The equalizer definition of a sheaf given by <code>isSheaf'</code> is equivalent to <code>isSheaf</code>.</p></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_of_isSheaf_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L684-L687">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_of_isSheaf_comp"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_of_isSheaf_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">A</span> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Basic.html#CategoryTheory.Limits.ReflectsLimitsOfSize">Limits.ReflectsLimitsOfSize.{v₁, max v₁ u₁, v₂, v₃, u₂, u₃}</a> <span class="fn">s</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">s</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_comp_of_isSheaf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L689-L692">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_comp_of_isSheaf"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_comp_of_isSheaf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">A</span> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Basic.html#CategoryTheory.Limits.PreservesLimitsOfSize">Limits.PreservesLimitsOfSize.{v₁, max v₁ u₁, v₂, v₃, u₂, u₃}</a> <span class="fn">s</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">s</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_iff_isSheaf_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L694-L698">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_isSheaf_comp"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isSheaf_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <a href="../../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">B</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">A</span> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasLimitsOfSize">Limits.HasLimitsOfSize.{v₁, max v₁ u₁, v₂, u₂}</a> <span class="fn">A</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Basic.html#CategoryTheory.Limits.PreservesLimitsOfSize">Limits.PreservesLimitsOfSize.{v₁, max v₁ u₁, v₂, v₃, u₂, u₃}</a> <span class="fn">s</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/ReflectsIso/Basic.html#CategoryTheory.Functor.ReflectsIsomorphisms">ReflectsIsomorphisms</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">s</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/0cc1f970691e01afdf9d8bb9f8307cd7b6aca12a/Mathlib/CategoryTheory/Sites/Sheaf.lean#L700-L713">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget"><span class="name">CategoryTheory</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isSheaf_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A'</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{max v₁ u₁, u₂}</a> <span class="fn">A'</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology">GrothendieckTopology</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P'</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a> <span class="fn">A'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">A'</span> <a href="../../.././foundational_types.html">(Type</a> (max v₁ u₁))</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasLimits">Limits.HasLimits</a> <span class="fn">A'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Basic.html#CategoryTheory.Limits.PreservesLimits">Limits.PreservesLimits</a> <span class="fn">s</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/ReflectsIso/Basic.html#CategoryTheory.Functor.ReflectsIsomorphisms">ReflectsIsomorphisms</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">P'</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Presheaf.IsSheaf">IsSheaf</a> <span class="fn">J</span> <span class="fn">(<span class="fn"><span class="fn">P'</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">s</span>)</span></span></div></div><p>For a concrete category <code>(A, s)</code> where the forgetful functor <code>s : A ⥤ Type v</code> preserves limits and
reflects isomorphisms, and <code>A</code> has limits, an <code>A</code>-valued presheaf <code>P : Cᵒᵖ ⥤ A</code> is a sheaf iff its
underlying <code>Type</code>-valued presheaf <code>P ⋙ s : Cᵒᵖ ⥤ Type</code> is a sheaf.</p><p>Note this lemma applies for &quot;algebraic&quot; categories, eg groups, abelian groups and rings, but not
for the category of topological spaces, topological rings, etc since reflecting isomorphisms doesn't
hold.</p></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>